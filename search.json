[{"title":"阅读代码的技巧","url":"%2F2021%2F08%2F09%2F%E9%98%85%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%80%E5%B7%A7%2F","content":"\n<img src=\"阅读代码的技巧/header.jpeg\" >\n\n## 前言\n\n记录一些阅读代码的一些技巧和知识点\n\n<!--more-->\n\n## 这个方法到底是哪里调用的？\n\n平日在阅读代码的时候，经常被跳来跳去的函数（或者是方法）调用栈绕晕，尤其是遇到多态和接口的时候，方法的实际执行的类和实现跟方法定义的位置很难通过 IDE 的跳转关系理清。一不小心就会把自己绕进去，好不容易理清了吧，时间久了再次看的时候又得理一遍，而且有些调用链特别长，那么有没有什么办法可以快速的知道方法调用栈呢？\n\n其实我们可以借助 Exception (准确来说是 Throwable) 的 `printStackTrace()` 方法打印调用栈。我们知道在发生异常的时候，一般会调用 e.printStackTrace() 打印错误信息，帮助我们定位到发生异常的位置。其实，我们也可以主动创建 Exception 对象去打印方法调用栈。\n\n比如在 `Activity` 的 `onCreate()` 方法中，我们想知道 Activity 到底是如何创建的。\n\n### 方法调用栈工具类\n\n我们首先创建一个工具类，方便复用\n\n\n```kotlin\nobject SystemTools {\n\n    fun printMethodTrace(tag: String) {\n        val trace = Exception(tag)\n        trace.printStackTrace()\n    }\n}\n```\n\n### Activity 生命周期调用链\n\n然后在 Activity 的生命周期中调用工具类\n\n```kotlin\nclass WrapContentActivity : BaseActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_wrap_content)\n        SystemTools.printMethodTrace(\"onCreate\")\n    }\n\n    override fun onResume() {\n        super.onResume()\n        SystemTools.printMethodTrace(\"onResume\")\n    }\n}\n```\n看一下输出结果：\n\n```shell\n\ncom.engineer.android.mini W: java.lang.Exception: onCreate\ncom.engineer.android.mini W:     at com.engineer.android.mini.util.SystemTools.printMethodTrace(SystemTools.kt:17)\ncom.engineer.android.mini W:     at com.engineer.android.mini.ui.pure.WrapContentActivity.onCreate(CustomViewPlayGround.kt:357)\ncom.engineer.android.mini W:     at android.app.Activity.performCreate(Activity.java:8000)\ncom.engineer.android.mini W:     at android.app.Activity.performCreate(Activity.java:7984)\ncom.engineer.android.mini W:     at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1309)\ncom.engineer.android.mini W:     at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3422)\ncom.engineer.android.mini W:     at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3601)\ncom.engineer.android.mini W:     at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:85)\ncom.engineer.android.mini W:     at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135)\ncom.engineer.android.mini W:     at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95)\ncom.engineer.android.mini W:     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2066)\ncom.engineer.android.mini W:     at android.os.Handler.dispatchMessage(Handler.java:106)\ncom.engineer.android.mini W:     at android.os.Looper.loop(Looper.java:223)\ncom.engineer.android.mini W:     at android.app.ActivityThread.main(ActivityThread.java:7656)\ncom.engineer.android.mini W:     at java.lang.reflect.Method.invoke(Native Method)\ncom.engineer.android.mini W:     at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:592)\ncom.engineer.android.mini W:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:947)\n\n```\n可以看到 ActivityThread.java（2066）行，内部类 H 接收到 Message 消息后，便开始了方法调用链，包括 `LaunchActivityItem.execute`,`handleLaunchActivity`,`performLaunchActivity`,`Instrumentation.callActivityOnCreate`,`performCreate` 等我们在 AMS 流程中经常看到这些方法。\n\n```shell\ncom.engineer.android.mini W: java.lang.Exception: onResume\ncom.engineer.android.mini W:     at com.engineer.android.mini.util.SystemTools.printMethodTrace(SystemTools.kt:17)\ncom.engineer.android.mini W:     at com.engineer.android.mini.ui.pure.WrapContentActivity.onResume(CustomViewPlayGround.kt:351)\ncom.engineer.android.mini W:     at android.app.Instrumentation.callActivityOnResume(Instrumentation.java:1456)\ncom.engineer.android.mini W:     at android.app.Activity.performResume(Activity.java:8135)\ncom.engineer.android.mini W:     at android.app.ActivityThread.performResumeActivity(ActivityThread.java:4434)\ncom.engineer.android.mini W:     at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:4476)\ncom.engineer.android.mini W:     at android.app.servertransaction.ResumeActivityItem.execute(ResumeActivityItem.java:52)\ncom.engineer.android.mini W:     at android.app.servertransaction.TransactionExecutor.executeLifecycleState(TransactionExecutor.java:176)\ncom.engineer.android.mini W:     at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:97)\ncom.engineer.android.mini W:     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2066)\ncom.engineer.android.mini W:     at android.os.Handler.dispatchMessage(Handler.java:106)\ncom.engineer.android.mini W:     at android.os.Looper.loop(Looper.java:223)\ncom.engineer.android.mini W:     at android.app.ActivityThread.main(ActivityThread.java:7656)\ncom.engineer.android.mini W:     at java.lang.reflect.Method.invoke(Native Method)\ncom.engineer.android.mini W:     at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:592)\ncom.engineer.android.mini W:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:947)\n```\nonResume 的调用也是类似 onCreate 都是由 `ActivityThread` 处理 Message 消息开始。\n\n\n### View measure \n\n可以再来看一个大家比较熟悉的 View measure 流程的代码。可以先思考一下，一个继承自View.java 的自定义 View 。其 OnMeasure 至少会执行多少次？\n\n```kotlin\nclass SimpleViewOne @JvmOverloads\nconstructor(\n    context: Context, attributeSet:\n    AttributeSet? = null, style: Int = 0\n) : View(context, attributeSet, style) {\n\n    // else logic \n\n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec)\n        // ... measure logic \n        SystemTools.printMethodTrace(\"SimpleViewOne\")\n    }\n}\n```\n[完整代码](https://github.com/REBOOTERS/MinApp)\n输出\n\n```shell\n\n2021-08-09 21:46:33.516 com.engineer.android.mini W: java.lang.Exception: SimpleViewOne\n2021-08-09 21:46:33.516 com.engineer.android.mini W:     at com.engineer.android.mini.util.SystemTools.printMethodTrace(SystemTools.kt:17)\n2021-08-09 21:46:33.516 com.engineer.android.mini W:     at com.engineer.android.mini.ui.pure.SimpleViewOne.onMeasure(CustomViewPlayGround.kt:86)\n2021-08-09 21:46:33.516 com.engineer.android.mini W:     at android.view.View.measure(View.java:25466)\n2021-08-09 21:46:33.516 com.engineer.android.mini W:     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:6957)\n2021-08-09 21:46:33.516 com.engineer.android.mini W:     at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1552)\n2021-08-09 21:46:33.516 com.engineer.android.mini W:     at android.widget.LinearLayout.measureVertical(LinearLayout.java:842)\n2021-08-09 21:46:33.516 com.engineer.android.mini W:     at android.widget.LinearLayout.onMeasure(LinearLayout.java:721)\n2021-08-09 21:46:33.516 com.engineer.android.mini W:     at android.view.View.measure(View.java:25466)\n2021-08-09 21:46:33.516 com.engineer.android.mini W:     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:6957)\n2021-08-09 21:46:33.517 com.engineer.android.mini W:     at android.widget.FrameLayout.onMeasure(FrameLayout.java:194)\n2021-08-09 21:46:33.517 com.engineer.android.mini W:     at androidx.appcompat.widget.ContentFrameLayout.onMeasure(ContentFrameLayout.java:145)\n2021-08-09 21:46:33.517 com.engineer.android.mini W:     at android.view.View.measure(View.java:25466)\n2021-08-09 21:46:33.517 com.engineer.android.mini W:     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:6957)\n2021-08-09 21:46:33.517 com.engineer.android.mini W:     at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1552)\n2021-08-09 21:46:33.518 com.engineer.android.mini W:     at android.widget.LinearLayout.measureVertical(LinearLayout.java:842)\n2021-08-09 21:46:33.518 com.engineer.android.mini W:     at android.widget.LinearLayout.onMeasure(LinearLayout.java:721)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.view.View.measure(View.java:25466)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:6957)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.widget.FrameLayout.onMeasure(FrameLayout.java:194)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.view.View.measure(View.java:25466)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:6957)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1552)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.widget.LinearLayout.measureVertical(LinearLayout.java:842)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.widget.LinearLayout.onMeasure(LinearLayout.java:721)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.view.View.measure(View.java:25466)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:6957)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.widget.FrameLayout.onMeasure(FrameLayout.java:194)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at com.android.internal.policy.DecorView.onMeasure(DecorView.java:747)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.view.View.measure(View.java:25466)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.view.ViewRootImpl.performMeasure(ViewRootImpl.java:3397)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.view.ViewRootImpl.measureHierarchy(ViewRootImpl.java:2228)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:2486)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1952)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:8171)\n2021-08-09 21:46:33.519 com.engineer.android.mini W:     at android.view.Choreographer$CallbackRecord.run(Choreographer.java:972)\n2021-08-09 21:46:33.520 com.engineer.android.mini W:     at android.view.Choreographer.doCallbacks(Choreographer.java:796)\n2021-08-09 21:46:33.520 com.engineer.android.mini W:     at android.view.Choreographer.doFrame(Choreographer.java:731)\n2021-08-09 21:46:33.520 com.engineer.android.mini W:     at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:957)\n2021-08-09 21:46:33.520 com.engineer.android.mini W:     at android.os.Handler.handleCallback(Handler.java:938)\n2021-08-09 21:46:33.520 com.engineer.android.mini W:     at android.os.Handler.dispatchMessage(Handler.java:99)\n2021-08-09 21:46:33.520 com.engineer.android.mini W:     at android.os.Looper.loop(Looper.java:223)\n2021-08-09 21:46:33.520 com.engineer.android.mini W:     at android.app.ActivityThread.main(ActivityThread.java:7656)\n2021-08-09 21:46:33.520 com.engineer.android.mini W:     at java.lang.reflect.Method.invoke(Native Method)\n2021-08-09 21:46:33.520 com.engineer.android.mini W:     at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:592)\n2021-08-09 21:46:33.520 com.engineer.android.mini W:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:947)\n\n\n2021-08-09 21:46:33.564 com.engineer.android.mini W: java.lang.Exception: SimpleViewOne\n2021-08-09 21:46:33.565 com.engineer.android.mini W:     at com.engineer.android.mini.util.SystemTools.printMethodTrace(SystemTools.kt:17)\n2021-08-09 21:46:33.565 com.engineer.android.mini W:     at com.engineer.android.mini.ui.pure.SimpleViewOne.onMeasure(CustomViewPlayGround.kt:86)\n2021-08-09 21:46:33.565 com.engineer.android.mini W:     at android.view.View.measure(View.java:25466)\n2021-08-09 21:46:33.565 com.engineer.android.mini W:     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:6957)\n2021-08-09 21:46:33.565 com.engineer.android.mini W:     at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1552)\n2021-08-09 21:46:33.565 com.engineer.android.mini W:     at android.widget.LinearLayout.measureVertical(LinearLayout.java:842)\n2021-08-09 21:46:33.565 com.engineer.android.mini W:     at android.widget.LinearLayout.onMeasure(LinearLayout.java:721)\n2021-08-09 21:46:33.565 com.engineer.android.mini W:     at android.view.View.measure(View.java:25466)\n2021-08-09 21:46:33.565 com.engineer.android.mini W:     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:6957)\n2021-08-09 21:46:33.565 com.engineer.android.mini W:     at android.widget.FrameLayout.onMeasure(FrameLayout.java:194)\n2021-08-09 21:46:33.565 com.engineer.android.mini W:     at androidx.appcompat.widget.ContentFrameLayout.onMeasure(ContentFrameLayout.java:145)\n2021-08-09 21:46:33.565 com.engineer.android.mini W:     at android.view.View.measure(View.java:25466)\n2021-08-09 21:46:33.565 com.engineer.android.mini W:     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:6957)\n2021-08-09 21:46:33.565 com.engineer.android.mini W:     at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1552)\n2021-08-09 21:46:33.566 com.engineer.android.mini W:     at android.widget.LinearLayout.measureVertical(LinearLayout.java:842)\n2021-08-09 21:46:33.566 com.engineer.android.mini W:     at android.widget.LinearLayout.onMeasure(LinearLayout.java:721)\n2021-08-09 21:46:33.566 com.engineer.android.mini W:     at android.view.View.measure(View.java:25466)\n2021-08-09 21:46:33.566 com.engineer.android.mini W:     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:6957)\n2021-08-09 21:46:33.566 com.engineer.android.mini W:     at android.widget.FrameLayout.onMeasure(FrameLayout.java:194)\n2021-08-09 21:46:33.566 com.engineer.android.mini W:     at android.view.View.measure(View.java:25466)\n2021-08-09 21:46:33.566 com.engineer.android.mini W:     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:6957)\n2021-08-09 21:46:33.566 com.engineer.android.mini W:     at android.widget.LinearLayout.measureChildBeforeLayout(LinearLayout.java:1552)\n2021-08-09 21:46:33.566 com.engineer.android.mini W:     at android.widget.LinearLayout.measureVertical(LinearLayout.java:842)\n2021-08-09 21:46:33.566 com.engineer.android.mini W:     at android.widget.LinearLayout.onMeasure(LinearLayout.java:721)\n2021-08-09 21:46:33.566 com.engineer.android.mini W:     at android.view.View.measure(View.java:25466)\n2021-08-09 21:46:33.566 com.engineer.android.mini W:     at android.view.ViewGroup.measureChildWithMargins(ViewGroup.java:6957)\n2021-08-09 21:46:33.566 com.engineer.android.mini W:     at android.widget.FrameLayout.onMeasure(FrameLayout.java:194)\n2021-08-09 21:46:33.566 com.engineer.android.mini W:     at com.android.internal.policy.DecorView.onMeasure(DecorView.java:747)\n2021-08-09 21:46:33.567 com.engineer.android.mini W:     at android.view.View.measure(View.java:25466)\n2021-08-09 21:46:33.567 com.engineer.android.mini W:     at android.view.ViewRootImpl.performMeasure(ViewRootImpl.java:3397)\n2021-08-09 21:46:33.567 com.engineer.android.mini W:     at android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:2880)\n2021-08-09 21:46:33.567 com.engineer.android.mini W:     at android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1952)\n2021-08-09 21:46:33.567 com.engineer.android.mini W:     at android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:8171)\n2021-08-09 21:46:33.567 com.engineer.android.mini W:     at android.view.Choreographer$CallbackRecord.run(Choreographer.java:972)\n2021-08-09 21:46:33.567 com.engineer.android.mini W:     at android.view.Choreographer.doCallbacks(Choreographer.java:796)\n2021-08-09 21:46:33.567 com.engineer.android.mini W:     at android.view.Choreographer.doFrame(Choreographer.java:731)\n2021-08-09 21:46:33.567 com.engineer.android.mini W:     at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:957)\n2021-08-09 21:46:33.567 com.engineer.android.mini W:     at android.os.Handler.handleCallback(Handler.java:938)\n2021-08-09 21:46:33.567 com.engineer.android.mini W:     at android.os.Handler.dispatchMessage(Handler.java:99)\n2021-08-09 21:46:33.567 com.engineer.android.mini W:     at android.os.Looper.loop(Looper.java:223)\n2021-08-09 21:46:33.567 com.engineer.android.mini W:     at android.app.ActivityThread.main(ActivityThread.java:7656)\n2021-08-09 21:46:33.567 com.engineer.android.mini W:     at java.lang.reflect.Method.invoke(Native Method)\n2021-08-09 21:46:33.567 com.engineer.android.mini W:     at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:592)\n2021-08-09 21:46:33.567 com.engineer.android.mini W:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:947)\n```\n可以看到 onMeasure 是会执行两次的。并不是日志重复了，仔细看的话可以发现两次的调用链是有差异的\n\n - **调用栈是按方法压栈的顺序打印的，所以需要倒着看。**\n - **我们只关注到 DecorView 的 onMeasure 之前的调用链，因为后面一定是相同的**\n\n第一次是 \n\n```java\ncom.android.internal.policy.DecorView.onMeasure(DecorView.java:747)\nandroid.view.View.measure(View.java:25466)\nandroid.view.ViewRootImpl.performMeasure(ViewRootImpl.java:3397)\nandroid.view.ViewRootImpl.measureHierarchy(ViewRootImpl.java:2228)\nandroid.view.ViewRootImpl.performTraversals(ViewRootImpl.java:2486)\nandroid.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1952)\n```\n\n第二次是 \n\n```java\ncom.android.internal.policy.DecorView.onMeasure(DecorView.java:747)\nandroid.view.View.measure(View.java:25466)\nandroid.view.ViewRootImpl.performMeasure(ViewRootImpl.java:3397)\nandroid.view.ViewRootImpl.performTraversals(ViewRootImpl.java:2880)\nandroid.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1952)\n```\n可以看到两次 performMeaure 是通过不同的方式发起的。\n\n可以看到，利用 Throwable 的 `printMethodTrace()` 方法。我们可以非常方便的获得复杂的方法调用链。这样的技巧不仅可以用在定位错误，阅读复杂源码的场景。也可以用在我们日常开发中，尤其是在方法调用链比较长，且包含接口、抽象类的时候，使用这个方法可以非常方便的让我们确定方法调用关键结点，甚至是行号。使用这个在日常开发中做很多事情，这里就不一一举例了，有兴趣的话可以自己尝试一下。\n\n## 位运算的逻辑其实很简\n\n我们经常在源码中看到使用位运算表达的逻辑。比如在 View 的 `measure` 方法中\n\n```java\n    public final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n\n        // Suppress sign extension for the low bytes\n        long key = (long) widthMeasureSpec << 32 | (long) heightMeasureSpec & 0xffffffffL;\n        if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);\n\n        final boolean forceLayout = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;\n\n        // 省略部分代码\n\n        if (forceLayout || needsLayout) {\n            // first clears the measured dimension flag\n            mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;\n\n            resolveRtlPropertiesIfNeeded();\n\n            int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);\n            if (cacheIndex < 0 || sIgnoreMeasureCache) {\n                // measure ourselves, this should set the measured dimension flag back\n                onMeasure(widthMeasureSpec, heightMeasureSpec);\n                mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;\n            } else {\n                long value = mMeasureCache.valueAt(cacheIndex);\n                // Casting a long to int drops the high 32 bits, no mask needed\n                setMeasuredDimensionRaw((int) (value >> 32), (int) value);\n                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;\n            }\n\n            // flag not set, setMeasuredDimension() was not invoked, we raise\n            // an exception to warn the developer\n            if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {\n                throw new IllegalStateException(\"View with id \" + getId() + \": \"\n                        + getClass().getName() + \"#onMeasure() did not set the\"\n                        + \" measured dimension by calling\"\n                        + \" setMeasuredDimension()\");\n            }\n\n            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;\n        }\n\n        mOldWidthMeasureSpec = widthMeasureSpec;\n        mOldHeightMeasureSpec = heightMeasureSpec;\n\n        mMeasureCache.put(key, ((long) mMeasuredWidth) << 32 |\n                (long) mMeasuredHeight & 0xffffffffL); // suppress sign extension\n    }\n```\n\n可以看到这么几行代码，大量使用 逻辑运算符进行了各种逻辑判断和处理，看的时候总是有种似懂非懂的感觉，这里就来简单总结一下。\n\n在之前 [二进制](https://rebooters.github.io/2020/12/28/%E4%BA%8C%E8%BF%9B%E5%88%B6/) 一文中，其实就二进制相关的运算的一些基础做过介绍，这里就结合一个具体的例子加深一下印象。\n\n### 鸡蛋灌饼你要加点啥？\n\n在 FantasyCake 中可以添加土豆丝、海带丝、生菜形式不同 style 的 cake。 同时在结算的时候会根据输入金额的限制去除掉某一项。\n\n```java\npublic class FantasyCake {\n    public static final int FLAG_ADD_POTATO_SHREDS  = 0x00000001; // 加土豆丝\n    public static final int FLAG_ADD_SEAWEED_STRIPS = 0x00000002; // 加海带丝\n    public static final int FLAG_ADD_LETTUCE        = 0x00000004; // 加生菜\n\n    private int style = 0; // 默认\n\n    @Override\n    public String toString() {\n        if ((this.style & FLAG_ADD_SEAWEED_STRIPS) != FLAG_ADD_SEAWEED_STRIPS) {\n            // 没有加海带丝时警告\n            System.err.println(\"without add seaweed_strips\");\n        }\n\n        return \"FantasyCake{\" +\n                \"style=\" + Integer.toBinaryString(this.style) +\n                '}';\n    }\n\n    public void addLettuce() {\n        this.style |= FLAG_ADD_LETTUCE;\n    }\n\n    public void addPotatoShreds() {\n        this.style |= FLAG_ADD_POTATO_SHREDS;\n    }\n\n    public void addSeaweedStrips() {\n        this.style |= FLAG_ADD_SEAWEED_STRIPS;\n    }\n\n    public int checkout(int money) {\n        int base = 5; // 基础价格 5\n\n        if ((style & FLAG_ADD_LETTUCE) == FLAG_ADD_LETTUCE) {\n            base = base + 1;  // 如果加生菜了，加 1\n        }\n\n        if ((style & FLAG_ADD_SEAWEED_STRIPS) == FLAG_ADD_SEAWEED_STRIPS) {\n            base = base + 2; // 如果加海带丝了 加 2\n        }\n\n        if ((style & FLAG_ADD_POTATO_SHREDS) == FLAG_ADD_POTATO_SHREDS) {\n            base = base + 3; // 如果加 土豆丝了 加 3\n        }\n\n        if (base > money) {\n            // 如果钱超了，把土豆丝去掉，重新算 （这里的逻辑其实可以写的复杂一点，按照金额去掉最小值，只是实例位运算用法，就不跑偏了）\n            style &= ~FLAG_ADD_POTATO_SHREDS;\n            return checkout(money);\n        }\n\n        return base;\n    }\n}\n```\n我们可以测试一下 ,完整代码参见 [FantasyCake.java](https://github.com/REBOOTERS/MinApp/blob/master/app/src/main/java/com/engineer/android/mini/better/FantasyCake.java)\n\n```kotlin\n// java 写的 main 方法 AS 编译不过了，只能用 kotlin 救急了\nfun main() {\n    val cake = FantasyCake()\n    println(cake)\n    cake.addLettuce()\n    cake.addPotatoShreds()\n    cake.addSeaweedStrips()\n    println(cake)\n    println(\"cost = ${cake.checkout(9)}\")\n    println(cake)\n}\n```\n输出\n\n```shell\nwithout add seaweed_strips\nFantasyCake{style=0}\nFantasyCake{style=111}\ncost = 8\nFantasyCake{style=110}\n```\n\n- 可以看到当 style 缺失 FLAG_ADD_SEAWEED_STRIPS 会输出警告。\n- 默认的 style 为 0\n- 添加 3 种 FLAG 后，style = 111 (符合预期)\n- 结算时，由于总额大于 9 ，去除了 FLAG_ADD_POTATO_SHREDS, 并重新结算结果为 8 。\n\n至此可以简单总结规律：\n\n- ` A |= FLAG_ANY ` 是对 A 进行写 FLAG_ANY 对应位的 1\n- ` A &= FLAG_ANY ` 是对 A 进行写 FLAG_ANY 对应位的 0 \n- ` (A & FLAG_ANY) == FLAG_ANY) ` 确保 A 有 FLAG_ANY 对应位的 1\n- ` (A & FLAG_ANY) != FLAG_ANY) ` 确保 A 没有 FLAG_ANY 对应位的 1,即为 0。\n\n还有常见的一种\n\n` (A & FLAG_ANY) != 0` 则表明在 A 当中，至少 FLAG_ANY 对应位的值是 1。这一标志位是开启的。\n\n在 Android 源码中，FLAG_XXX 常常对应的就是某个功能是否开启了，下次阅读源码的时候，按照上面的方式理解就好了。\n\n可以看到使用位运算有一个 64 字节的 Int 类型就相当于可以包含 64 个标志位，相比直接使用 boolean 值节省了不少内存。同时一旦习惯了这种用法会觉得写起来更方便。\n\n***\n\nmaybe continued\n\n\n\n\n\n\n\n\n\n","tags":["高效工作"]},{"title":"Java 代码执行时机","url":"%2F2021%2F07%2F31%2FJava-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%2F","content":"\n<img src=\"Java-代码执行时机/order.svg\" width=20%>\n\n## 前言\n\n简单了解一下 Java 代码中，成语变量、静态变量、代码块、构造函数之类的内容的执行顺序。\n\n从一个类的用途出发，他会经历 **类的加载、类的初始化、类的实例初始化** 这三个阶段。\n\n其中加载更多的虚拟机内部的细节，这里重点说一下类的初始化、类的实例化相关的内容。\n\n\n<!--more-->\n\n\n\n## 类的加载\n\nJava 做为一种解释执行的语言，我们编写的 java 代码通过 javac 命令编译之后，会被编译成相应的 class 文件。然后 Java 虚拟机会加载并执行这些文件。关于加载和执行的具体细节，按照《深入了解 Java 虚拟机》中的介绍，会按如下步骤进行。\n\n### class 文件的加载\n\n<img src=\"Java-代码执行时机/classloader.svg\" width=50%>\n\n从上图我们已经可以了解到一个 .class 文件到一个真实的 Java 对象之前会经历哪些步骤。这当中装载、链接、init 方法的执行等都是虚拟机细节相关的部分，这里我们重点看一下 类中各个成员变量的初始化。具体的执行细节阅读 [类的初始化深入探索](https://mp.weixin.qq.com/s/ozsOXBpKpF1GTrX-NPAuFg)。\n\n## 类的初始化和实例化\n\n在学习 Java 继承这一特性的时候，我们就知道在执行子类构造函数的时候会优先执行父类的构造函数，并依次向上传递。这是因为在继承这个特性上，子类需要依赖父类相关属性的初始化。\n\n但是当类中包含静态变量、静态常量、静态代码块、代码块时又会是一种什么样的执行逻辑呢？我们可以简单试一下。\n\n### 类的初始化\n\n先看两个类 Person.java 和 Student.java\n\n - 基类\n\n```java\npublic class Person {\n    // 静态变量\n    public static int value1 = printAndReturn(100);\n    // 静态常量\n    public static final int value2 = printAndReturn(200);\n\n    // 普通变量\n    public int value4 = 400;\n\n    // 静态代码块\n    static {\n        value1 = 101;\n        System.out.println(\"Person static block\");\n    }\n\n    // 代码块\n    {\n        value1 = 102;\n        System.out.println(\"Person block\");\n    }\n\n    // 构造函数\n    public Person() {\n        value1 = 103;\n        System.out.println(\"Person constructor\");\n    }\n\n    // helper method\n    public static int printAndReturn(int param) {\n        System.out.println(\"Person:\" + param);\n        return param;\n    }\n}\n```\n\n**这里 printAndReturn() 方法的主要作用是确定静态成员的执行顺序，因为变量或常量的初始化本身不会有输出，因此这里通过中间赋值的方式，确认其执行顺序**\n\n - 子类\n\n```java\npublic class Student extends Person {\n    public static int value3 = printAndReturn(300);\n\n    public int value5 = 500;\n\n    static {\n        value3 = 301;\n        System.out.println(\"Student static block\");\n    }\n\n    {\n        value3 = 302;\n        System.out.println(\"Student block\");\n    }\n\n    public Student() {\n        value3 = 303;\n        System.out.println(\"Student constructor\");\n        System.out.println(\"--------------------\");\n    }\n\n    public static int printAndReturn(int param) {\n        System.out.println(\"Student:\" + param);\n        return param;\n    }\n}\n```\n\n要实现**类的加载**，注意这里是加载，不是初始化。有两种方式，\n - Class.forName(\"类的全量限定名\")\n - Class.staticField\n\n ```java\n     public static void main(String[] args) {\n\n        int temp = Student.value3;  // logic 1\n\n        try {\n//            Class clazz = Class.forName(\"com.basic.classloads.Student\"); // logic 2\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\noutput\n```shell\nPerson:100\nPerson:200\nPerson static block\nStudent:300\nStudent static block\n```\n\n上面的 main 方法，无论是单独执行 logic 1 还是 logic 2。 结果都是相同的输出。这可以看到，在没有创建主动创建类的实例的时候，当我们用到一个类的时候，只会执行初始化其静态成员，执行静态代码块。构造函数之类的是不会执行的。\n\n这里可以看到静态成员是按照其在代码中声明的顺序执行。Person 类按照 value1 ,value2 ,静态代码块的顺序一次执行。\n这里大家可以调整代码顺序自己体会一下，就不再验证了。\n\n<img src=\"Java-代码执行时机/classinit.png\">\n\n### 实例初始化\n\n```java\n    public static void main(String[] args) {\n\n        Student s1 = new Student();\n        Student s2 = new Student();// logic 1\n\n        try {\n            Class clazz = Class.forName(\"com.basic.classloads.Student\"); // logic 2\n            clazz.newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n这里我们通过不同的方式，创建了 3 个 Student 的实例。我们再来看看输出\n\n```shell\nPerson:100\nPerson:200\nPerson static block\nStudent:300\nStudent static block\nPerson block\nPerson constructor\nStudent block\nStudent constructor\n--------------------\nPerson block\nPerson constructor\nStudent block\nStudent constructor\n--------------------\nPerson block\nPerson constructor\nStudent block\nStudent constructor\n--------------------\n```\n\n从结果我们可以得出执行顺序：\n\n1. 父类静态变量和静态代码块；\n\n2. 子类静态变量和静态代码块；\n\n3. 父类普通成员变量和普通代码块；\n\n4. 父类的构造函数；\n\n5. 子类普通成员变量和普通代码块；\n\n6. 子类的构造函数。\n\n同时也可以看到，静态的内容，是属于类的，和单个的实例无关，因此只会执行一次。\n\n<img src=\"Java-代码执行时机/objectinit.png\">\n\n\n## 潜在的坑\n\n按照上面的逻辑，似乎类的实例化一定是在类的初始化完毕只会执行，其实不然。\n\n```java\nclass A {\n    public static A a = new A();\n\n\n    public A() {}\n}\n```\n在这样的代码中，由于静态成员的初始化使用了当前类的构造函数，那么就会在这个过程中发生实例变量的初始化。\n\n\n## 参考文档\n\n- [类的初始化深入探索](https://mp.weixin.qq.com/s/ozsOXBpKpF1GTrX-NPAuFg)\n- 深入理解 Java 虚拟机 （第二版）","tags":["Java"]},{"title":"IntelliJ Idea 实用快捷键","url":"%2F2021%2F06%2F07%2FIntelliJ-Idea-%E5%AE%9E%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F","content":"\n## 实用\n\n|功能|快捷键|备注|\n|---|-----|---|\n|最近实用|Ctrl + E(Win) / Command +E （Mac）|\n|查看当前类的层次结构|Ctrl + H|\n|查看类结构(Structure)|Alt + 7(Win) / Command +7 （Mac）|\n|快速检索类|Ctrl + N (Win) / Command + O （Mac）|类似双击 shift 快速查找|\n|查看方法 / 类的实现类|Ctrl + Alt + B (Win) / Command + Alt + B (Mac)|在 Mac 上，Alt 键是 option 键|\n|查看方法被使用的情况|Alt + F7|\n\n\n\n## 参考文档\n\n[真香！用 IDEA 神器看源码，效率真高！](https://mp.weixin.qq.com/s/qFuAQH8UBxQPVOTV8atICQ)\n\n\n","tags":["idea"]},{"title":"Bitmap Next","url":"%2F2021%2F05%2F01%2FBitmap-Next%2F","content":"\n\n## 前言\n\nAndroid Bitmap 的一些总结\n\n<!--more-->\n\n## Bitmap 占用内存大小\n\nBitmap 实际站用的内容大小可以通过 Bitmap 提供的方法\n`getAllocationByteCount()` 获取到。\n\n也可以提前进行估算，估算公式为\n\n``` 图片实际高 x scale x 图片实际宽度 x scale x 图片每个像素占用的 byte ```\n\nscale 计算方式为  当前设备 densityDpi/图片所在目录dpi \n\n图片所在目录对应的 dpi 如下表\n\n|目录|mdpi|hdpi|xhdpi|xxhdpi|xxxhpi|\n|-----|--|--|--|--|--|\n|density|1|1.5|2|3|4|\n|densityDpi|160|240|320|480|640|\n\n比如下面这幅图，实际宽高为 1200x800 .\n\n<img src=\"./Bitmap-Next/android.webp\" />\n\n在屏幕密度为 420 的 Pixel2 上，当图片被放在 drawable-xxxhpi 文件夹下时，占用内存为\n\n图片内存 = 1200 x (420/640) x 800 x(420/640) x 4 = 1654800 byte\n图片宽度 = 1200 x 420/640 \n图片高度 = 800  x 420/640\n\n可以看到，当图片放在不同的目录时，图片自身的大小以及所占用的内存都将会有不同的值。\n\n从中也可以看到规律，当图片对应文件夹 dpi 大于 手机 dpi 时，在实际展示的时候将对图片进行缩小的处理，因为 scale 的值小于 1 。当然，如果手机屏幕密度和当前图片所在的文件夹的密度相同的话，那么将不会进行缩放。 反之，一旦 scale 参数大于 1 时，不但图片自身会被放大，占用的内存也会发生较大的增长，毕竟 scale 在计算公式中要做两次乘数。\n\n因此，把图片放到适合主流手机 dpi 的目录下是较好的选择。\n\n\n## BitmapFactory.Options\n\nBitmapFactory.Options 的常用成员变量。\n\n```java\n//获取图片信息\npublic boolean inJustDecodeBounds;\n//设置图片采样率\npublic int inSampleSize;\n//像素在内存中的存储格式，默认为 Bitmap.Config.ARGB_8888\npublic Bitmap.Config inPreferredConfig = Bitmap.Config.ARGB_8888;\n//文件所在文件夹的屏幕分辨率\npublic int inDensity;\n//真实设备屏幕分辨率\npublic int inTargetDensity;\n//设置是否需要缩放\npublic boolean inScaled;\n//图片原始宽度\npublic int outWidth;\n//图片原始高度\npublic int outHeight;\n//图片 MIME 类型，例如 JPEG GIF 等\npublic String outMineType;\n```\n\n\n## 参考文档\n\n[Android Bitmap图片优化分析](https://juejin.cn/post/6844904166138069005)","tags":["Android;Bitmap"]},{"title":"Kotlin Syntactic Sugar","url":"%2F2021%2F04%2F09%2FKotlin-Syntactic-Sugar%2F","content":"\n<img src=\"Kotlin-Syntactic-Sugar/header.jpeg\" width=50%>\n\n## 前言\n\nKotlin 语法糖的总结和原理分析。\n\nKotlin 有很多实用的语法糖，比如扩展函数、Object 单例、apply/run/with 等内置函数，对于开发者来说非常的友好的方便。简单梳理和总结包括但不限于上述这些语法糖的内容。\n\n<!--more-->\n\n[TOC]\n\n\n\n## Enjoy Syntactic Sugar \n\n### 内置函数\n\nkotlin-stdlib 内的 Standard.kt 文件内定义了几个比较实用的顶层函数\n比如 `apply/with/run/let/also` 等，这几个函数的功能比较相似，但又略微有些差异，在此梳理一下。\n\n<details>\n<summary>\n实例\n</summary>\n\n\n\n```kotlin\n\nfun main() {\n    val sugar = Sugar(\"mike\", 21, true)\n    printInfo(sugar)\n\n    val letResult = sugar.let {\n        it.name = \"let\"\n        it.age = 9\n    }\n    printInfo(letResult)\n\n    val alsoResult = sugar.also {\n        it.name = \"also\"\n        it.age = 13\n    }\n    printInfo(alsoResult)\n\n    val withResult = with(sugar) {\n        name = \"with\"\n        age = 10\n    }\n    printInfo(withResult)\n\n    val runResult = sugar.run {\n        name = \"run\"\n        age = 11\n    }\n    printInfo(runResult)\n\n    val applyResult = sugar.apply {\n        name = \"apply\"\n        age = 12\n    }\n    printInfo(applyResult)\n}\n```\noutput \n\n```shell\nSugar(name=mike, age=21, happy=true) : com.ext.Sugar\n\nkotlin.Unit : kotlin.Unit  // let\n\nSugar(name=also, age=13, happy=true) : com.ext.Sugar // also\n\nkotlin.Unit : kotlin.Unit  // with\n\nkotlin.Unit : kotlin.Unit // run \n\nSugar(name=apply, age=12, happy=true) : com.ext.Sugar // apply\n```\n\n</details>\n\n首先从返回结果，可以看到，默认情况下 apply 和 also 返回的都是当前对象，let/with/run 返回的 Unit ，也就是在 Lamdba 表达式中如果没有显示的在最后一行写返回值，那么  kotlin.Unit 就是返回值，可以理解为 Java 中的 Void。\n\n\n\n<img src=\"Kotlin-Syntactic-Sugar/it.png\" width=50%>\n\n<img src=\"Kotlin-Syntactic-Sugar/this.png\" width=50%>\n\n其次从 lambda 表达式的参数可以看出，it 和 also 都是 it ,剩下的 run/with/apply 都是 this 。其实 run 和 with 是的表现是完全一致的，只是调用方式不同而已，run 只需要一个参数，而 with 需要把接受者和 lambda 同时传入。\n\n| 类型  | 参数 | 返回值                                    |\n| ----- | ---- | ----------------------------------------- |\n| let   | it   | lambda 表达式最后一行，默认为 kotlin.Unit |\n| also  | it   | 接受者，即调用方法的对象                  |\n| apply | this | 接受者，即调用方法的对象                  |\n| with  | this | lambda 表达式最后一行，默认为 kotlin.Unit |\n| run   | this | lambda 表达式最后一行，默认为 kotlin.Unit |\n\n##### 原理剖析\n\n总的来说，这几个内置函数的实现是高度相似的，都是使用了 Kotlin 高阶函数的特性。但是他又是如何实现这些微妙的差异的那？我们可以对比一下 `let`  和 `also`\n\n```ko\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n```\n\n- 可以看到 ` block: (T) -> R `   block 函数的参数类型就是 T，也就是调用者。因此 lambda 表达式的参数名称就是 `it`\n- 再看返回值  `let` 直接返回了 block 函数的运行结果，而这个 block 函数就是我们调用时传入的 lambda 表达式，因此其执行结果就是整个函数的结果。而 `also` block 函数时返回值就是 Unit ，也就是说 lambda 表达式的结果是被忽略的。这里可以认为调用 block 真是为了执行一项操作，而实际返回是 `this`\n\n再来看看为什么有时候参数是 it ，有时候又是 this 呢？ 可以对比一下 `also` 和 `apply`\n\n```ko\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n```\n\n- 这里的关键就是 block 函数的定义。 注意到 apply 中 `block T.() -> Unit` 的写法，可以看到这里明确了当前函数执行的类型，同时参数为空；可以试一下，这种情况下，定义参数是没有意义的。\n\n```k\n  public fun <T> T.apply1(block: T.(Int) -> Unit): T {\n      block(1)\n      return this\n  }\n```\n\n比如这里，虽然定义了 block 的参数为 Int 类型，但是因为应明确定义了 block 函数是在 T 类型执行，因此实际调用时也无法传递这个参数，因此这里实现时也无法获取到具体的参数值 。\n\n可以看到，内置函数这几个非常使用的顶层函数的实现还是很有参考价值，我们在平时自己创建顶层函数的时候，可以参考这些实现。 Standard.kt 中还包括 `takeIf()` `takeUnless` `repeat` 这几个函数，实现和含义较为简单，就不展开说了。\n\n***\n\ntobe continued ...\n\n- [ ] 扩展函数\n- [ ] object 单例\n- [ ] 高阶函数\n- [ ] 协程（mabye?) \n\n","tags":["Kotlin"]},{"title":"InspectUI Code Review","url":"%2F2021%2F03%2F16%2FInspectUI-Code-Review%2F","content":"\n<img src=\"https://raw.githubusercontent.com/YvesCheung/UInspector/2.x/art/uinspector.png\" >\n\n\n## 前言\n\n一个类似 Android Studio Layout Inspector 的工具，可以非常方便的在手机上查看当前页面的 UI 信息，包括布局层级、View 树中各个 View 的属性。\n\n[UInspector](https://github.com/YvesCheung/UInspector)\n\n> A UI inspector to traverse a view hierarchy on Android\n\n<!--more-->\n\n## Preview\n\n<img src=\"./InspectUI-Code-Review/inspector1.png\" width=30%><img src=\"./InspectUI-Code-Review/inspector2.png\" width=30%><img src=\"./InspectUI-Code-Review/doraemonkit.png\" width=30%>\n\n\n## 带着问题去看源码\n\n - 怎么初始化的？\n - 为什么需要一个 Notification？怎么实现的？\n - 怎么拦截事件的？\n - 如何找到对应的 View 的？View 属性？\n - 如何将拦截的事件再次分发出去的？\n - 设计模式相关\n\n### 初始化 \n\n#### Uinspector-optional-autoinstall   \n\n ```kotlin\n @RestrictTo(RestrictTo.Scope.LIBRARY)\nclass UInspectorInstaller : ContentProvider() {\n\n    override fun onCreate(): Boolean {\n        UInspector.create(requireNotNull(context))\n        return true\n    }\n    //... \n}\n```\n\n```xml\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.pitaya.mobile.uinspector.optional.autoinstall\">\n\n    <application>\n        <provider\n            android:name=\"com.pitaya.mobile.uinspector.optional.UInspectorInstaller\"\n            android:authorities=\"${applicationId}.uinspector.optional.installer\"\n            android:exported=\"false\" />\n    </application>\n</manifest>\n```\n\n类似 LeakCanary， 使用 ContentProvider 的 Context 进行初始化。\n>缺点：不灵活，但是作为 debug 工具，完全可以忽略。\n>\n>优点：无侵入式的依赖\n\n#### Uinspector.create\n\n```kotlin\n    fun create(context: Context) {\n        if (init.compareAndSet(false, true)) {\n            application = context.applicationContext as Application\n            installPlugins\n            lifecycle.register(application)\n            stop()\n        }\n    }\n```\n\n### Notification \n\n前台 Service \n\n - UInspectorNotificationService \n    - setContentIntent\n    - onStartCommand\n    - UInspector.changeStateInner(pendingState)\n    - 前后台\n\n### 如何拦截事件\n\n - UInspector \n    - changePanelState\n    - UInspectorPanel\n\n - UInspectorDialogFragment \n    - 拦截事件\n    - UInspectorMask\n\n\n- UInspectorMask\n    - dispatchKeyEvent 拦截返回键\n    - onTouchEvent 拦截 down 事件 \n       - isSingleTap = true 时 dispatchCancelEvent\n\n- 如何找到 DecorView\n\n```kotlin\n    val global by lazy(LazyThreadSafetyMode.NONE) {\n        Class.forName(\"android.view.WindowManagerGlobal\")\n    }\n\n    val windowManagerGlobal: Any by lazy(LazyThreadSafetyMode.NONE) {\n        global.getDeclaredMethod(\"getInstance\").invoke(null)\n    }\n\n    val getWindowViews by lazy(LazyThreadSafetyMode.NONE) {\n        val f = global.getDeclaredField(\"mViews\")\n        f.isAccessible = true\n        f\n    }\n\n    @Suppress(\"KDocUnresolvedReference\")\n    fun findAllDecorViews(): List<View>? {\n        try {\n            @Suppress(\"UNCHECKED_CAST\")\n            return getWindowViews.get(windowManagerGlobal) as List<View>\n        } catch (e: Throwable) {\n            Log.e(LibName, e.toString())\n            return null\n        }\n    }\n```\n\n### 如何找到对应的 View 的？View 属性？\n\n- 如何找到被点击的 View\n\n```kotlin\n\n        protected val firstTouchTarget: Field by lazy(LazyThreadSafetyMode.NONE) {\n            val f = ViewGroup::class.java.getDeclaredField(\"mFirstTouchTarget\")\n            f.isAccessible = true\n            f\n        }\n\n        protected val touchTargetChild: Field by lazy(LazyThreadSafetyMode.NONE) {\n            val cls = Class.forName(\"android.view.ViewGroup\\$TouchTarget\")\n            val f = cls.getDeclaredField(\"child\")\n            f.isAccessible = true\n            f\n        }\n\n     /**\n     * 1. Try to get the [view]'s 'mFirstTouchTarget' field\n     * 2. If fail, use [findTouchTargetByEvent] instead\n     */\n    protected open fun findFirstTouchTarget(view: View?, touchEvent: MotionEvent): View? {\n        if (view is ViewGroup) {\n            return try {\n                val touchTarget = firstTouchTarget.get(view)\n                if (touchTarget != null) {\n                    touchTargetChild.get(touchTarget) as? View\n                } else {\n                    findTouchTargetByEvent(view, touchEvent)\n                }\n            } catch (e: Throwable) {\n                Log.e(LibName, e.toString())\n                findTouchTargetByEvent(view, touchEvent)\n            }\n        }\n        return null\n    }\n```\n\n- 面板\n    -UInspectorPopupPanelContainerImpl\n\n\n\n\n\n\n\n\n\n","tags":["三方库源码分析"]},{"title":"View Measure","url":"%2F2021%2F03%2F01%2FView-Measure%2F","content":"\n\n## 前言\n\nAndroid View 体系 Measure 流程分析，结合 View、ViewGroup 梳理 Android 中测量 View 大小的具体实现。\n\n<!--more-->\n\n### 到底是从哪里开始了 measure ? \n\n<img src=\"./Activity-为什么能显示-UI/with_content.png\" width=60%/>\n\n通过之前 {% post_link Activity-为什么能显示-UI %} 一文我们知道，Activity 所显示的所有 View 是添加到 DecorView 中。ViewRootImpl 调用最终的 setView 之前，会之前调用 requestLayout 触发整个 View 树的测量、布局和绘制流程。也就是执行 ```performTraversals``` 方法。\n\n\n### 测量流程\n\n#### performTraversals\n\n```java\nprivate void performTraversals() {\n        // cache mView since it is used so much below...\n\n        // 1. mView 就是 DecorView\n        final View host = mView;\n\n        if (host == null || !mAdded)\n            return;\n\n\n        WindowManager.LayoutParams lp = mWindowAttributes;\n\n        // 2. 窗口宽高\n        int desiredWindowWidth;\n        int desiredWindowHeight;\n\n        Rect frame = mWinFrame;\n        if (mFirst) {\n            mFullRedrawNeeded = true;\n            mLayoutRequested = true;\n\n            final Configuration config = mContext.getResources().getConfiguration();\n            if (shouldUseDisplaySize(lp)) {\n                // NOTE -- system code, won't try to do compat mode.\n                Point size = new Point();\n                mDisplay.getRealSize(size);\n                desiredWindowWidth = size.x;\n                desiredWindowHeight = size.y;\n            } else if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT\n                    || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {\n                // For wrap content, we have to remeasure later on anyways. Use size consistent with\n                // below so we get best use of the measure cache.\n                desiredWindowWidth = dipToPx(config.screenWidthDp);\n                desiredWindowHeight = dipToPx(config.screenHeightDp);\n            } else {\n                // After addToDisplay, the frame contains the frameHint from window manager, which\n                // for most windows is going to be the same size as the result of relayoutWindow.\n                // Using this here allows us to avoid remeasuring after relayoutWindow\n                desiredWindowWidth = frame.width();\n                desiredWindowHeight = frame.height();\n            }\n\n           \n        } else {\n            \n        }\n\n    \n\n        boolean layoutRequested = mLayoutRequested && (!mStopped || mReportNextDraw);\n        if (layoutRequested) {\n\n            final Resources res = mView.getContext().getResources();\n\n            if (mFirst) {\n                // make sure touch mode code executes by setting cached value\n                // to opposite of the added touch mode.\n                mAttachInfo.mInTouchMode = !mAddedTouchMode;\n                ensureTouchModeLocally(mAddedTouchMode);\n            } else {\n                if (!mPendingDisplayCutout.equals(mAttachInfo.mDisplayCutout)) {\n                    cutoutChanged = true;\n                }\n                if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT\n                        || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {\n                    windowSizeMayChange = true;\n\n                    if (shouldUseDisplaySize(lp)) {\n                        // NOTE -- system code, won't try to do compat mode.\n                        Point size = new Point();\n                        mDisplay.getRealSize(size);\n                        desiredWindowWidth = size.x;\n                        desiredWindowHeight = size.y;\n                    } else {\n                        Configuration config = res.getConfiguration();\n                        desiredWindowWidth = dipToPx(config.screenWidthDp);\n                        desiredWindowHeight = dipToPx(config.screenHeightDp);\n                    }\n                }\n            }\n\n            // Ask host how big it wants to be\n            windowSizeMayChange |= measureHierarchy(host, lp, res,\n                    desiredWindowWidth, desiredWindowHeight);\n        }\n```\n最终调用 measureHierarchy 方法。这里可以看一下他的几个参数\n\n- host 其实就是 DecorView ,就是 ViewRootImpl.setView 方法添加进来的 DecorView .\n- lp 是 mWindowAttributes ，其实就是 DecorView 的对应的 WindowManager.LayoutParmas.\n- res 及 context.getResources().\n- desiredWindowWidth, desiredWindowHeight 代表屏幕的宽高\n\n#### measureHierarchy\n\n```java\n    private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp,\n            final Resources res, final int desiredWindowWidth, final int desiredWindowHeight) {\n        int childWidthMeasureSpec;\n        int childHeightMeasureSpec;\n        boolean windowSizeMayChange = false;\n\n        if (DEBUG_ORIENTATION || DEBUG_LAYOUT) Log.v(mTag,\n                \"Measuring \" + host + \" in display \" + desiredWindowWidth\n                + \"x\" + desiredWindowHeight + \"...\");\n\n        boolean goodMeasure = false;\n        // unnormal-logic \n\n        if (!goodMeasure) {\n            childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);\n            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);\n            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n            if (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) {\n                windowSizeMayChange = true;\n            }\n        }\n\n\n        return windowSizeMayChange;\n    }\n\n    private static int getRootMeasureSpec(int windowSize, int rootDimension) {\n        int measureSpec;\n        switch (rootDimension) {\n\n        case ViewGroup.LayoutParams.MATCH_PARENT:\n            // Window can't resize. Force root view to be windowSize.\n            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);\n            break;\n        case ViewGroup.LayoutParams.WRAP_CONTENT:\n            // Window can resize. Set max size for root view.\n            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);\n            break;\n        default:\n            // Window wants to be an exact size. Force root view to be that size.\n            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);\n            break;\n        }\n        return measureSpec;\n    }\n```\n\n在 measureHierarchy 中会根据 DecorView 的 LayoutParams 和 窗口宽高计算出 MeasureSpec 。具体实现在 getRootMeasureSpec 中。逻辑很简，就是根据屏幕宽高和测量规格再次计算封装一个 MeasureSepc。\n\n最终会调用 performMeasure 方法。\n\n#### performMeasure\n\n```java\n   private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {\n        if (mView == null) {\n            return;\n        }      \n        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n    }\n```\n\n#### measure \n\n```java\n  public final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n       \n        // Suppress sign extension for the low bytes\n        long key = (long) widthMeasureSpec << 32 | (long) heightMeasureSpec & 0xffffffffL;\n        if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);\n\n        final boolean forceLayout = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;\n\n        // Optimize layout by avoiding an extra EXACTLY pass when the view is\n        // already measured as the correct size. In API 23 and below, this\n        // extra pass is required to make LinearLayout re-distribute weight.\n        final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec\n                || heightMeasureSpec != mOldHeightMeasureSpec;\n        final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY\n                && MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;\n        final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)\n                && getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);\n        final boolean needsLayout = specChanged\n                && (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);\n\n        if (forceLayout || needsLayout) {\n            // first clears the measured dimension flag\n            mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;\n\n            resolveRtlPropertiesIfNeeded();\n\n            int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);\n            if (cacheIndex < 0 || sIgnoreMeasureCache) {\n                // measure ourselves, this should set the measured dimension flag back\n                onMeasure(widthMeasureSpec, heightMeasureSpec);\n                mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;\n            } else {\n                long value = mMeasureCache.valueAt(cacheIndex);\n                // Casting a long to int drops the high 32 bits, no mask needed\n                setMeasuredDimensionRaw((int) (value >> 32), (int) value);\n                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;\n            }\n\n            // flag not set, setMeasuredDimension() was not invoked, we raise\n            // an exception to warn the developer\n            if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {\n                throw new IllegalStateException(\"View with id \" + getId() + \": \"\n                        + getClass().getName() + \"#onMeasure() did not set the\"\n                        + \" measured dimension by calling\"\n                        + \" setMeasuredDimension()\");\n            }\n\n            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;\n        }\n\n        mOldWidthMeasureSpec = widthMeasureSpec;\n        mOldHeightMeasureSpec = heightMeasureSpec;\n\n        mMeasureCache.put(key, ((long) mMeasuredWidth) << 32 |\n                (long) mMeasuredHeight & 0xffffffffL); // suppress sign extension\n    }\n```\n\nmeasure 整体流程还是比较简单，首先会根据父布局传递的 MeasureSpec 计算一个 key ，用这个 key 作为实现计算结果缓存的效果。这也是现在常用的一种代码优化实现方式，先去缓存里查，有的话直接使用。没有的话在计算，并且存起来。\n\n最终在**需要重新测量** 的前提下，如果缓存中拿不到值，那么就执行 onMeasure 方法进行测量。\n\n#### onMeasure \n\n```java\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n    }\n```\n看起来很简单？只要拿到当前 view 的默认大小就可以了。\n\n\n注意！注意！注意！\n\n这里就是比较有意思的地方了，上面提到的所有方法要么是私有的，要么是 final 的。因此，调用时机和调用的对象都是一致的。但到了 onMeasure 就不一样了，他是一个 protected 的方法，他的子类是可以覆写甚至完全覆盖 view 中的实现的。\n\n同时按照 Java 多态中方法调用的规则，这个时候实际执行的是当前 mView 对象的 onMeasure 方法。而 mView 是 DecorView (即 FrameLayout 的 onMeasure)。 这一点通过打断点在调用栈也可以很简单的看出来。\n\n<img src=\"View-Measure/frames.png\">\n\n#### FrameLayout.onMeasure\n\n```java\n@Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        int count = getChildCount();\n\n        int maxHeight = 0;\n        int maxWidth = 0;\n        int childState = 0;\n\n        for (int i = 0; i < count; i++) {\n            final View child = getChildAt(i);\n            if (mMeasureAllChildren || child.getVisibility() != GONE) {\n                measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);\n                final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n                maxWidth = Math.max(maxWidth,\n                        child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);\n                maxHeight = Math.max(maxHeight,\n                        child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);\n                childState = combineMeasuredStates(childState, child.getMeasuredState());\n            }\n        }\n\n        // else logic \n\n        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),\n                resolveSizeAndState(maxHeight, heightMeasureSpec,\n                        childState << MEASURED_HEIGHT_STATE_SHIFT));\n    }\n```\n\n#### measureChildWithMargins\n\n```java\n protected void measureChildWithMargins(View child,\n            int parentWidthMeasureSpec, int widthUsed,\n            int parentHeightMeasureSpec, int heightUsed) {\n        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n\n        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin\n                        + widthUsed, lp.width);\n        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin\n                        + heightUsed, lp.height);\n\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n\n\n    }\n```\n\n可以看到，在 measureChildWithMargins 方法中会根据当前 ViewGroup 自身的 padding, view 的 margin 以及  view 自己的 LayoutParams 共同计算出一个新的 MeasureSpec，然后调用 子view 的 measure 方法继续递归的执行这个过程，直到没有子 View 本身不包含 view 为止。\n\n#### 整体流程图\n\n<img src=\"View-Measure/measure.svg\" width=70%>\n\nViewGroup 中 setMeasuredDimension 会根据 LinearLayout/RelativeLayout 等不同的特性，程序不同的实现逻辑。但整体是思路是一致的。\n\n### 小结\n\n至此，我们了解了 View measure 的整体流程。\n\n通过 WindowManager 将 DecorView 添加到 ViewRootImpl 的过程中，会主动调用 requestLayout 。在这个过程中会触发 measureHierarchy() 方法，开始整个 ViewTree 的绘制流程。\n\n在绘制流程中，不同类型的 View 会经历不同的流程。不包括子view的 view 只负责自身大小的测量，同时一定要调用 setMeasuredDimension 方法保存大小。包含子view 的 ViewGroup 类型的 View ，同时会测量所有 view 的大小，一般是使用 measureChildWithMargins 方法。根据具体执行结果，计算自身的宽高并通过 measureChildWithMargins 保存。\n\n### 哪些场景会触发 view 的测量 ？ \n\n\n\n\n\n","tags":["Android;自定义View"]},{"title":"Activity 为什么能显示 UI","url":"%2F2021%2F02%2F26%2FActivity-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%98%BE%E7%A4%BA-UI%2F","content":"\n## 前言\n\nActivity 作为 Android 中承载 UI 显示的组件，背后的原理是什么呢？本文简单窥探一下。\n\n\n<!--more-->\n\n*本文基于 Android-SDK 30 做源码分析*\n\n## Activity 和 UI 的关系\n\n在 Android 中，调用 ```startActivity(Intent)``` 方法就可以打开一个新的页面。\n\n```kotlin\noverride fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n```\n<details>\n<summary>\nactivity_main.xml\n</summary>\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello World!\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n</details>\n\n我们知道 Activity 启动后在其 onCreate 方法，通过开发者主动调用 setContentView 方法，会加载和显示在 activity_main.xml 中定义的 View 组件们。那么，如果我们不调用这个方法会怎么样呢？会正常打开一个新的页面吗？\n\n简单试一下，其实是可以的。\n\n- 调用 setContentView 后 Activity UI 及 LayoutInspect 结果\n\n<img src=\"./Activity-为什么能显示-UI/with_content.png\" width=60%/>\n\n- 不调用 setContentView 后 Activity UI 及 LayoutInspect 结果\n\n<img src=\"./Activity-为什么能显示-UI/without_content.png\" width=60%/>\n\n可以看到两种场景相差的恰好就是 activity_main.xml 当中的内容。剩下的都是两种场景下公共的部分，比如 DecorView ,StatusBar , NavigationBar 等。那么这些 View 又是怎么如何被管理和添加到当前页面的。再有，一个 Activity 呈现的一个页面，到底是什么？ 严格从面向对象的角度出发，他到底是哪个类的实例？一个普通的 Java 类怎么就可以变成花花绿绿的东西，可以显示在屏幕上的？\n\n如果你思考过以上问题，可能多多少少看过一些相关的介绍。当我们调用 ```startActivity(Intent)``` 方法启动一个 Activity 的时候，最终 AMS 通过一系列复杂的运作，会回到 ActivityThread 当中执行 ```performLaunchActivity()``` 方法，在其中会创建 activity 的实例，并调用 Activity.attach 方法，实现创建 Window 及 View 添加和渲染的一系列操作。\n\n通过以上，我们也可以知道，Activity 类其实并不是负责进行页面渲染的类，他更多的功能是 Android 系统提供给应用开发者方便进行页面生命周期管理和 UI 实现的模板类。当然，Activity 自身涉及到的设计模式也有很多，从不同的角度出发会有不同的答案。\n\n下面就来看看 Android 中 Window 到底是什么？\n\n## WindowManager & View \n\n### Window \n\n```java\n/**\n * Abstract base class for a top-level window look and behavior policy.  An\n * instance of this class should be used as the top-level view added to the\n * window manager. It provides standard UI policies such as a background, title\n * area, default key processing, etc.\n *\n * <p>The only existing implementation of this abstract class is\n * android.view.PhoneWindow, which you should instantiate when needing a\n * Window.\n */\npublic abstract class Window {\n    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)\n    private WindowManager mWindowManager;\n    @UnsupportedAppUsage\n    private IBinder mAppToken;\n}\n```\nWindow 这个抽象类定义了上层 window 的基础及一些行为策略。他的唯一实现是 PhoneWindow。\n\nWindow 有两个特别重要的或者说常见的属性 WindowManager 和 IBinder 。尤其是当我们在日常开发中错误的操作 Window 时（比如用 application 的 context 调用 startActivity 或进行打开 AlertDialog 的操作）经常会看到 token 相关的报错信息。下面重点说一下 WindowManager 。\n\n### WindowManager \n\n首先看看 WindowManager 的基类 ViewManager\n\n#### ViewManager\n\n```java\n/** Interface to let you add and remove child views to an Activity. To get an instance\n  * of this class, call {@link android.content.Context#getSystemService(java.lang.String) Context.getSystemService()}.\n  */\npublic interface ViewManager\n{\n    public void addView(View view, ViewGroup.LayoutParams params);\n    public void updateViewLayout(View view, ViewGroup.LayoutParams params);\n    public void removeView(View view);\n}\n```\n**这里关于这个 ViewManager 的注释很有意思，他是专门用于给 Activity 添加和移除 View 的接口。** 注意这里的 LayoutParamas 是 ViewGroup 内定义的。\n我们通过调用 ```getSystemService(Context.WINDOW_SERVICE)``` 就可以获取到他的实例，当然他本身是个接口，他的实例一般都是用他的子类 WindowManager。\n\n####  LayoutParamas\n\n```java\n/**\n * The interface that apps use to talk to the window manager.\n * </p><p>\n * Each window manager instance is bound to a particular {@link Display}.\n */\n@SystemService(Context.WINDOW_SERVICE)\npublic interface WindowManager extends ViewManager {\n\n  public void removeViewImmediate(View view);\n\n  public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable {}\n}\n```\nWindowManger 继承 ViewManager 后，添加了键盘弹出收起及截屏的相关接口。最重要的是定义了内部类 LayoutParams 以规范对 WindowManger 进行 add 和 update 的操作时的边界。\n\n有了 WindowManger 我们就可以把一个 View 添加到屏幕上了，只要添加的规则符合 WindowManager.LayoutParams 中定义参数即可。这里及不具体操作了，类似的实现比如屏幕上的悬浮球，悬浮弹窗之类的实现就太多了，具体参考[Window/WindowManager 不可不知之事\n](https://mp.weixin.qq.com/s/VDdDy3_nU0W1byM8H5B0Pw)\n\n**从以上定义可以看到，我们具体操作的还是 View，Window 不仅是一个抽象类，更是一个抽象的概念。我们添加到屏幕上或更新的东西并不是 Window ,而是更加可以具体化的 View 组件。**\n\n这就和我们平时说吃饭是一个道理，虽说是吃饭，但吃的并不是叫做饭的东西，因为实际上在任何一个菜谱不会有一个叫做饭的菜，我们吃的是具体的一道菜，比如宫保鸡丁盖饭或牛肉面。\n\n#### WindowManagerImpl\n\nWindowManger 依然是抽象的，我们需要看他的具体实现 WindowManagerImpl。 \n\n```java\n/**\n * Provides low-level communication with the system window manager for\n * operations that are bound to a particular context, display or parent window.\n * Instances of this object are sensitive to the compatibility info associated\n * with the running application.\n *\n * This object implements the {@link ViewManager} interface,\n * allowing you to add any View subclass as a top-level window on the screen.\n * Additional window manager specific layout parameters are defined for\n * control over how windows are displayed.  It also implements the {@link WindowManager}\n * interface, allowing you to control the displays attached to the device.\n *\n * <p>Applications will not normally use WindowManager directly, instead relying\n * on the higher-level facilities in {@link android.app.Activity} and\n * {@link android.app.Dialog}.\n *\n * <p>Even for low-level window manager access, it is almost never correct to use\n * this class.  For example, {@link android.app.Activity#getWindowManager}\n * provides a window manager for adding windows that are associated with that\n * activity -- the window manager will not normally allow you to add arbitrary\n * windows that are not associated with an activity.\n *\n * @see WindowManager\n * @see WindowManagerGlobal\n * @hide\n */\npublic final class WindowManagerImpl implements WindowManager {\n    @UnsupportedAppUsage\n    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();\n  \n    private final Window mParentWindow;\n\n    private IBinder mDefaultToken;\n\n    public WindowManagerImpl(Context context) {\n        this(context, null);\n    }\n\n    private WindowManagerImpl(Context context, Window parentWindow) {\n        mContext = context;\n        mParentWindow = parentWindow;\n    }\n\n    public WindowManagerImpl createLocalWindowManager(Window parentWindow) {\n        return new WindowManagerImpl(mContext, parentWindow);\n    }\n\n    public WindowManagerImpl createPresentationWindowManager(Context displayContext) {\n        return new WindowManagerImpl(displayContext, mParentWindow);\n    }\n\n    /**\n     * Sets the window token to assign when none is specified by the client or\n     * available from the parent window.\n     *\n     * @param token The default token to assign.\n     */\n    public void setDefaultToken(IBinder token) {\n        mDefaultToken = token;\n    }\n\n    @Override\n    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {\n        applyDefaultToken(params);\n        mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,\n                mContext.getUserId());\n    }\n\n    @Override\n    public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {\n        applyDefaultToken(params);\n        mGlobal.updateViewLayout(view, params);\n    }\n    //...   \n}\n\n```\n这个类的注释很清楚的表达了以下几点\n\n- 这个类是在更低一层负责和系统的 WindowManagerService 进行通讯，在客户端这个要进行通讯的可能是一个具体的 Context 、Display 或一个存在 Window. \n  - 这一点从其构造函数也可以看到，mParentWindow 是可能为 null 的\n- 按照设计模式面向接口编程的理念，上层业务只会接触到 WindowManger ，而具体的操作由他来实现。\n\n但是，具体的操作依旧不是由 WindowManagerImpl 来实现，而是统一桥接到了 WindowManagerGlobal。\n\n\n#### WindowManagerGlobal\n\n```java\n/**\n * Provides low-level communication with the system window manager for\n * operations that are not associated with any particular context.\n *\n * This class is only used internally to implement global functions where\n * the caller already knows the display and relevant compatibility information\n * for the operation.  For most purposes, you should use {@link WindowManager} instead\n * since it is bound to a context.\n *\n * @see WindowManagerImpl\n * @hide\n */\npublic final class WindowManagerGlobal {\n\n    @UnsupportedAppUsage\n    private final ArrayList<View> mViews = new ArrayList<View>();\n    @UnsupportedAppUsage\n    private final ArrayList<ViewRootImpl> mRoots = new ArrayList<ViewRootImpl>();\n    @UnsupportedAppUsage\n    private final ArrayList<WindowManager.LayoutParams> mParams =\n            new ArrayList<WindowManager.LayoutParams>();\n    private final ArraySet<View> mDyingViews = new ArraySet<View>();\n}\n```\n可以对比一下这里的注释和上面 WindowManagerImpl 的注释，同样 low-level 的实现，WindowManagerGlobal 可以说是更加的通用。从命名及之前在 WindowManagerImpl 的初始化可以看到，WindowManagerGlobal 是全局单例的设计模式。因此，可以说他是整个 App 负责进行 window 添加、更新、删除的大管家。\n\n关于 WindowManagerGlobal 内部 view 具体的操作，可以参考 《Android 开发艺术探索》一书了解（这部分内容还是讲的很清楚的，虽然是很久之前出的书，这部分的逻辑其实也没怎么变化，还是值得参考的)。\n\n```java\n    public void addView(View view, ViewGroup.LayoutParams params,\n            Display display, Window parentWindow, int userId) {\n            root = new ViewRootImpl(view.getContext(), display);\n\n            view.setLayoutParams(wparams);\n\n            mViews.add(view);\n            mRoots.add(root);\n            mParams.add(wparams);\n\n            // do this last because it fires off messages to start doing things\n            try {\n                root.setView(view, wparams, panelParentView, userId);\n            } catch (RuntimeException e) {}\n          }\n\n```\n最后，在沿着最后的逻辑，看看大名鼎鼎的 ViewRootImpl \n\n#### ViewRootImpl\n\n##### ViewParent\n\n```java\n/**\n * Defines the responsibilities for a class that will be a parent of a View.\n * This is the API that a view sees when it wants to interact with its parent.\n * \n */\npublic interface ViewParent {\n    /**\n     * Called when something has changed which has invalidated the layout of a\n     * child of this view parent. This will schedule a layout pass of the view\n     * tree.\n     */\n    public void requestLayout();\n}\n```\nViewRootImpl.java\n\n```java\n/**\n * The top of a view hierarchy, implementing the needed protocol between View\n * and the WindowManager.  This is for the most part an internal implementation\n * detail of {@link WindowManagerGlobal}.\n */\n@SuppressWarnings({\"EmptyCatchBlock\", \"PointlessBooleanExpression\"})\npublic final class ViewRootImpl implements ViewParent,\n        View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks {}\n```\n\n - setView \n\n```java\npublic void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,\n            int userId) {\n                // Schedule the first layout -before- adding to the window\n                // manager, to make sure we do the relayout before receiving\n                // any other events from the system.\n                requestLayout();\n           \n                try {\n                    //... \n                    res = mWindowSession.addToDisplayAsUser(mWindow, mSeq, mWindowAttributes,\n                            getHostVisibility(), mDisplay.getDisplayId(), userId, mTmpFrame,\n                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,\n                            mAttachInfo.mDisplayCutout, inputChannel,\n                            mTempInsets, mTempControls);\n                    setFrame(mTmpFrame);\n                } catch (RemoteException e) {}\n            }\n```\n\n到这里就变成了一次跨进程通信，由系统的 WindowManagerService 进行后续操作的流程了。\n\n - requestLayout \n\n```java\n    @Override\n    public void requestLayout() {\n        if (!mHandlingLayoutInLayoutRequest) {\n            checkThread();\n            mLayoutRequested = true;\n            scheduleTraversals();\n        }\n    }\n```\n\n### 类结构关系\n\n下面通过 UML 图对上文中提到的类总结一下\n\n<img src=\"./Activity-为什么能显示-UI/windowmanger.png\" >\n\n上面的图简单梳理一下涉及到显示一个页面或者说 Window 的类，以及他们之间的关系。\n\n### Activity 显示流程\n\n回到一开始我们的例子，一个 Activity 是如何变成一个可以显示的页面的呢 ？\n\n\n在 Activity 的启动过程中，我们知道在 ActivityThread 的 ```performLaunchActivity``` 方法中，在创建 activity 的实例后会调用其 attach 方法。\n\n```java\n    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n        // ..\n        Activity activity = null;\n        try {\n            java.lang.ClassLoader cl = appContext.getClassLoader();\n            activity = mInstrumentation.newActivity(\n                    cl, component.getClassName(), r.intent);\n          \n        } catch (Exception e) {\n           \n        }\n\n        try {\n            if (activity != null) {\n              \n                activity.attach(appContext, this, getInstrumentation(), r.token,\n                        r.ident, app, r.intent, r.activityInfo, title, r.parent,\n                        r.embeddedID, r.lastNonConfigurationInstances, config,\n                        r.referrer, r.voiceInteractor, window, r.configCallback,\n                        r.assistToken);\n\n        } catch (SuperNotCalledException e) {}\n\n        return activity;\n    }\n```\n\n\n```java\n    final void attach(Context context, ActivityThread aThread,\n            Instrumentation instr, IBinder token, int ident,\n            Application application, Intent intent, ActivityInfo info,\n            CharSequence title, Activity parent, String id,\n            NonConfigurationInstances lastNonConfigurationInstances,\n            Configuration config, String referrer, IVoiceInteractor voiceInteractor,\n            Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) {\n\n        attachBaseContext(context);\n\n        mFragments.attachHost(null /*parent*/);\n\n        mWindow = new PhoneWindow(this, window, activityConfigCallback);\n        mWindow.setWindowControllerCallback(mWindowControllerCallback);\n        mWindow.setCallback(this);\n       \n        mUiThread = Thread.currentThread();\n\n        mMainThread = aThread;\n        mToken = token;\n    \n        mWindow.setWindowManager(\n                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),\n                mToken, mComponent.flattenToString(),\n                (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);\n        if (mParent != null) {\n            mWindow.setContainer(mParent.getWindow());\n        }\n    }\n```\n可以看到，在 attach 方法中会创建 PhoneWindow 的实例，同时调用 setWindowManager 。注意，这个 attach 的调用时机非常的早，甚至在我们非常熟悉的 onCreate 之前，因此在这个阶段，Activity 只是创建了一个 Window 并且这个 Window 绑定了 WindowManger .\n\n按照 Activity 的生命周期方法，在 ActivityThread 的 ```handleResumeActivity``` 方法中会调用如下代码\n\n```java\n    public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,\n            String reason) {\n\n        // 获取 ActivityClientRecord \n        final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);\n\n        final Activity a = r.activity;\n\n        if (r.window == null && !a.mFinished && willBeVisible) {\n            r.window = r.activity.getWindow();\n            View decor = r.window.getDecorView();\n            decor.setVisibility(View.INVISIBLE);\n            ViewManager wm = a.getWindowManager();\n            WindowManager.LayoutParams l = r.window.getAttributes();\n            // 赋值 mDecor 为 decor \n            a.mDecor = decor;\n          \n        \n        } else if (!willBeVisible) {\n           \n        }\n\n      \n        if (!r.activity.mFinished && willBeVisible && r.activity.mDecor != null && !r.hideForNow) {\n            \n            // 调用 Activity 的 makeVisible 方法\n            if (r.activity.mVisibleFromClient) {\n                r.activity.makeVisible();\n            }\n        }\n    }\n```\n即 Activity 的 makeVisible() 方法\n\n```java\n    void makeVisible() {\n        if (!mWindowAdded) {\n            ViewManager wm = getWindowManager();\n            wm.addView(mDecor, getWindow().getAttributes());\n            mWindowAdded = true;\n        }\n        mDecor.setVisibility(View.VISIBLE);\n    }\n```\n可以看到 最终是将 mDecor 添加到了 WindowManager 当中。从前面的 onResume 的中的代码我们也可以看到 这里的 mDecor 其实就是 activity.window.getDecorView() 。\n\ngetDecorView 在 Window 中是一个抽象方法，我们可以在其实现类 PhoneWindow 中找到具体实现。\n\n```java\n    @Override\n    public final @NonNull View getDecorView() {\n        if (mDecor == null || mForceDecorInstall) {\n            installDecor();\n        }\n        return mDecor;\n    }\n```\n\n看一下  installDecor() \n\n\n```java\n    private void installDecor() {\n        mForceDecorInstall = false;\n        if (mDecor == null) {\n            mDecor = generateDecor(-1);\n            // ... \n        } else {\n            mDecor.setWindow(this);\n        }\n        if (mContentParent == null) {\n            mContentParent = generateLayout(mDecor);\n\n        }\n    }\n\n        protected DecorView generateDecor(int featureId) {\n        Context context;\n        if (mUseDecorContext) {\n            Context applicationContext = getContext().getApplicationContext();\n            if (applicationContext == null) {\n                context = getContext();\n            } else {\n                context = new DecorContext(applicationContext, this);\n                if (mTheme != -1) {\n                    context.setTheme(mTheme);\n                }\n            }\n        } else {\n            context = getContext();\n        }\n        return new DecorView(context, featureId, this, getAttributes());\n    }\n```\n\n在 installDecor 方法中，会生成 DecorView 并赋值给 mDecor，同时会根据 mDecor 初始化 mContentParent 。\n\n查看源码可知，DecorView 只是一个 FrameLayout 。那么我们在 setContentView 中设置的内容又是怎么和 DecorView 关联的呢？ \n\n```java\n    @Override\n    public void setContentView(int resId) {\n        ensureSubDecor();\n        ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);\n        contentParent.removeAllViews();\n        LayoutInflater.from(mContext).inflate(resId, contentParent);\n        mAppCompatWindowCallback.getWrapped().onContentChanged();\n    }\n```\nsetContentView 有多个重载方法，但是每个重载方法里都会调用 ensureSubDecor() 的方法。\n\n\n```java\n    private void ensureSubDecor() {\n        if (!mSubDecorInstalled) {\n            // 核心实现还是 createSubDecor\n            mSubDecor = createSubDecor();\n            mSubDecorInstalled = true;\n\n        }\n    }\n\n    private ViewGroup createSubDecor() {\n\n        // 1 , 获取当前系统 Theme ,检查 theme 的合法性并获取一些\n        // 配置信息\n        TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);\n\n        // Now let's make sure that the Window has installed its decor by retrieving it\n        // 2.检查 window 是否已经创建 ，mWindow 赋值\n        ensureWindow();\n        // 3. 调用上面说的 getDecorView 创建 DecorView \n        mWindow.getDecorView();\n\n        final LayoutInflater inflater = LayoutInflater.from(mContext);\n        ViewGroup subDecor = null;\n\n\n        // 4. 根据 theme 配置信息，创建 subDecor 及 \n\n        // subDecor 就是 DecorView 直接子 View，一般会包含 、、/// titleBar 等信息\n        // Now set the Window's content view with the decor\n        // 5. 将 subDecor 添加到 mWindow 中，准确说是添加到\n        // DecorView 中。\n        mWindow.setContentView(subDecor);\n\n        contentView.setAttachListener(new ContentFrameLayout.OnAttachListener() {\n            @Override\n            public void onAttachedFromWindow() {}\n\n            @Override\n            public void onDetachedFromWindow() {\n                dismissPopups();\n            }\n        });\n\n        return subDecor;\n    }\n```\n\n在 PhoneWindow 的  setContentView 方法中最终会将 传入的参数也就是这里的 subDecor 添加到之前创建的 mContentParent 中。至此，DecorView 中已经包含了我们通过 setContentView 设置的内容。按照上面的 onResume 的逻辑，当 DecorView 显示的时候，我们添加的 View 也就显示了。\n\n最后，再来看一个问题，当我们没有调用 setContentView 的时候，为什么也能显示一个正常的窗口呢？这个其实也很简单了，在代码了打个断点就可以发现，除了上面提到的 setContentView 会调用 ensureSubDecor 之外，\n\n```java\n    public void onPostCreate(Bundle savedInstanceState) {\n        // Make sure that the sub decor is installed\n        ensureSubDecor();\n    }\n```\n\nonPostCreate 也会调用这个方法。也就是说，要么我们在 onCreate 中调用，要么在系统会主动在 onPostCreate 中调用。总之，最后一定会创建 DecorView ，并把一个根据 Activity theme 创建出来的 subDecor 添加到 DecorView 当中。\n\n以上就是 Activity 中 UI 显示的梳理。\n\n\n\n\n\n\n\n## 参考文档\n - 《Android 开发艺术探索》\n - [Window/WindowManager 不可不知之事\n](https://mp.weixin.qq.com/s/VDdDy3_nU0W1byM8H5B0Pw)\n\n\n","tags":["Android源码"]},{"title":"Android 原生项目集成 Flutter","url":"%2F2021%2F02%2F20%2FAndroid-%E5%8E%9F%E7%94%9F%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90-Flutter%2F","content":"\n<img src=\"./Android-原生项目集成-Flutter/flutter.jpeg\" >\n\n## 前言\n\n了解一下如何在 Android 原生项目中集成 Flutter ，通过项目中打开 Flutter 页面。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [前言](#前言)\n- [添加 Flutter Module 并依赖](#添加-flutter-module-并依赖)\n    - [生成配置](#生成配置)\n    - [配置原生项目 settings.gradle](#配置原生项目-settingsgradle)\n    - [关于 include_flutter.groovy](#关于-include_fluttergroovy)\n    - [依赖 flutter](#依赖-flutter)\n- [集成 Flutter UI 到原生项目](#集成-flutter-ui-到原生项目)\n    - [FlutterEngine 提前初始化并缓存](#flutterengine-提前初始化并缓存)\n    - [打开 FlutterActivity 或 FlutterFragment](#打开-flutteractivity-或-flutterfragment)\n    - [一些坑](#一些坑)\n- [flutter pub get](#flutter-pub-get)\n- [Flutter 一些思考](#flutter-一些思考)\n- [参考文档](#参考文档)\n\n<!-- /TOC -->\n\n## 添加 Flutter Module 并依赖\n\n### 生成配置\n\n在原生项目根目录执行命令 \n  \n```shell\nflutter create -t module --org {package_name} {module_name}\n\n// 此处 module_name 的命令遵循 Android 子 module 的命名即可。不能有中划线。\n\n// 比如, \n\nflutter create -t module --org com.engineer.mini.flutter sub_flutter\n```\n结果\n\n```shell\nCreating project sub_flutter...\n  sub_flutter/test/widget_test.dart (created)\n  sub_flutter/sub_flutter.iml (created)\n  sub_flutter/.gitignore (created)\n  sub_flutter/.metadata (created)\n  sub_flutter/pubspec.yaml (created)\n  sub_flutter/README.md (created)\n  sub_flutter/lib/main.dart (created)\n  sub_flutter/sub_flutter_android.iml (created)\n  sub_flutter/.idea/libraries/Dart_SDK.xml (created)\n  sub_flutter/.idea/modules.xml (created)\n  sub_flutter/.idea/workspace.xml (created)\nRunning \"flutter pub get\" in sub_flutter...                      1,054ms\nWrote 11 files.\n```\n最终生成了以上文件，注意这里最后**自动执行了 flutter pub get** 的命令。关于 flutter pub get 具体做了什么，可以参考后面的[描述](#依赖-flutter)。\n\n**这里在项目根目录创建子 module 只是为了把代码放在一个仓库，方便维护，理论上可以放在硬盘的任何位置**。\n\n\n### 配置原生项目 settings.gradle \n\n在配置 settings.gradle 之前先来简单回顾一下关于 Gradle 的一些基础知识。\n\n如果你了解过 Gradle 相关的配置的话，一定会看到一个概念，就是**约定优于配置**，什么意思呢，按照面向对象的思路来理解，每一个工程是一个巨大的 Project 类，整个类里有很多的属性。而我们创建的每一个项目其实就是一个具体的 Project 对象（也就是实例).约定优于配置的意思，就是在 project 实例化的时候，其内部的属性已经有了默认值。那么我们怎么知道有哪些默认值呢？在项目根目录执行 \n\n```shell\n ./gradlew properties\n```\n就可以得到整个 Project 的一些默认配置，比如（此处节选部分结果）\n\n```shell\n------------------------------------------------------------\nRoot project\n------------------------------------------------------------\n\nallprojects: [root project 'MiniApp', project ':app', project ':thirdlib']\nandroid.agp.version.check.performed: true\nandroid.enableJetifier: true\nandroid.enableR8: true\nandroid.enableR8.libraries: true\nandroid.useAndroidX: true\nbuildDir: /Users/username/Documents/mygithub/MinApp/build\nbuildFile: /Users/username/Documents/mygithub/MinApp/build.gradle\nprojectDir: /Users/username/Documents/mygithub/MinApp\nrootDir: /Users/username/Documents/mygithub/MinApp\nrootProject: root project 'MiniApp'\n```\n这里当前有一些是我们配置的，比如 useAndroidX，但也有一些是约定的，比如 对于整个 project 来说 buildDir 就是项目根目录的 build 文件夹等。\n\n执行 \n\n```shell\n ./gradlew :app:properties\n```\n节选部分结果\n\n```shell\nbuildDir: /Users/username/Documents/mygithub/MinApp/app/build\nbuildFile: /Users/username/Documents/mygithub/MinApp/app/build.gradle\n```\n\n就会得到关于 app 整个 module 现阶段的一些配置信息，当然这些配置信息除了约定的，还有你自己配置的，比如 buildToolsVersion ，签名等相关信息。可以看到 buildDir 和整个 project 的是不一样的。\n\n回到主题， 看看如何把我们刚才创建的 sub_flutter 模块集成到项目中。（严格来说并不是集成 sub_flutter 模块，因为他只是一个 flutter 的模块，而在 Android 主项目只能集成子 Android module，那么具体该怎么做呢，下面就来看看其中的奥秘）\n\n按照官方的操作方法，会要求我们添加以下配置到 settings.gradle 中。\n\n```shell\n// Include the host app project.\ninclude ':app'                                    // assumed existing content\nsetBinding(new Binding([gradle: this]))                                // new\nevaluate(new File(                                                     // new\n  settingsDir.parentFile,                                              // new\n  'my_flutter/.android/include_flutter.groovy'                         // new\n))                                                                     // new\n```\n\n首先看看 这里的 settingsDir 的值。在 settings.gradle 中直接添加\n```groovy\nprintln \"settings.dir=\" + settingsDir\nprintln \"settings.dir.parent=\" + settingsDir.parent\n```\nsync 之后就会看到输出\n\n```shell\nsettings.dir=/Users/username/Documents/mygithub/MinApp\nsettings.dir.parent=/Users/username/Documents/mygithub\n```\n所以，上面的配置信息，就是说结合 settings 所在目录的父目录和我们配置的目录结合，找到一个名为 include_flutter.groovy 的文件，然后去执行他。\n\n前面说了，创建子 module 的时候，可以是在项目根目录，也可以是在其他位置，如果是在其他位置，这里的 my_flutter 可以替换为你创建目录的绝对路劲。\n\n这里是在根目录直接创建的，那么以上的配置就可以简化为\n\n```gradle\nsetBinding(new Binding([gradle: this]))\nevaluate(new File(settingsDir, 'sub_flutter/.android/include_flutter.groovy'))\ninclude ':sub_flutter'\n```\n\n### 关于 include_flutter.groovy\n\n上面说了，settings.gradle 的配置，其实就是去执行 include_flutter.groovy 这个文件，可以简单看一下这个文件\n\n```groovy \ndef scriptFile = getClass().protectionDomain.codeSource.location.toURI()\ndef flutterProjectRoot = new File(scriptFile).parentFile.parentFile\n\ngradle.include \":flutter\"\ngradle.project(\":flutter\").projectDir = new File(flutterProjectRoot, \".android/Flutter\")\n\ndef localPropertiesFile = new File(flutterProjectRoot, \".android/local.properties\")\ndef properties = new Properties()\n\nassert localPropertiesFile.exists(), \"❗️The Flutter module doesn't have a `$localPropertiesFile` file.\" +\n                                     \"\\nYou must run `flutter pub get` in `$flutterProjectRoot`.\"\nlocalPropertiesFile.withReader(\"UTF-8\") { reader -> properties.load(reader) }\n\ndef flutterSdkPath = properties.getProperty(\"flutter.sdk\")\nassert flutterSdkPath != null, \"flutter.sdk not set in local.properties\"\ngradle.apply from: \"$flutterSdkPath/packages/flutter_tools/gradle/module_plugin_loader.gradle\"\n```\n.android 其实就是一个 Android 项目，他包含一个 Flutter 文件夹，这 Flutter 是一个 library 类型的 Android module ，这个一点从他的 build.gradle 文件就可以看出。 include_flutter.groovy 所做的事情，就是将当前 library 命名为 flutter 的一个 moudle。然后检查项目中 local.properties 中 sdk 的相关配置，最后去执行 FlutterSDK 的中 gradle 脚本，这里具体的分析就不再展开了。\n\n也就是说，现在有一个名为  flutter 的 Android Library Module 。这个 module 包含 flutter 的所有配置。我们如果依赖了这个 module ,那么就相当于是依赖了 Flutter .\n\n### 依赖 flutter \n\n最后在原生项目的 application-module 的 build.gradle 的 dependencies 闭包中添加\n\n```gradle\n    implementation project(':flutter')\n```\n至此，原生项目已经有了 Flutter 的依赖，可以使用 Flutter 的 UI 了。\n\n至此，现在的原生项目就包含 Flutter SDK 的所有依赖了。 Flutter UI 相关的内容，该怎么写还是用 dart 在 main.dart 中写，然后我们就可以把这个 dart 渲染出来的内容按照 Activity 、Fragment 或 View 的形式添加到已有的项目中了。具体怎么添加，下面来看。\n\n## 集成 Flutter UI 到原生项目\n\n### FlutterEngine 提前初始化并缓存\n\n按照官方的建议以及实际体验，在这种原生项目后集成 Flutter 的场景下，需要提前预热（官方称为 pre-warm) Flutter 引擎，也就是说提前启动 Dart 的虚拟机，否则当你以其他方式添加 Flutter 的内容时再创建 Flutter 引擎，体验会非常糟糕，尤其是首次打开页面的时候。\n\n因此，简单起见我们可以使用 IdleHandler 在应用启动后进行预热操作。（理论上这种后期集成 Flutter 的页面应该不是首页及需要 App 启动后立即显示的页面，大部分情况下至少是个二级甚至三级页面，因此这样做是合理的）\n\n```kotlin\n    fun onCreate() {\n        Looper.myQueue().addIdleHandler {\n            initFlutterEngine()\n            false\n        }\n    }\n\n    private fun initFlutterEngine() {\n        val flutterEngine = FlutterEngine(context)\n        flutterEngine.navigationChannel.setInitialRoute(\"/custom/route/page\") // 1\n        flutterEngine.dartExecutor.executeDartEntrypoint(\n                DartExecutor.DartEntrypoint.createDefault()  // 2\n//                DartExecutor.DartEntrypoint(FlutterInjector.instance()\n//                        .flutterLoader().findAppBundlePath(), \"fakeMain\")\n        )\n        FlutterEngineCache\n                .getInstance()\n                .put(MinApp.FLUTTER_ENGINE_KEY, flutterEngine)\n    }\n\n```\n\n注释 1 处的实现不是必须的，注释 2 处是默认实现。\n\n按照上面的代码，在这个 FlutterEngine 被启动的时候，会默认执行 main.dart 中的 main 方法。```DartExecutor.DartEntrypoint.createDefault()``` 这个默认的实现结点就是 main 方法，这点从代码了很容易窥探到。当然，我们也可以在 FlutterEngine 启动的时候指定自定义的执行结点，比如上面注释中的 ```fakeMain()``` 方法，是定义在 main.dart 中的一个 Dart 方法。（当然，这里有一个坑，后面再说）。\n\n当然，我们也可以按注释 1 出写的那样， FlutterEngine 在启动的时候，执行指定路由对应页面的提前初始化工作。（当然，这里还是有坑的，后面统一说）\n\n### 打开 FlutterActivity 或 FlutterFragment\n\n有了缓存好的 FlutterEngine，我们就可以用它打开 FlutterActivity 和 FlutterFragment 了。\n\n```kotlin\n        viewBinding.flutterActivity.setOnClickListener {\n            startActivity(\n                FlutterActivity\n                    .withCachedEngine(MinApp.FLUTTER_ENGINE_ID)\n                    .build(this)\n            )\n        }\n        viewBinding.flutterFragment.setOnClickListener {\n            if (supportFragmentManager.fragments.size > 0) {\n                return@setOnClickListener\n            }\n            currentFragment = FlutterFragment.withCachedEngine(MinApp.FLUTTER_ENGINE_ID).build()\n            supportFragmentManager.beginTransaction()\n                .replace(R.id.flutter_container, currentFragment!!)\n                .commitAllowingStateLoss()\n        }\n```\n\nFlutterActivity 和 FlutterFragment 都是 Flutter SDK 内封装好的，便于在原生项目中集成 Flutter 的实现。当然，你也可以使用 FlutterView ,但是比较复杂，具体可以参考官方指导 。\n\n这样上面打开的 Activity 或添加的 Fragment 就会默认展示 main.dart 中配置的 Widget 所对应的 UI。\n\n<img src=\"./Android-原生项目集成-Flutter/flutter-activity.png\" width=50% />\n\nFlutterFragment 已经被 add 到当前页面的 FrameLayout 中了。\n\n### 一些坑\n\n这里说一下这种做法的一些坑。\n\n- 官方是建议提前缓存 FlutterEngine ，但是按照实际体验与其说是建议，不如说是必须做的事情，否则打开页面的体验真的只能用非常卡来形容了。\n\n- 关于 pre-warmed FlutterEngine 的一些细节。\n\n>Note: To warm up a FlutterEngine, you must execute a Dart entrypoint. Keep in mind that the moment executeDartEntrypoint() is invoked, your Dart entrypoint method begins executing. If your Dart entrypoint invokes runApp() to run a Flutter app, then your Flutter app behaves as if it were running in a window of zero size until this FlutterEngine is attached to a FlutterActivity, FlutterFragment, or FlutterView. Make sure that your app behaves appropriately between the time you warm it up and the time you display Flutter content.\n\n按照这段描述的意思，提前创建 FlutterEngine 并不只是创建了一个执行环境，而是在提前执行代码，类似于用一个 1 像素的 Activity 敲敲执行一些后台逻辑。因此，但是我们的 Flutter 代码的执行依赖于一个 Activity 或者是 Window,那么就会失败。\n\n比如，我要做一个显示用户相册的页面，因此需要申请权限，但在 pre-warmed 的时候，Flutter Widget 所要要依赖的 Activity 并没有被 attached. 这个时候，势必会导致代码运行的异常。\n\n- 前面说了，我们可以在 FlutterEngine 创建的时候，指定特定的执行结点，而不一定要执行 main() 方法，从而规避一些问题，是这样没错。但是，当打出 release 版本的 Apk时， main.dart 中的代码被混淆了，自定义的执行结点找不到了，比如上面代码中注释掉的 fakeMain() 方法，在 Debug 阶段时正常的，但是在 release 的版本就会出现找不到方法的异常日志。这里其实很好奇 main 方法是怎么找到的，难道没有被混淆？\n\n- 在来说说 ```flutterEngine.navigationChannel.setInitialRoute``` 这个似乎很牛逼的配置，意思是我可以在初始化 FlutterEngine 的时候，执行特定路由所对应的 Widget ，而不是默认的 home 配置。比如，main.dart 默认加载的是 A Widget，可以通过路由配置在初始化的时候执行 B Widget 的逻辑。似乎很好，如果 B Widget 恰好很耗时的话，似乎还可以做优化呢？但是我们再看一下打开页面时候的代码\n\n```kotlin \n            startActivity(\n                FlutterActivity\n                    .withCachedEngine(MinApp.FLUTTER_ENGINE_ID)\n                    .build(this)\n            )\n```\n\n是的，你没法做任何其他和 FlutterEngine 有关的配置了，现在打开的 FlutterActivity 会默认显示 B Widget ，A Widget 直接被忽略了。是不是很坑？（o(╥﹏╥)o\n\n- 最后这个集成的 Flutter module 会导致整个项目编译变慢，是非常明显的变慢了。\n\n坦白来说，在原生项目中接入 Flutter 现阶段还是会有投入产出比不高的体验，虽然写实际功能或业务的代码可以复用了，似乎是省了人力成本，但是实际上这中间的还是有许多意想不到的坑要去趟，有些问题都是前人没有遇到过的，到最后只能自己去读源码或是自己给官提 issue 找答案，总体来说整体流程还是比较费时的。\n\n## flutter pub get\n\nflutter pub get 或者 pub get 是在做 flutter 的时候在使用第三方 lib 或版本更新的时候经常会使用一个命令，通过这个命令会拉取相关的依赖，其实这个命令还会自动生成 Android 和 iOS 的原生项目。比如在我们创建就的 sub_flutter 模块中，均自动生成了 .android 和 .ios 的原生项目目录。同时这两个目录都是点打头的，那么一般情况下就是隐藏文件，同时通过 .gitignore 文件也可以看到，对于 flutter module 形式来说，这两个文件夹都是被忽略的，毕竟 flutter module 的核心，还是为了方便以 module 的形式集成到原生的项目中，内部的两个原生目录，一方面是为了方便集成，另一方面是便于直接运行执行 hot-reload 的调试。\n\n## Flutter 一些思考\n\nFlutter 的确很棒，尤其在低端机上的表现，比如我手边的小米 5 上，长列表滑动或者网格图显示图片，流畅度和原生页面几乎是一样的。但是在高端机上就没有什么优势了，总不能比原生实现还牛逼吧。 HotReload 很实用，尤其是客户端还是比较偏 UI 的情况下，对开发效率是一个很大的提升。同时现阶段各类需要和原生通信的插件还是挺丰富的，虽然适配情况及实现质量层次不齐，比如 Android 权限获取的适配，Android Q 沙盒机制下存储空间访问的适配，相册读写的适配等，都没有非常完美的实现。同时这类跨平台的插件实现，需要满足 Android、iOS 双端甚至是未来更多端的需求，所以还有很长的路要走。\n\n至于 Flutter 自身，Dart 语法写 UI 的嵌套问题其实也不是什么完全无法接受的事情，写多了，自然而然就习惯了，或者说实在不行就不断的创建小方法，将局部的嵌套用方法体来包裹掉。\n\n<img src=\"./Android-原生项目集成-Flutter/dart-code.png\" />\n\n比如上面这样，按照一些都是 Widget 的思路，做一些封装之后，代码看起来也还行，写起来也能习惯。\n\n槽点：\n\n最后，再说一下 Flutter 页面的生命周期简直是过于捡漏了，关键结点太少了，来来去去就是 build 、setState .很多场景下，限制太大了。\n\n好了，暂时这些，Flutter 未来可期。新项目或试水项目值得投入，在试错阶段可以有非常高效的产出。\n\n## 参考文档\n\n[Add-To-An-Android-App](https://flutter.dev/docs/development/add-to-app/android/add-flutter-fragment?tab=cached-engine-with-initial-route-java-tab)\n\n","tags":["flutter"]},{"title":"Java 之 goto, 标签的使用","url":"%2F2021%2F02%2F05%2FJava%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8%2F","content":"\n<img src=\"Java标签的使用/java.jpeg\"  />\n\n## 前言\n\n最近在看一些 Java 源码或 Kotlin 库反编译的 Java class 文件之后，看到了一种之前不曾用过的 Java 语法，**标签**。本文就使用标签的原因及用法，做一些简单的的总结。\n\n<!--more-->\n\n## 什么是 Java 中的标签\n\n说来惭愧，在去搜 Java 标签这个字眼之前，我甚至都不知道 Java 当中有标签这种语法。那么，什么是标签呢？\n\n\n### kotlin 协程中的标签\n\n作为 Android 开发者，如果你用过 Kotlin 的协程，并尝试去了解过他的内部原理，那么你一定见过标签。\n\n```kotlin\nsuspend fun getPeople(): String {\n    withContext(Dispatchers.IO) {\n        delay(1000)\n    }\n    return \"mike\"\n}\n\nsuspend fun getAge(name: String): Int {\n    withContext(Dispatchers.IO) {\n        delay(1000)\n    }\n\n    return 100 + name.hashCode()\n}\n```\n比如上面这两个支持挂起的 suspend 方法。我们用 AS 去查看他反编译的 Java 代码 \n\n<img src=\"Java标签的使用/java_label.png\" width=60%/>\n\n上面的 ```label20:``` 就是标签,当然这两个标签没有任何关系。\n\n### Android ViewBinding 中的标签\n\n随着 kotlin-android-extensions 这个 plugin 被官方废弃，为了不再写 findViewById 的模板代码，又开始使用 ViewBinding 了。那么 ViewBinding 背后的实现又是什么呢？\n\n我们可以在 application-module 的 ```app/build/generated/data_binding_base_class_source_out/debug/out/{package_name}/ ```\n\n下看到所有自动生成的 XXXViewBinding 文件；这里随便找一个文件，看他的 binding 方法。\n\n```java\npublic static ActivityFlutterRootBinding bind(@NonNull View rootView) {\n    // The body of this method is generated in a way you would not otherwise write.\n    // This is done to optimize the compiled bytecode for size and performance.\n    int id;\n    missingId: {\n      id = R.id.flutter_activity;\n      Button flutterActivity = rootView.findViewById(id);\n      if (flutterActivity == null) {\n        break missingId;\n      }\n\n      id = R.id.flutter_container;\n      FrameLayout flutterContainer = rootView.findViewById(id);\n      if (flutterContainer == null) {\n        break missingId;\n      }\n\n      return new ActivityFlutterRootBinding((LinearLayout) rootView, flutterActivity,\n          flutterContainer, flutterFragment);\n    }\n    String missingId = rootView.getResources().getResourceName(id);\n    throw new NullPointerException(\"Missing required view with ID: \".concat(missingId));\n  }\n  ```\n  可以看到这里的 ```missingId:``` 就是一个标签。（注意这里最后定义的 ```String missingId``` 和这个标签没有任何关系，这是恰好同名而已。\n\n  看起来都是在循环中使用，那么为什么要使用标签呢？他解决了什么问题呢？\n\n  ## 为什么使用标签\n\n  说起标签，就不得不提 goto ,学过 C 语言的同学应该至少看到过这个关键字，但应该是都没有用过。记得大一上计算机课，老师讲到这个 goto 的时候，非常严肃的说，你们只要知道有 goto 这么个东西就可以了，不要在代码里使用他。\n\n  于是乎在后来学习 Java 的时候，当每次看到 goto 的章节时，也是没仔细看就跳过了。可能因此就和标签错过了。🤣 🤣 🤣 🤣 🤣 🤣 。至于为什么不建议使用 goto 后来代码写多了，原因也了解了。在 Java 中 goto 虽然是关键字，当也仅此而已。\n\n  >在 Java 中，在 break 和 continue 这两个关键字的身上，我们仍能看出一些 goto 的影子。它们并不属于一次跳转，而是中断循环语句的一种方法。\n\n  >对 Java 来说，唯一用到标签的地方是在循环语句之前。进一步说，它实际需要紧靠在循环语句的前方 —— 在标签和循环之间置入任何语句都是不明智的。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环或者一个开关。这是由于 break 和 continue 关键字通常只中断当前循环，但若搭配标签一起使用，它们就会中断并跳转到标签所在的地方开始执行。代码示例：\n\n  ```java\n  label1:\nouter-iteration { \n  inner-iteration {\n  // ...\n  break; // [1] \n  // ...\n  continue; // [2] \n  // ...\n  continue label1; // [3] \n  // ...\n  break label1; // [4] \n  } \n}\n```\n\n - [1] break 中断内部循环，并在外部循环结束。 \n - [2] continue 移回内部循环的起始处。但在条件 3 中，continue label1 却同时中断内部循环以及外部循环，并移至 label1 处。 \n - [3] 随后，它实际是继续循环，但却从外部循环开始。 \n - [4] break label1 也会中断所有循环，并回到 label1 处，但并不重新进入循环。也就是说，它实际是完全中止了两个循环。\n\n*以上内容引用自 《On Java8》，当然观点颇有些片面，比如以上两个举例使用的地方都不是循环，当然这不妨碍我们理解他的本质*。\n\n简单理解，从退出循环的角度出发， continue label 和 break label 都可以用 return 语句实现。但是 return 会退出整个方法体，而 continue 或 break 标签并不会，**只是回退到标签的位置重新开始或整体跳过标签继续执行后面的代码。**\n\n比如 ViewBinding 的 bind 实现 \n\n```java\npublic static ActivityFlutterRootBinding bind(@NonNull View rootView) {\n    // The body of this method is generated in a way you would not otherwise write.\n    // This is done to optimize the compiled bytecode for size and performance.\n    int id;\n    missingId: {\n      id = R.id.flutter_activity;\n      Button flutterActivity = rootView.findViewById(id);\n      if (flutterActivity == null) {\n        break missingId;\n      }\n\n      id = R.id.flutter_container;\n      FrameLayout flutterContainer = rootView.findViewById(id);\n      if (flutterContainer == null) {\n        break missingId;\n      }\n\n      return new ActivityFlutterRootBinding((LinearLayout) rootView, flutterActivity,\n          flutterContainer, flutterFragment);\n    }\n    String missingId = rootView.getResources().getResourceName(id);\n    throw new NullPointerException(\"Missing required view with ID: \".concat(missingId));\n  }\n```\n这里并没有采用遍历当前布局中所有 view 的方式，而是按照定义的内容去执行 findViewById 。因此，这里使用 label 是一个非常便捷的实现。当然，也可以把这个方法改造成带返回值的方法，在调用这个方法的位置根据返回值决定是否抛出异常。\n\n协程中的实现也是类型的原因，由于在一个协程体内内部可以调用另一个协程方法，因此会有多个标签需要同时去处理，而如果简单的使用 return 进行退出，将导致代码结构非常繁杂，简单的使用标签，就可以实现跳过整段代码块儿的逻辑。\n\n\n## 总结\n\n\b借鉴 Kotlin 协程和 ViewBinding 中对标签的使用逻辑，是非常好理解的，即便是对不了解标签的人，也是基本上可以一句话解释清楚的逻辑。但是，如果为了使用标签而强行在各个地方用标签，可能会无谓的增添程序的复杂性，阅读起来非常难以理解。\n\n\n## 参考\n\n《On Java8》书籍\n\n\n\n\n\n\n\n\n\n","tags":["Java"]},{"title":"hexo markdown 一些 trick","url":"%2F2021%2F01%2F13%2Fhexo-markdown-%E4%B8%80%E4%BA%9B-trick%2F","content":"\n\nhexo 写 blog 的一些很难在网上找到好办法的问题及答案。\n\n<!--more-->\n\nQ: 如果在 文章中实现对于本地文章的超链接\n\nA: 在普通的 markdown 文档中，我们可以直接使用类似超链接的的方式，\n使用 ```[目标文章](目标文章的本地相对路劲)``` 来实现。但是在 hexo 中 markdown 文档被转换为 html 之后，这样的信息肯定是不行的。因此，需要按下面的方式来。\n\n```\n{% post_link 目标文章的title %}\n```\n\n~~注意这里 title 必须是文章内 title ,而不能是 markdown 文档的名字~~。由于文章 title 可能会有空格，因此直接用 hexo 自动生成的 xx.md 的文件名即可。\n这个语法在 markdown 中是没有预览的，只有在最终生成的 html 中有效果。\n\nfor example :\n\n```\n{% post_link 我的少年时代 %}\n```\n\n{% post_link 我的少年时代 %}\n","tags":["高效工作"]},{"title":"A 计划","url":"%2F2021%2F01%2F01%2FA-%E8%AE%A1%E5%88%92%2F","content":"\n**凡事预则立不预则废**\n\n<br/>\n<img src=\"A-计划/cute(2).gif\" width=40% style =\"border-radius:8px\" >\n\n<!--more-->\n\n<br/>\n\n8 月 TODO\n\n- Reading\n\n|List|OK|week-32|week-33|week-34|week-35|week-36|R|C|\n|----|--|-|-|-|-|-|-|-|\n|**OnJava8**|读完|90%|\n|**labuladong** 算法|读完|40%|\n|见识-吴军|读完|41%|\n|中国经济 2021||9%|\n|**第一行代码**|读完|50%|\n\n\n- Writing\n\n|List|OK|week-32|week-33|week-34|week-35|week-36|R|C|\n|----|--|-|-|-|-|-|-|-|\n|技术类|3篇|||\n|     |HashMap|\n|     |多态|\n|     |AAC - ViewModel - LiveData|\n|     |Kotlin Syntactic Sugar|\n|     |Code Review Skills|\n|     |View-layout|\n|     |View-draw|\n|     |Handler Again|\n|     |OnJava8 Reading Notes|\n|     |OkHttp CodeReview|\n\n- Entertainment\n\n|List|OK|week-32|week-33|week-34|week-35|week-36|R|C|\n|----|--|-|-|-|-|-|-|-|\n|Moive|4|||\n|     |**速度与激情1**|done|\n|     |**速度与激情2**|done|\n|TV   |1|||\n|家有儿女|日常|37|\n\n\n***\narchived\n***\n\n\n\n<br/>\n<details>\n<summary>\n1 月 TODO\n</summary>\n\n\n- Reading\n\n|List|OK|week-1|week-2|week-3|week-4|week-5|R|C|\n|----|-|-|-|-|-|-|-|--|\n|**肖申克的救赎**|读完|12%|20%|\n|**文明之光**|30%|||\n|**水浒传连环画**|读完|%6|50%|100%|||√|\n|**西游记连环画**|读完|||||20%|\n\n- App\n\n\n|List|OK|week-1|week-2|week-3|week-4|week-5|R|C|\n|----|-|-|-|-|-|-|--|--|\n|TimeFly||||\n|       |自定义添加倒计时|||\n|       |UI Better|||\n|StreeView|||||||√|\n|       |add a tool|done||\n|       |fix issue and feature||done|\n|       |bug-fix school filter|||done||\n|       |bug-fix ||||done|||\n|       |photo editor|||\n\n- Writing\n\n\n|List|OK|week-1|week-2|week-3|week-4|week-5|R|C|\n|----|-|-|-|-|-|-|--|--|\n|技术类|3篇|||\n|     |HashMap Code Review|50%||\n|     |二进制|||\n|     |Flutter Embed With Android|||\n|     |Android Framework|||\n|公众号||||\n|      ||||\n\n- Entertainment\n\n\n|List|OK|week-1|week-2|week-3|week-4|week-5|R|C|\n|----|-|-|-|-|-|-|--|--|\n|Moive|4|||\n|     |我和我的家乡|done|||\n|     |疯狂原始人2||done||\n|     |送你一朵小红花|||\n|     |铁雨|||\n|     |极限职业|||\n|TV   |1|||\n|     |老友记第四季|done||\n|     |无耻之徒最终季|||\n|     |小希尔顿第四季|||\n|     |老友记第五季|04|12|20|24(完)|\n|     |老友记第六季||||01~02|03~07|\n|     |旺达幻视|||01~02|03~04|\n|     |奇葩说|两期|两期|两期|两期|两期|\n|     |王牌对王牌第六季|||||一期|\n|     |来自星星的你||||1~16集|\n|     |新西游记||||1~14集|15~16集|\n\n- Review \n\nPS: 这一个月是工作特别特别忙的一个月，有很多次下班都到了晚上 10 点之后甚至更晚。因此，有点乱。睡眠质量有点差，所以整体完成质量有点不好。要适应，无论如何还是要有自己的节奏，自己的规划。\n - 基本没有时间读书，Kindle 充了两次电，都没有打开看 10 分钟。下个月补上。好在看了连环画。\n - StreetView 缝缝补补活跃度似乎有所提升，但是道路漫长，还是有很多要做的事情。\n - 电视看的太多了，后面需要克制一下。\n\n</details>\n\n<br/>\n<img src=\"A-计划/cute(1).gif\" width=40% style =\"border-radius:8px\">\n\n\n<br/>\n<br/>\n\n<details>\n<summary>\n2 月 TODO\n</summary>\n\n\n- Reading\n\n|List|OK|week-6|week-7|week-8|week-9|R|C|\n|----|-|-|-|-|-|---|--|\n|**肖申克的救赎**|读完|20%|done|||电影比书精彩|\n|**文明之光**|30%||40%|90%|100%|只读了第四册，整体其实都值得一读|\n|**西游记连环画**|读完|100%||||\n|**Kotlin 实战**|读完|30%|40%|70%||二次读发现更多之前没理解的东西，值得细品|\n|**并发编程之美**|读完|0%|||||下个月继续|\n|三国演义连环画|读完|0%||60%|100%|\n\n- App\n\n\n|List|OK|week-6|week-7|week-8|week-9|R|C|\n|----|--|-|-|-|-|--|--|\n|TimeFly||||\n|       |自定义添加倒计时||||done|\n|       |UI Better||||done|\n|       |自定义添加事件||||done|\n|StreeView||||\n|       |spring feature|done||\n|1050   |ad update & coroutines|||done|\n|1051   |add a tool||||done|\n\n- Writing\n\n\n|List|OK|week-6|week-7|week-8|week-9|R|C|\n|----|-|-|-|-|-|--|--|\n|技术类|3篇|||\n|     |HashMap Code Review|50%||\n|     |二进制|||\n|     |Flutter Embed With Android|||\n|     |Android Framework-window|||\n|     |Android Framework-ipc|||\n|     |Android Media|||done|\n|公众号||||\n|      ||||\n\n- Entertainment\n\n\n|List|OK|week-6|week-7|week-8|week-9|R|C|\n|----|-|-|-|-|-|--|--|\n|Moive|4|||\n|     |送你一朵小红花|||\n|     |铁雨||||done|\n|     |极限职业|||\n|TV   |1|||\n|     |无耻之徒最终季|||\n|     |小谢尔顿第四季|||02~04|05~06|\n|     |老友记第六季|08-15|16-19|20~23|24~25|\n|     |旺达幻视|05||06~07|08|\n|     |奇葩说|13~14|15~16|17~18|19-20||\n|     |王牌对王牌第六季|一期|一期||||\n|     |来自星星的你|17~21||||\n|     |赘婿||1-8|9-14|15~21|\n\n - Review\n\n    - 读书进展整体较好，继续保持\n    - 小程序开始支持个人应用记事，可以继续扩展了\n    - Streetview 可以往工具箱的方向发展\n    - 关于写东西，需要一个开始，有了一些积累，可以开始写了\n  \n    **总之呢，无法一口气吃成一个胖子，发现问题，解决问题，不忘初心，方得始终**\n\n</details>\n\n<br/>\n<img src=\"A-计划/cute(3).gif\" width=40% style =\"border-radius:8px\">\n\n\n<br/>\n<br/>\n\n\n<details>\n<summary>\n3 月 TODO\n</summary>\n\n\n- Reading\n\n|List|OK|week-10|week-11|week-12|week-13|week-14|R|C|\n|----|-|-|-|-|-|-|---|--|\n|**Kotlin 实战**|读完|80%|100%||||done|\n|**并发编程之美**|读完||100%||||done|\n|**OnJava8**|读完||20%|30%|60%|70%||内容不错，下月继续|\n|把时间当做朋友-李笑来|||||||40%|\n|算法图解|读完|done|\n|计算机基础|\n|操作系统基础|\n|Android 源码|\n\n- App\n\n\n|List|OK|week-10|week-11|week-12|week-13|week-14|R|C|\n|----|-|-|-|-|-|-|---|--|\n|TimeFly||||\n|       |**分享到朋友圈功能**|||||||下月尝试|\n|       |**倒计时编辑功能**|||||\n|       |倒计时过滤功能|||||\n|       |UI 优化|done||||\n|StreeView||||\n|       |**add a flutter page**|||50%|100%|||too hard|\n|       |photo edit|||||done|\n|       |gen qrcode|done||\n|       |mirror fun||done|\n\n- Writing\n\n\n|List|OK|week-10|week-11|week-12|week-13|week-14|R|C|\n|----|-|-|-|-|-|-|---|--|\n|技术类|3篇|||\n|     |HashMap Code Review|||\n|     |二进制|||\n|     |Flutter Embed With Android||70%|100%|\n|     |Android Framework-window||70%|\n|     |Android Framework-ipc|||||30%|\n|     |Java 标签||100%|\n|     |UInspector Code-Review|||100%|\n|     |hexo 文章内超链接|\n|公众号||||\n|      ||||\n\n- Entertainment\n\n\n|List|OK|week-10|week-11|week-12|week-13|week-14|R|C|\n|----|-|-|-|-|-|-|---|--|\n|Moive|4|||\n|     |**拆弹专家2**||done|\n|     |波斯语课|||done||||临时添加|\n|     |正义联盟||||done|||临时添加|\n|     |极限职业|||\n|     |超时空通话|||\n|TV   |1|||\n|开始看    |无耻之徒最终季||01|02~03|\n|开始看    |猎鹰与冬兵|||01|02|03|\n|日常     |小谢尔顿第四季|07~09|10|11|\n|第一季结局    |旺达幻视|09|||||done|\n|本季最后两期    |奇葩说|21|||||done|\n|日常   |王牌对王牌第六季|一期|一期|一期|一期|一期|\n|日常     |赘婿|22~29|30~36||||done|\n\n\n- Review \n\n  - 为了微信读书，特地购买了小米多看电子书，用起来效果还不错。读书还是比较有意思，其实好书可以多读几遍的。\n  - 写东西还是需要一个开始，一旦有了开始，后面就容易慢慢坚持下去。\n  - 看电视、刷剧少了一些，基本上每周一部电影的节奏。《真意联盟》四个小时太费时间了，其实也没多好看，以后慎重选择这种长剧。又想看结局，又没有太多时间，看完都大半夜了。\n  - 似乎可以尝试一些别的东西了。\n\n\n</details>\n\n<br/>\n<img src=\"A-计划/cute(4).gif\" width=40% style =\"border-radius:8px\">\n\n<br/>\n<br/>\n\n\n<details>\n<summary>\n4 月 TODO\n</summary>\n\n- Reading\n\n|List|OK|week-15|week-16|week-17|week-18|R|C|\n|----|-|-|-|-|-|---|--|\n|**OnJava8**|读完|80%|\n|**极客时间**|读完|8%|\n|把时间当做朋友-李笑来|读完|60%|\n|计算机基础|读完|\n|操作系统基础|读完|\n|Android 源码|读完|\n\n- App\n\n\n|List|OK|week-15|week-16|week-17|week-18|R|C|\n|----|-|-|-|-|-|---|--|\n|TimeFly||||\n|       |**分享到朋友圈功能**|||||\n|       |**倒计时编辑功能**|||||\n|       |倒计时过滤功能|||||\n|StreeView||||\n|       |**some thing**|\n\n- Writing\n\n\n|List|OK|week-15|week-16|week-17|week-18|R|C|\n|----|-|-|-|-|-|---|--|\n|技术类|3篇|||\n|     |HashMap Code Review|||\n|     |二进制|done||\n|     |Android Framework-window|done|\n|     |Android Framework-ipc|||\n|     |more..|\n|公众号||||\n|      ||||\n\n- Entertainment\n\n\n|List|OK|week-15|week-16|week-17|week-18|R|C|\n|----|-|-|-|-|-|---|--|\n|Moive|4|||\n|     |**刺杀小说家**|done||\n|     |**一朵小红花**|||\n|TV   |1|||\n|看完最后两集    |无耻之徒最终季|11|12|||done|\n|最后三集    |猎鹰与冬兵|04|||05|\n|日常     |小谢尔顿第四季|13|\n|本季最后两期   |王牌对王牌第六季|11期|12期|||done|\n\n</details>\n\n<br/>\n<img src=\"A-计划/cute(5).gif\" width=40% style =\"border-radius:8px\">\n\n<br/>\n<br/>\n\n\n<details>\n<summary>\n5 月 TODO\n</summary>\nLeetCode And Android-Soruce-code\n\n\n## Result Review\n\n- 刷 LeetCode 完成 104 题，了解了一些套路和规则，锻炼形成了一些思路。再接再厉\n- 看完代码还是需要总结一下，落地到文章或笔记，遗忘是不可避免的。无论当下记得多么清楚。\n- 失败并不可怕，可怕的是没有面对失败的勇气和信念，人生充满了不确定性和未知，需要\n  自己以强大的心态去面对一切。\n- 制定好计划，一步一步的做。\n\n</details>\n\n<br/>\n<img src=\"A-计划/cute(6).gif\" width=40% style =\"border-radius:8px\" >\n\n<details>\n<summary>\n6 月 TODO\n</summary>\n\n- Reading\n\n|List|OK|week-23|week-24|week-25|week-26|week-27|R|C|\n|----|-|-|-|-|-|-|---|--|\n|**OnJava8**|读完|20%|30%||\n|**原则**|读完|40%|50%|\n|labuladong 算法||50%|\n\n- Writing\n\n\n|List|OK|week-23|week-24|week-25|week-26|week-27|R|C|\n|----|-|-|-|-|-|-|---|--|\n|技术类|3篇|||\n|     |HashMap Code Review|||\n|     |Android Framework-ipc|||\n|     |more..|\n\n- Entertainment\n\n\n|List|OK|week-23|week-24|week-25|week-26|week-27|R|C|\n|----|-|-|-|-|-|-|---|--|\n|Moive|4|||\n|     |**爵迹-冷血狂宴**|done||\n|     |**电话**|done||\n|     |X 战警|||done|\n|     |X 战警二|||done|\n|     |X 战警三|||done|\n|     |祖宗十九代|||done|\n|     |**悬崖之上**||||done|\n|     |**一朵小红花**|||||done|\n|TV   |1|||\n|伪装者    ||33~47|48||||done|\n|老友记第七季|||12~15|16~24|\n|老友记第八季||||1~12|13~19|20~24|done|\n|日常     |小谢尔顿第四季|15~18|||||done|\n|洛基|    ||1||2|\n\n\n</details>\n\n<br/>\n<img src=\"A-计划/cute(7).gif\" width=40% style =\"border-radius:8px\" >\n\n\n\n<details>\n<summary>\n 7 月 TODO\n</summary>\n\n\n\n- Reading\n\n|List|OK|week-28|week-29|week-30|week-31|R|C|\n|----|--|-|-|-|-|-|-|\n|**OnJava8**|读完|\n|**原则**|读完|60%|65%|||pause|\n|labuladong 算法|读完|\n|态度-吴军|读完|100%|\n|见识-吴军||10%|15%|20%|30%|40%|\n|剑指offer|读完||100%|\n|被讨厌的勇气|读完||100%|\n|中国经济 2021||5%|8%|\n\n\n- Writing\n\n|List|OK|week-28|week-29|week-30|week-31|R|C|\n|----|--|-|-|-|-|-|-|\n|技术类|3篇|||\n|     |HashMap Code Review|\n|     |多态|\n|     |Android Framework-ipc|\n|     |Java 类初始化和实例化细节||||done|\n|     |View-Measure||||done|\n\n- Entertainment\n\n\n|List|OK|week-28|week-29|week-30|week-31|R|C|\n|----|--|-|-|-|-|-|-|\n|Moive|4|||\n|     |**芝加哥七君子审判**|done|\n|     |**指环王1**|done|\n|     |**黑寡妇**||done|\n|     |**杀手妻子保镖**|||done|\n|     |王国：北方的阿信||||done|\n|     |我是谁||||done|\n|TV   |1|||\n|洛基|完成|03||04~06||done|good|\n|后翼弃兵|试看|||||done|not as good as expected|\n|家有儿女|日常|||32|33|\n|斯巴达克斯第二季||||01~02|\n\n\n## Result Review\n\n - 吴军的 《见识》是一本非常值得细读和再次阅读的书，里面有很多的道理或者说是常识吧，是一些早已了解和知晓是内容，但是从没有去深入的践行过和思考过这些内容的意义。比如 **吾生也有涯，而知也无涯** 。总是吉祥学这个又想了解那个，到最后发现知识没有形成体系；什么都是知道一点，但又说不清道不明，还不如聚焦在某个点上认认真真的了解清楚。\n - 《原则》这本书只有在某些职位之上才能发挥他的价值，比较就像书名原则一样，都是一些教会我们如何面对工作和生活的边界；有些书看一看，丰富了我们的思维，而有些书里的内容值得去实践，但是不是所有人的生活都可以过得像瑞达利欧那般的丰富多彩，并没有那么多可以做的选择。\n - **电影、书、音乐**的评价因人而异，即便是大多数人觉得好的、有价值的东西，也未必适合当下的你。\n - 不要对生活失去希望，要永远相信美好的事情总是会发生。早睡早起，有计划的做该做的事情，不要当一天和尚撞一天钟。\n\n\n\n\n</details>\n\n<br/>\n<img src=\"A-计划/cute(8).gif\" width=40% style =\"border-radius:8px\" >\n\n\n***\n\n友情链接： {% post_link 远走高飞 %}","tags":["OKR"]},{"title":"2021 Book And Movie List","url":"%2F2021%2F01%2F01%2F2021-Book-And-Movie-List%2F","content":"\n**自律给我自由**\n\n<img src=\"2021-Book-And-Movie-List/cute.gif\" />\n\n<!--more-->\n\n## Book\n\n- book read once\n    - [x] **文明之光-吴军(第四册)** ❤️❤️❤️❤️❤️\n    - [ ] **理财相关**\n    - [x] **原则 (60%)-stop**\n    - [x] **薛兆丰经济学讲义**\n    - [ ] **四大名著连环画**\n        - [x] 水浒传 ❤️❤️❤️❤️❤️\n        - [x] 西游记 ❤️❤️❤️❤️❤️\n        - [x] 三国演义 ❤️❤️❤️❤️❤️\n        - [ ] 红楼梦\n    - [ ] 豆瓣 2020 年度读书榜单\n    - [x] 肖申克的救赎原版小说 ❤️❤️❤️❤️\n    - [ ] 瓜迪奥拉传记\n    - [x] **态度-吴军** ❤️❤️❤️❤️❤️\n    - [ ] **见识-吴军** (reading)\n    - 微信读书\n        - [x] 做时间的朋友-李笑来 ❤️❤️❤️❤️\n        - [x] 给投资新手的极简股票课 ❤️❤️❤️❤️\n        - [x] 三分钟漫画汽车史 ❤️❤️❤️❤️\n        - [x] 三分钟漫画武器史 ❤️❤️\n        - [x] 被讨厌的勇气 ❤️❤️❤️❤️❤️\n        - [ ] 中国经济 2021 (reading)\n        - [ ] 第一行代码-第三版 (reading)\n  \n\n- book on bed\n    - [ ] 软技能\n    - [x] 并发编程之美 ❤️❤️❤️\n    - [x] Kotlin 实战 ❤️❤️❤️❤️❤️\n    - [ ] Head First 设计模式 (reading)\n    - [ ] 图解 HTTP （reading)\n    - [x] Android 进阶之光 ❤️❤️❤️\n    - [x] 剑指offer ❤️❤️❤️\n    - [x] 算法图解 ❤️❤️❤️\n    - [ ] OnJava 8 (reading)\n\n## Movie\n\n- [x] **速度与激情9** ❤️❤️❤️❤️❤️\n- [x] **黑寡妇** ❤️❤️❤️\n- [x] **~~猎鹰与冬兵~~(是电视剧）** ❤️❤️❤️\n- [x] **我和我的家乡** ❤️❤️❤️❤️❤️\n- [x] **送你一朵小红花** ❤️❤️❤️❤️\n- [ ] **心灵奇旅**\n- [x] **拆弹专家 2** ❤️❤️❤️❤️\n- [x] **疯狂原始人 2** ❤️❤️❤️\n- [x] **爵迹 2** ❤️❤️\n- [x] **电话** ❤️❤️❤️❤️\n- [x] **芝加哥七君子审判** ❤️❤️❤️\n- [ ] **~~侍神令~~** (abandon)\n- [ ] 紧急救援\n- [ ] 康斯坦丁\n- [ ] 碧蓝之海\n- [ ] 爱与怪物\n- [ ] 波拉特\n- [ ] 辣手保姆\n- [x] 铁雨 ❤️❤️❤️❤️❤️\n- [ ] 太极张三丰\n- [ ] 古董局中局\n- [x] 你好,李焕英 ❤️❤️❤️❤️❤️\n- [x] 刺杀小说家 ❤️❤️❤\n- [ ] ~~行骗天下~~ (abandon)\n- [ ] 极限职业\n- [ ] 爱尔兰人\n- [ ] 南方车站的聚会\n- [ ] **花样年华**\n- [ ] 大侦探皮卡丘\n- [x] 波斯语课 ❤️❤️❤️❤ （N）\n- [x] 正义联盟-扎克施耐德版 ❤️❤️❤️❤ （N）\n- [x] 祖宗十九代 ❤️（N）\n- [x] X 战警 ❤️❤️❤️ （N）\n- [x] X 战警2❤️❤️❤️ （N）\n- [x] X 战警3❤️❤️❤️ （N）\n- [x] 悬崖之上 ❤️❤️❤️❤️❤️ （N）\n- [x] 人潮汹涌 ❤️❤️❤️ (N)\n- [x] 指环王1 ❤️❤️❤️❤️ (N)\n- [x] 杀手妻子的保镖 ❤️❤️ (N)\n- [x] 王国-北方的阿信 ❤️❤️❤️❤️❤️ （N）\n- [x] 我是谁 ❤️❤️❤️ (N)\n- [x] 速度与激情 1 ❤️❤️❤️ (N)\n\n\n## Tv\n\n- [x] **无耻之徒第第十一季-最终季** ❤️❤️❤️❤️❤️\n- [x] **小谢尔顿第四季** ❤️❤️❤️❤️\n- [x] **旺达幻视** ❤️❤️❤️❤️❤️\n- [x] **老友记第四季** ❤️❤️❤️❤️❤️\n- [x] **奇葩说第七季** ❤️❤️❤️❤\n- [x] **伪装者** ❤️❤️❤️❤️❤️\n- [ ] **谁是被害者**\n- [x] **王牌对王牌第六季**  ❤️❤️❤️❤️❤️\n- [x] **猎鹰与冬兵** ❤️❤️❤️❤️\n- [ ] 人间课堂\n- [ ] 年少轻狂\n- [ ] 请再来四杯\n- [x] 老友记第五季❤️❤️❤️❤️❤️\n- [x] 老友记第六季❤️❤️❤️❤️❤️\n- [x] 老友记第七季❤️❤️❤️❤️❤️\n- [x] 老友记第八季❤️❤️❤️❤️❤️\n- [ ] 家有儿女第一部 (watching)\n- [x] 洛基 ❤️❤️❤️ (N)\n- [x] 赘婿 ❤️❤️❤️❤️(N)\n- [x] 斯巴达克斯-前传 ❤️❤️❤️❤️❤️ (N)\n- [ ] 斯巴达克斯第二季-复仇 (watching)\n\n## 纪录片（科普片）\n\n- [ ] 计算机科普 40 讲 （B站）\n- [ ] 小小世界\n- [ ] 我们的星球\n- [ ] 完美星球 （ing）\n\n## PS\n\n1. **加粗**的内容是一定会看的\n2. 目标:多看点书\n(N) : 非计划中发生的事情\n\n\n友情链接： {% post_link 2020-Book-And-Movie-List %}","tags":["诗与远方"]},{"title":"二进制","url":"%2F2020%2F12%2F28%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%2F","content":"\n\n<img src=\"./二进制/binary.gif\" width=50%>\n\n## 前言\n\n经常会在代码中看到用二进制实现一些标志位的运算，简单总结一下二进制的一些概念。了解\n使用二进制的原因。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [前言](#前言)\n- [二进制](#二进制)\n    - [比特和字节](#比特和字节)\n    - [二进制与十进制的互相转换。](#二进制与十进制的互相转换)\n    - [二进制正负数的表示](#二进制正负数的表示)\n- [二进制的运算](#二进制的运算)\n    - [用二进制位表示 boolean 值](#用二进制位表示-boolean-值)\n        - [读值](#读值)\n        - [写 1](#写-1)\n        - [写 0](#写-0)\n        - [通用实现](#通用实现)\n    - [在 Android 中的使用](#在-android-中的使用)\n        - [MeasureSpec](#measurespec)\n            - [一些细节](#一些细节)\n- [总结](#总结)\n- [参考文档](#参考文档)\n\n<!-- /TOC -->\n\n## 二进制\n\n### 比特和字节\n\n先了解一下比特。 \n\n计算机中最小的存储单位是二进制位（binary digit），也叫比特， bit 只能够存储 0 或 1。由 8 bit 串联组成的称为字节（byte）。\n也就是常说的 ```1 byte = 8 bit ```。\n\n1 个字节可以代表 256 种不同的可能（2<sup>8</sup>）\n\n```\n10101010 | 11111111 |\n```\n\n### 二进制与十进制的互相转换。\n\n关于二进制和十进制互相转换的方法，这个 [如何快速学会二进制？](https://www.zhihu.com/question/287005214) 知乎回答解释的很清楚了。这里贴一下原图。\n\n<img src=\"./二进制/otc-2-bin.jpg\" width=50%>\n\n十进制转换为二进制，**记得最后的余数要倒序排列，才是结果**，比如上图中 23 = 10111\n\n<img src=\"./二进制/bin-2-otc.jpg\" width=50%>\n\n至于二进制到十进制的转换相对来说说就比较简单了。我们知道十进制中\n\n- 123 的含义是  1x100 + 2x10 +3x1 = 123.\n- 1024 的含义是 1x1000 + 0x100 +2x10 + 4x1 = 1024\n这中间的 1000，100,10,1 就是每一位的权重。对于二进制也有类似的概念\n\n- 111 = 4x1 + 2x1 + 1x1 = 7 \n- 1010 = 8x1 + 4x0 + 2x1 + 1x0 = 10\n\n|幂|二进制|十进制|\n|-|--|--|\n|~|00000000|0|\n|0|00000001|1|\n|1|00000010|2|\n|2|00000100|4|\n|3|00001000|8|\n|4|00010000|16|\n|5|00100000|32|\n|6|01000000|64|\n|7|10000000|128|\n\n从表中我们也可以看到 1byte 8位二进制数可以表达 0~255 的值，也就是说 8 位二进制代表着 256 种可能性。\n\n### 二进制正负数的表示\n\n上面我们说，8 位二进制可以代表 256 种可能性，这是在非负整数的情况下，正常情况下还有负数。\n\n>在计算机0和1的世界中，没有'-'号，意味着它没法直接表示一个负数，我们如果想表示一个负数，只能在程序中去体现：比如声明成有符号的数据类型signed int（一般简写为int），这个类型既可以表示负整数也可以表示正整数。这就意味着：在内存中有一段二进制数据，你可以把它当成正整数也可以负数，甚至浮点数。\n\n为了更好的表示正数和负数，计算机规定：有符号数据的最高位是1则表示负数，为0则表示正数。而具体可以分为**原码，反码，补码**三种表示法\n\n - 原码表示法\n\n 最高位为1表示负数，剩余数据的表示与正整数相同。比如01010表示正数10，11010表示负整数-10。这种表示方法最符合我们正常人的思维方式。\n\n - 反码表示法\n\n 最高位为1表示负数，剩余的数据按照正整数的值按位取反，即:最高位1，然后对剩下的1010按位取反，得到0101，然后组合起来：10101。\n\n 以上两种表达方式式有点瑕疵：0的表示都有两种，原码表示法中10000(负)和00000(正)都表示0，反码表示法中，11111(负)和000000(正)都表示0（这里先假设数据只有5bit，如果是类型则是32个1），这样会浪费一个字节，而且也不利于计算。（注意无论是什么表示，正数的表达都是一样的）\n\n- 补码表示法\n\n最高位表示负数，剩余数据按照正整数的值按位取反，再加1，这同时也是反码转补码的方法。\n\n|二进制数|原码|反码|补码|十进制数|\n|-|-|-|-|-|\n|1000 0000|1000 0000|1111 1111|0000 0000|0/-0|\n|0000 0001|0000 0001|0000 0001|0000 0001|1|\n|1000 0001|1000 0001|1111 1110|1111 1111|-1|\n|1111 1111|1111 1111|1000 0000|1000 0001|-127|\n|0111 1111|0111 0111|0111 1111|0111 1111|127|\n\n\n-128 的补码是 1000 0000 . 当然，八位二进制数，能表达的最大整数是 127,因此，这是一条特例。至于具体的细节可以参考[原码、反码、补码的产生、应用以及优缺点有哪些？](https://www.zhihu.com/question/20159860/answer/21113783)\n\n**一条运算规律：对非负数的二进制进行取反、然后+1，便可得其负数的二进制表示**\n\n所以 8 位二进制用来表示有符号的数，可以表达的的范围是 -128~~127，也就是 -(2)<sup>7</sup>~2<sup>7</sup> -1 \n\n所以补码表示法中，所有能表示负数的个数要比正整数多一个，因为正整数中有一个0000 0000被当做0了呀。 \n\n我们知道在 Java 中，int 类型的数据有 4 个字节保存，也就是 32 位。\n因此，范围就是 -(2)<sup>31</sup>~2<sup>31</sup> -1 的值。\n\n\n看完了二进制的表示与转换，我们再看看看二进制的运算，这里主要说逻辑运算。\n\n## 二进制的运算\n\n二进制只有 0 和 1 表示 false 与 true。 对应的逻辑运算\n\n - 与 运算符为 &\n\n |input|input|out|\n |-|-|-|\n |0|0|0|\n |1|0|0|\n |0|1|0| \n |1|1|1|\n\n - 或 运算符为 |\n\n |input|input|out|\n |-|-|-|\n |0|0|0|\n |1|0|1|\n |0|1|1| \n |1|1|1|\n\n - 非 运算符为 ~\n\n \n |input|out|\n |-|-|\n |1|0|\n |0|1|\n\n - 异或 运算符为 ^\n\n |input|input|out|\n |-|-|-|\n |0|0|0|\n |1|0|1|\n |0|1|1| \n |1|1|0|\n\n关于异或运算，我们可以总结出规律\n\n**1. 0 与 A (任意值)异或的结果为 A**\n\n**2. 任何数与自己异或的结果为 0**\n\n### 用二进制位表示 boolean 值\n\n> 在java中，一个字节，也就是 8 位，而布尔值在 Java 中至少占用一个字节（关于布尔值具体占几个字节，不在此处讨论），如果用户有 7 个属性，如是否为汉族、是否为男性等，如果全用布尔值来表示，就是 7 个字节。也可以用一个字节来表示，用 1 和 0 代表是和否。用1个字节替代 7 个字节来表示信息，空间节省 80% 以上。 \n\n\n|8|7|6|5|4|3|2|1|\n|-|-|-|-|-|-|-|-|\n|1|0|1|0|0|0|1|1|\n\n用二进制位表示 boolean 标志位，我们需要关心三件事，即读取某一位的值，在某一位如何正确的写入 0 或 1 。\n\n#### 读值 \n\n怎么读取某个位是 0 还是 1 ？\n\n以第三位为例，即4的二进制00000100，利用与运算，可以知道某个位是否被 enable 了。\n\n```\n  00001001//9的二进制\n& 00000100//4的二进制\n= 00000000//0的二进制\n\n即 00001001 & 00000100 != 00000100 可判定，第三位 enable = false\n  00001101//13的二进制\n& 00000100//4的二进制\n= 00000100//4的二进制\n即 00001101 & 00000100 == 00000100 可判定，第三位 enable = true\n```\n\n#### 写 1\n\n怎么在不影响其他位的情况下，把某个位设为1？\n\n这里会利用到或运算，我们还是以第三位为例子\n\n```\n//当第三位没有 enable 时\n  00001001//9的二进制\n| 00000100//4的二进制\n= 00001101//13的二进制\n//当第三位 enable 时，设置前后，值应该是不变的\n  00001101//13的二进制\n| 00000100//4的二进制\n= 00001101//13的二进制\n```\n\n#### 写 0\n\n怎么在不影响其他位的情况下，把某个位设为0？\n\n这里会利用与、取反运算，我们仍以第三位为例子： 4的二进制 00000100 取反得到 11111011\n\n```\n//当第三位没有被置起时\n  00001101//13的二进制\n& 11111011//4的二进制取反\n= 00001001\n```\n\n\n#### 通用实现\n\n以上二进制位的读写可总结为实现\n\n```java\npublic class BitUtils {\n\n    public static void main(String[] args) {\n        int flag = 127;\n        System.out.println(check(flag,1));\n        flag = setBit(flag, 1, false);\n        System.out.println(check(flag, 1));\n        flag = setBit(flag, 8, true);\n        System.out.println(check(flag,8));\n        flag = setBit(flag, 5, false);\n        System.out.println(check(flag,5));\n    }\n\n    public static boolean check(int flag, int bit) {\n        System.out.println(\"BitUtils: flag: \" + Integer.toBinaryString(flag) + \", bit is \" + bit);\n        return (flag & bit) == bit;\n    }\n\n    public static int setBit(int flag, int bit, boolean value) {\n        int result;\n        if (value) {\n            result = flag | bit;\n        } else {\n            result = flag & (~bit);\n        }\n        System.out.println(\"BitUtils: flag: \" + Integer.toBinaryString(result));\n        return result;\n    }\n}\n```\n\n```shell\nBitUtils: flag: 1111111, bit is 1\ntrue\nBitUtils: flag: 1111110\nBitUtils: flag: 1111110, bit is 1\nfalse\nBitUtils: flag: 1111110\nBitUtils: flag: 1111110, bit is 8\ntrue\nBitUtils: flag: 1111010\nBitUtils: flag: 1111010, bit is 5\nfalse\n```\n\n可以看到结果和预期是完全符合的。\n\n### 在 Android 中的使用\n\n在 Android 中关于二进制位的使用，最熟悉的莫过于令人头疼的 MeasureSpec 了(关于 MeasureSpec 和 View 相关的内容不再此展开，此处只讨论其二进制位的使用)\n\n#### MeasureSpec \n\n```java\n    public static class MeasureSpec {\n        private static final int MODE_SHIFT = 30;\n        private static final int MODE_MASK  = 0x3 << MODE_SHIFT;\n\n    \n        public static final int UNSPECIFIED = 0 << MODE_SHIFT;\n\n        public static final int EXACTLY     = 1 << MODE_SHIFT;\n\n        public static final int AT_MOST     = 2 << MODE_SHIFT;\n\n    \n        public static int makeMeasureSpec(@IntRange(from = 0, to = (1 << MeasureSpec.MODE_SHIFT) - 1) int size,\n                                          @MeasureSpecMode int mode) {\n            if (sUseBrokenMakeMeasureSpec) {\n                return size + mode;\n            } else {\n                return (size & ~MODE_MASK) | (mode & MODE_MASK);\n            }\n        }\n\n        @MeasureSpecMode\n        public static int getMode(int measureSpec) {\n            //noinspection ResourceType\n            return (measureSpec & MODE_MASK);\n        }\n\n        public static int getSize(int measureSpec) {\n            return (measureSpec & ~MODE_MASK);\n        }\n    }\n```\n\n首先是 MODE_MASK, 它对 11 进行了左移 30 位的操作\n\n```java \nInteger.toBinaryString(MODE_MASK) == \"11000000000000000000000000000000\"\n```\n即 32 位 int 的高两位为 1，其余均为 0。\n\n那么其 getMode 和 getSize 的实现就很好理解了，就是利用与运算和非运算对相应的位进行屏蔽。\n\nmakeMeasureSpec 的实现也很好理解了， MODE_MASK 分别取最高为的值和剩余位的值，然后通过或运算再合起来。\n\n##### 一些细节\n\n- Mode 的具体值 \n\n```shell\nUNSPECIFIED = 0\nEXACTLY     = 1073741824\nAT_MOST     = -2147483648\n```\n\n- size 的范围\n\n32 位高两位表示 mode ,那么剩下的 30 位用来表示 size，也就是说实际上 size = (0~2<sup>30</sup>) 这么大的范围。但是在 makeMeasureSpec 方法中用 ```@IntRange`` 对 size 进行了限制，\nsize 的最大值为 \n\n```java\n(1 << MODE_SHIFT) - 1  ---> 1073741823\nMath.pow(2,30)         ---> 1073741824\n```\n\n可以看到实际最大值比预期的最大值少了 1。\n\n\n## 总结\n\n在 Android 源码中使用，使用二进制位进行位运算节省内存的场景还要很多，比如 View 的 mPrivateFlags 等各类标示是否需要进行绘制、测量操作的位。\n\n围绕二进制可以有很多话题可以展开讨论，比如二进制和物理内存的关系，和缓存的关系等，更多可以参考这篇[二进制](http://rkhcy.github.io/binary/)。\n\n\n\n## 参考文档\n\n - https://www.zhihu.com/question/287005214/answer/747864425\n - https://zhuanlan.zhihu.com/p/55405151\n - https://zhuanlan.zhihu.com/p/94577806\n - https://www.zhihu.com/question/20159860/answer/21113783\n - http://rkhcy.github.io/binary/\n\n","tags":["基础"]},{"title":"Android-Multi-Media","url":"%2F2020%2F09%2F15%2FAndroid-Multi-Media%2F","content":"\n<img src=\"./Android-Multi-Media/multi-media.jpg\" />\n\n学习和了解 Android 音视频开发相关的一些总结和梳理，有了一个基础和感性的认识。有哪些点以及用这些点可以做些什么有了一个大概的了解，简单列一下。\n\n<!--more-->\n\n## 基础知识概念相关\n\n音视频基础参见{% post_link 音视频知识 %},不再赘述。\n\n## 在 Android 中如何播放一个音频/视频\n\n### 音频播放\n\n有句话叫做没声音再好的戏也出不来。因此，音频播放的好坏（尤其是对于一个视频来说）是非常关键的。在 Android 中根据播放场景的不同，在加上手机上有铃声、电话声音、音乐播放的声音等不同的音源，音频播放有以下几种选择。\n\n#### MediaPlayer \n这个可能是最常用的。它非常强大。具体使用后面会详细分析，这里简单说一下他的缺点： **资源占用量较高、延迟时间较长、不支持多个音频同时播放等**\n\n#### SoundPool\n针对上述 MediaPlayer 的缺点，如果我们只是播放一些简单的音乐片段，比如游戏音效，音频特效的场景下是比较合适的。SoundPool支持多个音频文件同时播放(组合音频也是有上限的)，延时短，比较适合短促、密集的场景，是游戏开发中音效播放的福音。\n\n#### AudioTrack\n>AudioTrack属于更偏底层的音频播放，MediaPlayerService的内部就是使用了AudioTrack。\n\n>AudioTrack用于单个音频播放和管理，相比于MediaPlayer具有：精炼、高效的优点。\n更适合实时产生播放数据的情况，如加密的音频，\nMediaPlayer是束手无策的，AudioTrack却可以。\n\n>AudioTrack用于播放PCM(PCM无压缩的音频格式)音乐流的回放，如果需要播放其它格式音频，需要响应的解码器，这也是AudioTrack用的比较少的原因，需要自己解码音频。\n\n如上介绍, AudioTrack 使用门槛较高，但是的确可以解决一些特殊场景的问题。\n\n以上三种播放音频的具体实现方式，可以参考文末的 [Android中播放音乐的几种方式](https://www.cnblogs.com/Im-Victor/p/9760629.html)。\n\n\n### 播放视频\n\n#### VideoView\n\nAndroid 系统提供了 VideoView 这样封装好的组件，可以直接用来播放视频，使用方式非常简单。\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".ui.SimpleVideoViewActivity\">\n\n    <VideoView\n        android:id=\"@+id/video_view\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n```kotlin\nclass SimpleVideoViewActivity : AppCompatActivity() {\n    private lateinit var viewBinding: ActivitySimpleVideoViewBinding\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        viewBinding = ActivitySimpleVideoViewBinding.inflate(layoutInflater)\n        setContentView(viewBinding.root)\n        viewBinding.videoView.setVideoPath(Constant.originalPath)\n        val control = MediaController(this)\n        viewBinding.videoView.setMediaController(control)\n        viewBinding.videoView.requestFocus()\n    }\n}\n```\n如上代码即可实现一个带进度条及快进、快退、播放和暂停功能的视频播放功能。\n\n<img src=\"Android-Multi-Media/videoview.png\" width=30% />\n\n如图，底部控制视频播放的工具栏是系统提供的 MediaController 组件，VideoView 整体是通过继承 SurfaceView 并组合 MediaPlayer,MediaController 等相关组件将视频播放的生命周期相关的细节在内部进行了封装，方便开发者使用。但是，他内部添加 MediaController 组件的方式不够灵活，无论视频高度是什么样的，播放控制的组件永远在屏幕底部。失去了一些灵活性，因此在大部分场景需要我们自己去定制播放器。\n\n#### MediaPlayer + SurfaceView\n\nMediaPlayer 的使用整体来说比较简单，重点是理解下面这幅图中他的生命周期，在正确时候做正确事，否则就会发生 Exception.\n\n<img src=\"./Android-Multi-Media/mediaplayer-life.gif\" width=40%/>\n\n通过合理使用设计模式，我们可以对 MediaPlayer 进行二次封装，将其接口调用和播放转态的回调按照自己的需求进行设计。\n\n```java\npublic interface PlayerAdapter {\n\n    void loadMedia(Object mediaRes);\n\n    default void loadMedia(String path){}\n\n    void release();\n\n    boolean isPlaying();\n\n    void play();\n    ......\n}\n```\n比如设计如上接口用于上层业务调用。通过桥接模式，将 MediaPlayer 内各种判断隐藏在内。\n\n```java\npublic final class MediaPlayerHolder implements PlayerAdapter {\n    \n    ......\n\n    private void initializeMediaPlayer() {\n        if (mMediaPlayer == null) {\n            mMediaPlayer = new MediaPlayer();\n            mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);\n            mMediaPlayer.setOnCompletionListener(mediaPlayer -> {\n                stopUpdatingCallbackWithPosition(true);\n                ....\n            });\n        }\n    }\n\n    // Implements PlaybackControl.\n    @Override\n    public void loadMedia(Object resource) {\n        mResourceObj = resource;\n\n        initializeMediaPlayer();\n        if (mResourceObj instanceof Integer) {\n            int id = (int) mResourceObj;\n            AssetFileDescriptor assetFileDescriptor =\n                    mContext.getResources().openRawResourceFd(id);\n            try {\n                mMediaPlayer.setDataSource(assetFileDescriptor);\n            } catch (Exception e) {\n            }\n        } else if (mResourceObj instanceof String) {\n            String path = (String) mResourceObj;\n            try {\n                mMediaPlayer.setDataSource(path);\n            } catch (Exception e) {}\n        }\n\n        try {           \n            mMediaPlayer.prepare();\n        } catch (Exception e) {}\n\n        initializeProgressCallback();\n        \n    }\n\n    @Override\n    public void release() {\n        if (mMediaPlayer != null) {\n            mMediaPlayer.release();\n            mMediaPlayer = null;\n        }\n    }\n\n    @Override\n    public boolean isPlaying() {\n        if (mMediaPlayer != null) {\n            return mMediaPlayer.isPlaying();\n        }\n        return false;\n    }\n\n    @Override\n    public void play() {\n        if (mMediaPlayer != null && !mMediaPlayer.isPlaying()) {\n            mMediaPlayer.start();\n            if (mPlaybackInfoListener != null) {\n                mPlaybackInfoListener.onStateChanged(PlaybackInfoListener.State.PLAYING);\n            }\n            startUpdatingCallbackWithPosition();\n        }\n    }\n\n    .....\n\n}\n```\n比如这里将播放器设置资源、初始化的细节及异常处理的逻辑进行封装。播放器转态的切换在内部进行处理，最大程度的方便上层业务聚焦于具体的逻辑而不是这些细节。\n\n最后，在具体的 View 层使用就比价简单了。\n\n```kotlin\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        viewBinding = ActivitySimpleMediaPlayerBinding.inflate(layoutInflater)\n        setContentView(viewBinding.root)\n        surfaceHolder = viewBinding.surfaceView.holder\n                viewBinding.buttonPlay.setOnClickListener {\n            if (playVideo) {\n                mPlayerAdapter.setDisplay(surfaceHolder)\n            }\n            mPlayerAdapter.play()\n        }\n    }\n```\n具体细节可以参考 GitHub 源码     [SimpleMediaPlayerActivity](https://github.com/REBOOTERS/Android-Multi-Media/blob/master/media/src/main/java/com/engineer/android/media/ui/SimpleMediaPlayerActivity.kt)\n\n## 为啥还要了解音视频编解码？\n\nMediaPlayer 只是提供了音视频的播放功能。对于音视频来说还有数据的采集、二次创作、数据的传输等很多事情。因此，了解 MediaPlayer 后可能连 Android 音视频开发的大门还没打开。我们需要更深入的去了解音视频编解码的功能。 \n\n### 为什么要编解码？\n\n总的来说，编码是为了**多快好省**，这里的编码广义的来说就是压缩编码，用更合理的方式去除冗余信息，将物理设备采集的音视频数据进行压缩，做到又高清体积又小（当然，这两这必须找到平衡点），这样存储占的体积小，传输起来快，岂不就是多快好省。\n\n>我们知道，在计算机的世界中，一切都是0和1组成的，音频和视频数据也不例外。由于音视频的数据量庞大，如果按照裸流数据存储的话，那将需要耗费非常大的存储空间，也不利于传送。而音视频中，其实包含了大量0和1的重复数据，因此可以通过一定的算法来压缩这些0和1的数据。\n>\n>特别在视频中，由于画面是逐渐过渡的，因此整个视频中，包含了大量画面/像素的重复，这正好提供了非常大的压缩空间。\n>\n>因此，编码可以大大减小音视频数据的大小，让音视频更容易存储和传送。\n\nmp4、rmvb、avi、mkv、mov...些我们熟悉的视频格式，其实是包裹了音视频编码数据的容器，用来把以特定编码标准编码的视频流和音频流混在一起，成为一个文件。\n\n例如：mp4支持H264、H265等视频编码和AAC、MP3等音频编码\n\n编码和解码其实是两个相对来说互逆的过程，其实本质上我们用电子产品处理数据都是在做编解码。\n\n下面就来梳理一下如何实现编解码\n\n## 音视频编解码 MediaCodec 和 FFmpeg \n\n### MediaCodec(硬解码)\n\n视频编解码，首先要提到的就是官方提供的 MediaCodec。\n\nMediaCodec是一个Codec，通过硬件加速解码和编码。它为芯片厂商和应用开发者搭建了一个统一接口。MediaCodec几乎是所有安卓播放器硬解的标配。\n\n<img src=\"Android-Multi-Media/mediacodec1.png\" />\n\nMediaCodec 作为编码器/解码器时数据流向的示意图。\n\n\n<img src=\"Android-Multi-Media/mediacodec2.image\" />\n\nMediaCodec 的状态图。\n\nMediaCodec有两种工作模式，分别为异步模式和同步模式。具体使用方式可以参考\n\n1. **[音视频硬解码流程：封装基础解码框架](https://juejin.im/post/5d89fa02518825095879d5b6)**\n2. **[音视频播放：音视频同步](https://juejin.im/post/5d9c69b351882539ee4b0eea)。**\n\n通过同步解码的方式，对 API 的使用做了非常详细的介绍。\n\n#### MediaExtractor\n\n总结来说，就是使用 MediaExtractor 获取视频、音频的各类信息，结合上面两幅图的状态不断读取数据然后通过 SurfaceView 进行显示。\n\n#### MediaMuxer\n\nMediaMuxer 和 MediaExtractor 可以说两个功能刚好对立的工具，MediaExtractor 负责对视频资源进行解封装，以获取音视频资源的各类参数信息，MediaMuxer 则是将现有的音视频数据通过各类配置再次打包成为一个音视频文件的过程。\n\n具体实现可以参考 **[音视频解封和封装：生成一个MP4](https://juejin.cn/post/6844903966535319560)**\n\n### FFmpeg (软解码)\n\n**这里的软解码只是相对于其自身的解码实现来说,他本身是使用 CPU 的能力来编解码**，但是我们也可以通过其他方式让 ffmpeg 间接的使用 GPU 进行硬解码。当然，编解码只是其一部分功能。\n\n[FFmpeg GitHub 仓库](https://github.com/FFmpeg/FFmpeg) 官方介绍\n\n>FFmpeg is a collection of libraries and tools to process multimedia content such as audio, video, subtitles and related metadata.\n\n### FFmpeg 使用\n\n从 FFmpeg 的定位就可以看到，ffmpeg 可以做很多事情，非常的灵活，可以自由定制。对外使用提供了强大的接口或者是命令行工具，这也是使得其学习成本非常的陡峭，需要耗费大量的时间去实践和了解具体的细节。关于 ffmpeg 的具体我们可以学习按照自己的需求去编译 ffmpeg 的本库库和共享库的代码之后集成到项目中去，也可以了解一些第三方在此基础上的一些框架之类的。这里简单列一些可以拓展的方向。\n\n- [FFmpeg 自己编译、NDK 到视频编解码最佳实践](https://juejin.cn/user/3175045310197255/post)\n\n- [GitHub FFmpge 关键结果](https://github.com/search?q=ffmpeg)\n  - [FFmpeg Official](https://github.com/FFmpeg/FFmpeg)\n  - [FFmpegAndroid](https://github.com/xufuji456/FFmpegAndroid)\n  - [JiaoZiVideoPlayer](https://github.com/lipangit/JiaoZiVideoPlayer)\n\n- [B站开源的基于 ffmpeg 的 ijkplayer 播放器](https://github.com/bilibili/ijkplayer)\n- [Google 官方的 exoplayer](https://github.com/google/ExoPlayer)\n\n### MediaCodec VS FFmpeg\n  \n>**FFmpeg**：FFmpeg本质上可以看做是媒体处理工具的集合，包含了很多的媒体文件处理工具，例如媒体文件格式解析工具、编解码器等，这些工具实际上就是一个个的库，而FFmpeg的命令行程序实际上就是对这些库的一种包装，在调用命令行程序时也是通过底下的这些库来完成操作。这些库有的是编译时可选的，而且FFmpeg也支持一些外部的库，例如x264、MediaCodec。FFmpeg由于提供了很多的编解码器，而且它的媒体操作也很丰富，所以可以支持非常多的媒体类型，同时很多的处理功能也已经由FFmpeg提供，使用者只需要去调用即可，所以不少的编辑处理功能可以相对简单地完成开发。缺点就是如果通过其自带的软编解码来完成移动端上的任务的话效率会比较低。\n\n>**MediaCodec**：MediaCodec提供的功能就相对单一，它基本上只用来完成编解码相关的功能。以整个视频转码流程举例，大致需要几个步骤：解封装->解码->滤镜处理等操作->编码->封装，MediaCodec只提供编解码功能，而其它的功能则需要其它组件，如MediaExtractor以及MediaMuxer来完成。但是MediaCodec在编解码时提供硬件编解码功能，其好处是非常明显的，效率很高，且CPU占用大幅降低。说实话如果不使用硬件编解码的话，很多的转码过程的时长实在长得是令人无法忍受，放到APP上简直就是无法使用的功能。毕竟一段很短的视频，转码要好几分钟，发烫还严重，体验肯定是不行的。MediaCodec的缺点就是一定程度上会依赖于设备，由于MediaCodec的硬解码实际上是由厂商所提供的，同时安卓设备的硬件相互之间差异很大，所以在硬解码实现上自然也有所差别，就导致了一样的程序，一些设备上可以正常跑，而在另一些设备上则可能会出问题，此时就需要自行提供兼容性上的支持。\n\n作一个简单的比喻：FFmpeg就像一个工具箱，而MediaCodec就像一类功能强大，但是使用范围相对受限且不够灵活的工具。\n\n有几个需要注意的点：\n1.FFmpeg也有对MediaCodec的支持，在编译出合适的库后，可以通过FFmpeg的api来调用MediaCodec，但只能使用解码功能。\n2.MediaCodec并非只代表硬编解码，它事实上可以看做是一种服务，厂商将自己的编解码方案预先注册于服务中，而用户在需要时再通过服务去调用相应的编解码器来完成任务。MediaCodec支持硬件编解码以及软件编解码，可以自行选择需要使用的编解码器。\n3.FFmpeg在使用MediaCodec时，使用的方式和JAVA调用是类似的，FFmpeg会通过JNI的callXXmethod去调用MediaCodec的方法，这个过程其实和JAVA中的调用没有区别，但是FFmpeg通过封装MediaCodec的操作，使得MediaCodec可以按照FFmpeg的编解码流程进行调用。\n\n\n**结合上面的对比，可以简单的认为 ffmepg 可以在兼顾效率的同时实现比较好的兼容性。同时由于 Android 在国内变成了安卓，各类厂商对解码器的魔改等因素导致 MediaCodec 可能无法做到很稳定。因此，实现一套非常完美的播放器是一个工业级的项目，在使用了这些已有方案踩过坑之后，结合使用经验再去实现一套自己的播放器才是有可能的**，所以说，基础很重要啊。\n\n## OpenGL \n\n说到音视频开发，就不得不了解一下 OpenGL，对于移动端来说就是 OpenGL ES。 \n\n>OpenGL（Open Graphics Library）则是间接操作GPU的工具，是一组定义好的跨平台和跨语言的图形API，是可用于2D和3D画面渲染的底层图形库，是由各个硬件厂家具体实现的编程接口\n\n>OpenGL ES 全称：OpenGL for Embedded Systems，是OpenGL 的子集，是针对手机 PAD等小型设备设计的，删减了不必须的方法、数据类型、功能，减少了体积，优化了效率。\n\n### OpenGL ES \n\nOpenGL 整体来说还是有一定的学习曲线，有很多新的概念需要去理解和掌握，有些还是比较抽象的。\n\n- OpenGL ES 坐标系\n- OpenGL 着色器语言 GLSL \n  - 顶点着色器\n  - 片元着色器\n  - [着色器语言](https://blog.csdn.net/junzia/article/details/52830604)\n  \n### Android 中 OpenGL ES 渲染流程\n\n在Android中，OpenGL通常配合GLSurfaceView使用，在GLSurfraceView中，Google已经封装好了渲染的基础流程。\n\n[Android OpenGL ES 最佳实践](https://juejin.cn/post/6844903975267860494)\n\n### OpenGL ES 可以做什么？\n\n- 滤镜\n回归到本质，视频就是一帧帧的图片，因此使用 OpenGL 可以实现滤镜。\n- 透明视频\n视频本身不透明的，但是我们可以通过 OpenGL 将两个视频叠加在一起渲染，实现视频叠加的效果，也可以认为是画中画的效果。\n\n## 总结  \n\n<img src=\"Android-Multi-Media/all.image\" />\n\n*图源自水印*\n\n上图对音视频开发中的几个重要模块做了很好的划分。总体来说，编码器、解码器是永恒的话题。但凡涉及对视频的再次操作，都会涉及得到编解码的操作。而这里就看选择用什么方式实现了，MediaCodec 和 FFmpeg 都有各自的优缺点，需要我们根据实际的业务选择合适的技术方案。\n\nOpenGL 就是用来对视频数据进行各类差异化的操作，比如滤镜、水印等。其实可以理解为对 view 进行动画。当然，其中要考虑的细节就特别多了，更是有很多新的概念和抽象的思考，需要我们去探索。比如着色器、比如坐标变换、内容投影等非常复杂的概念。\n\n好了，以上就是对音视频相关内容的一个大概梳理。当然只是现阶段的认知和思考，后面如果有了新的了解，可以再次更新现在的一些观点。\n\n## 参考资料\n\n- [Android中播放音乐的几种方式](https://www.cnblogs.com/Im-Victor/p/9760629.html)\n- [Google 官方音视频样例 GitHub 仓库](https://github.com/android/media-samples)\n\n- [音视频硬解码流程：封装基础解码框架](https://juejin.im/post/5d89fa02518825095879d5b6)\n- [音视频播放：音视频同步](https://juejin.im/post/5d9c69b351882539ee4b0eea)\n- [音视频解封和封装：生成一个MP4](https://juejin.cn/post/6844903966535319560)\n- [Android OpenGL ES 最佳实践](https://juejin.cn/post/6844903975267860494)\n\n- [FFmpeg GitHub 仓库](https://github.com/FFmpeg/FFmpeg)\n- [FFmpegAndroid](https://github.com/xufuji456/FFmpegAndroid)\n- [JiaoZiVideoPlayer](https://github.com/lipangit/JiaoZiVideoPlayer)\n- [B站开源的基于 ffmpeg 的 ijkplayer 播放器](https://github.com/bilibili/ijkplayer)\n- [Google 官方的 exoplayer](https://github.com/google/ExoPlayer)\n\n","tags":["音视频"]},{"title":"文件编解码及加密读写","url":"%2F2020%2F07%2F28%2F%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E8%AF%BB%E5%86%99%2F","content":"\n## 前言\n\n简单了解对文本内容或二级制的内容，进行加密解密(也可以理解为编解码)操作。\n\n<!--more-->\n\n## Base64 编解码\n\nbase64 并不该算作一种加密方式，更倾向于他是一种编码方式，将二进制文件进行编码后，方便传输，同时编码后的内容可以进行反编码，恢复内容。\n\n- base64 文本编解码\n\n```java\nimport org.apache.commons.codec.binary.Base64;\n\n    private static void basic() {\n        String chinese = \"中华人民共和国\";\n        System.out.println(\"origin is \" + chinese);\n        String encode = Base64.encodeBase64String(chinese.getBytes());\n        System.out.println(\"encode --> \" + encode);\n        byte[] temp = Base64.decodeBase64(encode);\n        String decode = new String(temp);\n        System.out.println(\"decode --> \" + decode);\n    }\n```\n\n可以非常方便的使用 apache commons-codec 库中的 Base64 工具类进行关于 base64 的编解码工作。 \n\n- base64 图片编码\n\n\n\n比如在 Web 端常用的图片 base64 编码。\n\n```java\n    private static String imageToBase64(String path) {\n        String prefix = processPrefix(path);\n        String result = \"\";\n        InputStream input;\n        byte[] data = {};\n        try {\n            input = new FileInputStream(path);\n            data = new byte[input.available()];\n            input.read(data);\n            input.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        result = Base64.encodeBase64String(data);\n        return prefix + result;\n    }\n```\n以上便是把图片转换为 String 的 base64 实现，最终结果是类似 \"data:image/filetype,xyz\" 这样的数据。\n这里需要注意的是不同类型的图片（文件），这里 `image/filetype` 中 filetype 顾名思义是文件类型，因此在转换时需要做特殊处理。\n\n\n## 自定义加密/解密\n\n通过以上实现，我们可以了解到，对**文件进行编解码就是对文件中对应的输入内容进行一些算法操作，这样的算法操作有不同的目的，有的可能只是想获取文件的唯一标识，比如 MD5 等。有的是为了对输入内容进行一些[干扰]，使得常规的解码方式，无法识别对这些进行过干扰的内容，从而实现所谓的加密**。这里就来尝试一下对文件的加密操作。\n\n```java\n    /**\n     * \n     * @param filepath 要加密文件的路劲\n     * @param outputPath 加密文件的输出路径\n     * @param encrypt 是否加密，true 加密，false 解密\n     * @return 是否成功\n     */\n    public static boolean encryptFile(String filepath, String outputPath,boolean encrypt) {\n        boolean result = false;\n        File file = new File(filepath);\n        File outputFile = new File(outputPath);\n        outputFile.deleteOnExit();\n        try {\n            FileInputStream fileInputStream = new FileInputStream(file);\n            FileOutputStream fileOutputStream = new FileOutputStream(outputFile);\n\n            BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);\n            BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream);\n\n            int n;\n            while ((n = bufferedInputStream.read()) != -1) {\n                // 加密/解密算法\n                encrypt(bufferedOutputStream,n,encrypt);\n            }\n            bufferedInputStream.close();\n            bufferedOutputStream.close();\n            result = true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n```\n\n回归到本质，对文件进行加密/解密，其实就是文件内容通过自定义的方式添加和移除一些干扰项。比如上面的实现，encrypt 操作如果简单的实现为 `bufferedOutputStream.write(n);` 那么这个过程其实就是一个简单的文件复制操作而已，因此关于文件加解密的重点就是如何实现 encryt 方法。\n\n```java\n    private static void encrypt(BufferedOutputStream bos, int length, boolean encode) throws IOException {\n        if (encode) {\n            bos.write(length - 10);\n        } else {\n            bos.write(length + 10);\n        }\n    }\n```\n可以看到，这里的加密操作还是非常简单的，就是在加密时对输出流的写操作偏移了 10 个长度，对应的解密操作，在对加密过后文件，进行恢复的时候，要进行相应的反向操作。\n\n测试一下\n\n```java\npublic class Main {\n    private static final String INPUT_FILE = \"./resources/poet.txt\";\n    private static final String MIDDLE_FILE = \"./resources/poet_secret.txt\";\n    private static final String OUTPUT_FILE = \"./resources/poet_rollback.txt\";\n\n    public static void main(String[] args) {\n        try (MethodCost cost = new MethodCost()) {\n\n            boolean result = FileEncryptor.encryptFile(INPUT_FILE, MIDDLE_FILE, true);\n            System.out.println(\"result is \" + result);\n        }\n        try (MethodCost cost = new MethodCost()) {\n\n            boolean result1 = FileEncryptor.encryptFile(MIDDLE_FILE, OUTPUT_FILE, false);\n            System.out.println(\"result1 is \" + result1);\n        }\n        simpleTextTest();\n    }\n}\n```\n- output\n\n```shell\nresult is true\nmethod  cost :3617700\nresult1 is true\nmethod  cost :1532200\n```\n从总体执行多次的结果来看，加密时间还是比解密长的。\n\n再看一下最终输出的文件\n\n- 文件变化 \n\n    - poet.txt\n\n        ```txt\n        先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。\n        。。。。。\n\n        ```\n    - poet_secret.txt\n\n        ```txt\n        �{~ۮ��w�ޥ�岂�}�ڮ��y�ۅ��w��z�ܵv�vx\u0003 \u0003 ڱ�۳�޵�ݜ�岂ڮ�ޗ�ܬ�ߑ�岂ڮ�ݕ��vޞ\n        ```\n\n    - poet_rollback.txt\n\n        ```txt\n        先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。\n        。。。。。\n        ```\n\n这里以《出师表》全文作为实例，可以看到加密之后，txt 文本再次打开已经完全变成了乱码，解码之后的文件又恢复到了最初的样子。\n\n## 总结\n\n文本或二级制文件加密、解密本质上其实都是一样的，都是回归到对编码的再次操作，不同的加密或解密方式，唯一的区别就是编码方式的实现不同而已。\n\n\n\n\n","tags":["Java,编解码"]},{"title":"Review C","url":"%2F2020%2F07%2F01%2FReview-C%2F","content":"\nReview C Notes \n\n<!--more-->\n\n## 基础\n\n### 数据类型\n\n[C 数据类型](https://www.runoob.com/cprogramming/c-data-types.html)\n\n为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 sizeof 运算符。表达式 sizeof(type) 得到对象或类型的存储字节大小。\n\n```c\n#include <stdio.h>\n#include <limits.h>\n \nint main()\n{\n   printf(\"int 存储大小 : %lu \\n\", sizeof(int));\n   \n   return 0;\n}\n```\n\n### 常量\n\n[常量](https://www.runoob.com/cprogramming/c-constants.html)\n\n可以使用 const 或 define 定义常量\n\n### 函数\n\n[函数](https://www.runoob.com/cprogramming/c-functions.html)\n\n函数包括 函数声明和函数定义，函数参数可以是传值调用，也可以是引用调用。\n\n## 进阶\n\n\n### 数组\n\n[数组](https://www.runoob.com/cprogramming/c-arrays.html)\n\n数组定义方式\n\n```c\n// 大小固定为 10\ndouble balance[10];\n// 大小为 {} 数据的个数\ndouble balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};\n```\n和其他语言是有些区别的，比如 java 中 `int[] array` （因此，便有了定义数组时兼容 C 语言定义数组的说法）。\n\n\n### 指针\n\n[指针](https://www.runoob.com/cprogramming/c-pointers.html)\n\n- 指针的定义\n\n```c\nint    *ip;    /* 一个整型的指针 */\ndouble *dp;    /* 一个 double 型的指针 */\nfloat  *fp;    /* 一个浮点型的指针 */\nchar   *ch;     /* 一个字符型的指针 */\n```\n\n所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。\n\n不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。\n\n### 函数指针\n\n[函数指针](https://www.runoob.com/cprogramming/c-fun-pointer-callback.html)\n\n### 字符串\n\n[字符串](https://www.runoob.com/cprogramming/c-strings.html)\n\n### 结构体\n\n[结构体](https://www.runoob.com/cprogramming/c-structures.html)\n\n结构体类似于 Java 中的类，自定义一个包含不同数据类型的模块。\n\n```c\nstruct Books\n{\n   char  title[50];\n   char  author[50];\n   char  subject[100];\n   int   book_id;\n} book  = {\"C 语言\", \"RUNOOB\", \"编程语言\", 123456};;\n```\n比如这里的 Books 结构体，之后就可以用这个 Books 定义变量了。当然，定义变量的形式是多种多样的。\n- 结构体可以是函数参数\n- 也可以定义结构体指针\n- 可以嵌套定义\n\n使用时 `books.title`,`books.author` 。使用 . 操作符即可。\n\n### typedef\n\n[typedef](https://www.runoob.com/cprogramming/c-typedef.html)\n\n- C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字\n\n#### typedef vs #define\n\n#define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同：\n\n- typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。\n- typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。\n\n\n## 实用 \n\n### 输入、输出\n\n[输入/输出](https://www.runoob.com/cprogramming/c-input-output.html)\n\nC 语言提供了许多内置的函数用于处理各种不同场景的输入输出。\n\n[文件读写](https://www.runoob.com/cprogramming/c-file-io.html)\n\n### C 预处理器\n\n[预处理器](https://www.runoob.com/cprogramming/c-preprocessors.html)\n\n简单来说，预处理器完成了文本替换的工作，提高的代码的复用性。\n\n### 头文件\n\n[头文件](https://www.runoob.com/cprogramming/c-header-files.html)\n\n### 内存管理\n\n[内存管理](https://www.runoob.com/cprogramming/c-memory-management.html)\n\n","tags":["C/C++"]},{"title":"Android App 包体积变化史（二）","url":"%2F2020%2F06%2F20%2FAndroid-App-%E5%8C%85%E4%BD%93%E7%A7%AF%E5%8F%98%E5%8C%96%E5%8F%B2%EF%BC%88%E4%BA%8C%EF%BC%89%2F","content":"\n<img src=\"Android-App-包体积变化史（二）/android.jpeg\" width=40%/>\n\n## 前言\n\n承接上篇 [Android App 包体积变化史](https://rebooters.github.io/2020/05/06/Android-App-%E5%8C%85%E4%BD%93%E7%A7%AF%E5%8F%98%E5%8C%96%E5%8F%B2/) ，继续对 Apk 文件的大小进行压缩。\n\n<!--more-->\n\n## 意外收获\n\n在之前 [Android App 包体积变化史](https://rebooters.github.io/2020/05/06/Android-App-%E5%8C%85%E4%BD%93%E7%A7%AF%E5%8F%98%E5%8C%96%E5%8F%B2/) 的最后，我们通过一些非常非常基础的配置，把一个 Hello World 版本的 Demo 工程打包出的 release Apk 文件由 2MB 压缩到了 865kb。\n\n由于工作时间的关系就没有继续跟进。在这期间，Android Studio 4.0 正式版发布了，随之最重要的两个改变就是\n\n- Gradle Android 插件的版本升级到了 4.0.0。\n- Gradle 本地包装器的版本升级到了 6.1.1。\n\n当然，Android Studio 4.0 更新的一些特性已有相关介绍，详细大家都看过这篇 [Android Studio 4.0 稳定版发布了](https://juejin.im/post/5ed0677ee51d45788619c3a7)。\n\n这两天把之前用来测试的项目重新在 Android 4.0 打开后，按照提示自动升级了上面提到的两个版本号，想着继续优化包体积，结果当打出 release apk 文件的时候，忽然有了意外收获。\n\n<img src=\"Android-App-包体积变化史（二）/as4.0.png\"/>\n\n居然只有 701kb 了。\n\n<img src=\"Android-App-包体积变化史（二）/wocao3.jpg\" />\n\n这是发生了什么，难道哪天晚上在梦中做了优化自己忘了吗？赶紧回滚到升级 gradle 插件之前的版本打个包试试看。\n\n<img src=\"Android-App-包体积变化史（二）/v1.0.3.jpg\" />\n\n还是 865 kb 啊。发生了什么，两个文件对比一下。\n\n\n<img src=\"Android-App-包体积变化史（二）/bug.png\" />\n\n\nAndroid 自带的 apk 比较工具有 bug 啊，😭😭。\n\n不过不要紧，我们直接肉眼对比两张图，大概可以看出来，是编译后的 kotlin 文件夹变小了，从 103kb 直接减少到了 9.7kb,事实的确如此吗？是不是其他配置暗度陈仓产生的效果？\n\n为了保险，反手就用 Android Studio 新建了一个一模一样的 Hello World，用同一个 key 打包。\n\n\n<img src=\"Android-App-包体积变化史（二）/new-r.png\" />\n\nkotlin 文件夹只有 9.7KB 了。整个 apk 文件也只有 1.9MB 而已，再顺手跑个 debug 的包看看。\n\n<img src=\"Android-App-包体积变化史（二）/new-d.png\" />\n\n可以翻回去看看在 [Android App 包体积变化史](https://rebooters.github.io/2020/05/06/Android-App-%E5%8C%85%E4%BD%93%E7%A7%AF%E5%8F%98%E5%8C%96%E5%8F%B2/) 的时候，kotlin 文件夹的大小怎么着也有 103kb 啊。这不是意外收获还能是啥？ \n\n<img src=\"Android-App-包体积变化史（二）/wocao.jpeg\" width=60%s />\n\n至此，可以得出结论，在 Android Studio 4.0 版本中。\n\n- Gradle Android 插件的版本升级到 4.0.0。\n- Gradle 本地包装器的版本升级到 6.1.1。\n\n会对包体积有明显的增益。\n\n\nGoogle Android 团队牛逼 😏😏，Kotlin 牛逼。\n\n一些说明： \n\n- **期间 kotlin 插件版本版本没有变化，一直都是 1.3.72**\n- **从图中可以看到 classes.dex 文件由稍微的增长，是因为 core-ktx 的版本由 1.2.0 升级到了 1.3.0**\n\n## 资源压缩\n\n回到正题，尝完了意外收获，是不是得一鼓作气想想还能干点啥，把包体积再压一压？看看现状\n\nGithub [MinApp-V2.0.0](https://github.com/REBOOTERS/MinApp/tree/v2.0.0)\n\n<img src=\"Android-App-包体积变化史（二）/as4.0.png\"/>\n\n由于是 Hello World 版本，没有什么具体业务，classes.dex 已经做了混淆，暂时也想不出还有什么可做的了。\n\n代码可以混淆，那么资源可以混淆吗？当然是可以的，已经有大佬在领先我们很久之前就想到了这个问题，甚至已经把这个问题解决了,这就是非常有名的 [AndResGuard](https://github.com/shwenzhang/AndResGuard)。\n\n按照他的说明文件，简单进行一下配置（由于是 Demo 工程，没有地方库相关配置，按照配置模板直接进行即可），执行 `resguardRelease` 命令打出 final.apk 文件。\n\n\n<img src=\"Android-App-包体积变化史（二）/final.png\"/>\n\n可以看到已经减小到了 610 kb，出不多又压缩了 90 kb。这样的压缩比纯粹通过其他方式还是比较费劲和耗费人力的。因此，无论是对代码，还是资源，通过混淆的策略进行压缩是一件性价比非常高的事情。\n\n## 总结\n\n610 kb 是极限吗？显然不是。 这里仍然有压缩的空间，只是压缩到这种程度我们就需要考虑投入产出比这件事情了。\n\n一个 Apk 文件从真实的场景出发，是包含着所有业务逻辑和 UI 展现效果的集合包。Apk 文件越小，新用户越容易获取到。其实，除了一味地使用技术手段压缩，我们还可以从业务角度出发，针对不同的区域及受众做不到的定制，而不是一股脑的把所有要做的东西塞在一起，然后想着怎么做减法，这样势必会变成一个零和游戏，因为需求不止，需求的变化不止。\n\n但同时从意外收获也可以看到，很多时候官方发力做某些事情的时候，会比我们开发者自己做更有效率，之前使用 kotlin 导致包体积变大的时候，甚至讨论过要不要回到 java。但是，一旦 Android 官方听到广大开发者对于 kotlin 编译产物增大包体积的抱怨，并且开始亲自动手的话，效率是可是非常喜人的。\n\n最后，包体积优化任重道远，路漫漫其悠远兮。\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Android"]},{"title":"Excel 转 Json","url":"%2F2020%2F06%2F09%2FExcel-%E8%BD%AC-Json%2F","content":"\n<img src=\"Excel-转-Json/excel_header.jpg\" width=40%/>\n\n## 前言\n\n用 Python 读取  Excel 文件并转换为 Json 的实现\n\n<!--more-->\n\n最近由于一些日常的事情，需要对 Excel 里提供的数据进行分类或排序等相关操作。虽然用 Excel 软件做这些工作完全没有问题，但是处理的数据还是在 Excel 表格里，并没有办法直接使用，还是习惯直接处理 Json 格式的数据。Excel 本身有类似 ExcelToJson 的插件，但使用这样的插件有一些缺点。\n\n- 需要联网\n- 需要打开 Excel 软件\n\n为了方便，这里通过万能的胶水语言 Python 尝试一下。\n\n## 使用 xlrd 库\n\n```shell\npip install xlrd\n```\n\n### xlrl 简单了解\n\n总的来说 xlrd 的 api 取名是非常人性化的，基本上看到方法名字你就知道用来干什么了。\n\n比如 \n\n - `xl_workbook = xlrd.open_workbook(path)`\n    - 按文件路径读文件并返回一个对象 \n - `xl_workbook.sheet_names()`\n    - 返回一个 excel 文件中所有的表名，就是底部的 Sheet1，这个其实很有用，这个干啥用呢？看下面\n - `xl_workbook.sheet_by_name(sheet_names[0])`\n    - 通过表名返回一个表\n\n 当然，如果你的 excel 文件很简单，只有一张表，那么也可以通过 `xl_workbook.sheet_by_index(0)` 这样简单的方式，直接用下标索引按顺序访问表。\n\n为了方便，后面以下图中这张表为例\n\n<img src=\"Excel-转-Json/excel_sheet.jpg\">\n\n对于一张普通的表来说，第一行特别重要，因为他记录了这张表要统计哪些具体的信息，相当于是一个对象的属性。当然，在某些情况下，不一定是表的第一行，但一定是某个固定的行。\n\n### 获取表的关键属性\n\n```python\n    row = xl_sheet.row(0)  # 1st row\n    keys = []  # sheet prop\n\n    for idx, cell_obj in enumerate(row):\n        cell_type_str = ctype_text.get(cell_obj.ctype, 'unknown type')\n        print('(%s) %s %s' % (idx, cell_type_str, cell_obj.value))\n        keys.append(cell_obj.value)\n    print(keys)\n```\noutput\n```shell\n(0) text Company\n(1) text Address 1\n(2) text City\n(3) text State\n['Company', 'Address 1', 'City', 'State']\n```\n可以看到我们可以获取表格中每一列的内容的值和他的属性。\n\n**这里的属性其实非常有用，由于上述表格非常简单，每一列都只是简单的文字描述，因此都是 text。如果你的表格设计的比较高端，比如这里是一个 excel 的选择器，那么就可以做更多的事情了。**\n\n### 按行读取文件\n\n其实，上图中的表就是一个 list ，每一个相当于是一个对象或者说是字典，因此我们要做的就是按行访问表，并按照每一行进行赋值即可\n\n```python\n    results = []\n    num_cols = xl_sheet.ncols  # 表格的列数\n    for row_idx in range(1, xl_sheet.nrows):  # 对表格的行数循环\n        result = {}\n        for col_idx in range(0, num_cols):  # Iterate through columns\n            cell_obj = xl_sheet.cell(row_idx, col_idx)  # Get cell object by row, col\n            result[keys[col_idx]] = cell_obj.value\n        results.append(result)\n    print(json.dumps(results, ensure_ascii=False))\n```\n\n由于第0行是属性，因此直接从第一行开始遍历，用属性构造字典对象并添加到数组中，最后使用 json 库进行一个转换即可。\n\n## 总结\n\n用 Python 进行数据处理果然方便，同样的功能用其他语言，可能需要多的代码，但是 Python 却可以非常快速的完成。\n\n\n\n","tags":["Python"]},{"title":"Git 非常规操作","url":"%2F2020%2F06%2F04%2FGit-%E9%9D%9E%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C%2F","content":"\n<img src=\"Git-非常规操作/git_header.jpg\" />\n\n## 前言 \n\n记录使用 Git 时一些不常用，但是很值得了解的命令\n\n<!--more-->\n\n为了数据的多样性和丰富度，这里以滴滴开源的 [DoraemonKit](git@github.com:didi/DoraemonKit.git)<sup>[1]</sup>  Github 开源库作为进行 git 相关操作演示的仓库 。\n\n<!-- TOC -->\n\n- [前言](#前言)\n- [Q & A](#q--a)\n- [参考文档](#参考文档)\n\n<!-- /TOC -->\n\n## Q & A\n\n - 某个 git 仓库有哪些人做过 commit \n\n ```shell\n git shortlog -sn\n ```\n\n ```shell\n skye@Engineer MINGW64 /d/workspace/DoraemonKit (master)\n$ git shortlog -sn\n   377  yixiangboy\n   262  jackjintai\n   228  yixiang\n    42  wanglikun7342\n    41  ydlsl\n    26  LY\n    25  zhuzhiyong\n    ...\n ```\n 可以看到通过 `git shortlog -sn` 可以显示当前仓库的所有提交者，并且会按提交 commit 的数量进行降序排列。（当然，这个 commit 数量并不能说明什么，但是可以简单了解一下这个仓库有哪些人做过贡献）。\n\n [git shortlog](https://git-scm.com/docs/git-shortlog) 简单来说就是对 git log 的内容的总结。git shortlog 会就 git commit 按照提交者的名字及邮箱进行归类。\n\n 除了 -sn 参数外，还有 -e (邮箱相关) 等其他参数可用。\n\n\n - 查看某个文件的提交历史\n\n ```shell\n git log filename\n git show commit-id filename\n ```\n\n - 查看某个文件的某几行代码的提交历史\n\n```shell\ngit blame filename\n```\n会按行显示提交记录\n\n```shell\ngit blame -L startline,endline filename \n```\n特定行数的提交记录\n\n这里以 DoraemonKit 内 CONTRIBUTING.md 为例 \n\n```shell\ngit blame -L 1,20\n```\n\noutput\n\n```shell\nPS D:\\workspace\\DoraemonKit> git blame -L 1,20 .\\CONTRIBUTING.md\n1ae505691 (Tiger Wang 2018-08-27 13:47:08 +0800  1) # Contribution Guideline\n1ae505691 (Tiger Wang 2018-08-27 13:47:08 +0800  2)\n2c9c76304 (Tiger Wang 2018-08-27 13:45:51 +0800  3) Thanks for considering to contribute this project. All issues and pull requests are highly appreciated.\n2c9c76304 (Tiger Wang 2018-08-27 13:45:51 +0800  4)\n1ae505691 (Tiger Wang 2018-08-27 13:47:08 +0800  5) ## Pull Requests\n1ae505691 (Tiger Wang 2018-08-27 13:47:08 +0800  6)\n2c9c76304 (Tiger Wang 2018-08-27 13:45:51 +0800  7) Before sending pull request to this project, please read and follow guidelines below.\n2c9c76304 (Tiger Wang 2018-08-27 13:45:51 +0800  8)\nb7b0d77a5 (Tiger Wang 2018-08-27 13:47:36 +0800  9) 1. Branch: We only accept pull request on `master` branch.\n1ae505691 (Tiger Wang 2018-08-27 13:47:08 +0800 10) 2. Coding style: Follow the coding style used in DoraemonKit.\n1ae505691 (Tiger Wang 2018-08-27 13:47:08 +0800 11) 3. Commit message: Use English and be aware of your spell.\n1ae505691 (Tiger Wang 2018-08-27 13:47:08 +0800 12) 4. Test: Make sure to test your code.\n1ae505691 (Tiger Wang 2018-08-27 13:47:08 +0800 13)\n2c9c76304 (Tiger Wang 2018-08-27 13:45:51 +0800 14) Add device mode, API version, related log, screenshots and other related information in your pull request if possible.\n2c9c76304 (Tiger Wang 2018-08-27 13:45:51 +0800 15)\n1c8c215ee (Tiger Wang 2018-08-27 14:21:50 +0800 16) NOTE: We assume all your contribution can be licensed under the [Apache License 2.0](https://github.com/didi/DoraemonKit/blob/master/LICENSE).\n1ae505691 (Tiger Wang 2018-08-27 13:47:08 +0800 17)\n1ae505691 (Tiger Wang 2018-08-27 13:47:08 +0800 18) ## Issues\n2c9c76304 (Tiger Wang 2018-08-27 13:45:51 +0800 19)\n2c9c76304 (Tiger Wang 2018-08-27 13:45:51 +0800 20) We love clearly described issues. :)\nPS D:\\workspace\\DoraemonKit>\n```\n可以这个文件的按照行数列出了所有的记录。\n\n之后通过 `git show commit-id` 就可以查看详细的提交记录了。\n\n- 恢复已经被 reset 或删除的 commit 记录\n\n```shell\ngit reflog\n```\ngit reflog 很多时候都是 git 误操作的后悔药。 \n\n- 不小心删除的 commit 记录，\n- merge 代码时误操作干掉的 commit ，\n- git reset --hard 之后又想找回来的提交记录，\n- 被删除的分支找不到 commit-id 了，无法恢复时\n\n统统可以通过 git reflog 找回来。\n\n**git reflog 显示的内容本质上是 git commit 的在本地的所有操作记录。因此，并不能百分之百保证所有提交记录可以被恢复，因此 git 有定期进行 commit 自动清理的策略**\n\n因此，不能过度依赖 git reflog， 对仓库进行随意的操作。\n\n\n\n## 参考文档\n\n1. [DoraemonKit](git@github.com:didi/DoraemonKit.git)\n2. [Git 官方文档](https://git-scm.com/docs)","tags":["Git"]},{"title":"Android App 包体积变化史","url":"%2F2020%2F05%2F06%2FAndroid-App-%E5%8C%85%E4%BD%93%E7%A7%AF%E5%8F%98%E5%8C%96%E5%8F%B2%2F","content":"\n<img src=\"Android-App-包体积变化史/android.jpeg\" width=40%/>\n\n## 前言\n\n探索如何压缩一个 Android App 的包体积\n\n<!--more-->\n\n## Hello World \n\n#### 原始配置\n\n首先是创建一个 Hello World App，只有一个 Activity 的 App 有多大。\n\n创建 [v1.0.1](https://github.com/REBOOTERS/MinApp/tree/v1.0.1) 的一个 Hello World App。没有多余的配置，只有 release 的 key 。\n\n<details>\n<summary>build.gradle 配置细节 </summary>\n\n```gradle\napply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion 29\n    buildToolsVersion \"29.0.3\"\n\n    defaultConfig {\n        applicationId \"com.engineer.android.mini\"\n        minSdkVersion 21\n        targetSdkVersion 29\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    signingConfigs {\n        release {\n            keyAlias MYAPP_RELEASE_KEY_ALIAS\n            keyPassword MYAPP_RELEASE_KEY_PASSWORD\n            storeFile file(MYAPP_RELEASE_STORE_FILE)\n            storePassword MYAPP_RELEASE_STORE_PASSWORD\n        }\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n            signingConfig signingConfigs.release\n        }\n    }\n\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\n    implementation 'androidx.appcompat:appcompat:1.1.0'\n    implementation 'androidx.core:core-ktx:1.2.0'\n    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n}\n\n```\n\n</details>\n\n分别打出 debug 和 release 包。\n\n - debug\n\n ```shell\n Mode                LastWriteTime         Length Name\n----                -------------         ------ ----\n-a----         2020/5/6     21:12        2506450 app-debug.apk\n-a----         2020/5/6     21:12            239 output.json\n ```\n\n - release \n\n ```\n Mode                LastWriteTime         Length Name\n----                -------------         ------ ----\n-a----         2020/5/6     21:08        2117330 app-release.apk\n-a----         2020/5/6     21:08            247 output.json\n ```\n\n看一下 release 包的内容\n\n <img src=\"Android-App-包体积变化史/v1.0.0.jpg\" />\n\n可以看到主要还是 classes.dex 和 res 文件夹（资源文件）占用较多。其他如 kotlin 、META-INF 均为中间生成的文件，无法**简单**的进行优化。再有 AndroidManifest 文件更是无从优化。下面就从最容易上手的步骤开始逐步优化。\n\n首先是进行代码混淆和资源的压缩。\n\n #### 配置混淆、资源压缩等\n\n ```gradle\n     buildTypes {\n        release {\n            //混淆\n            minifyEnabled true\n            //所以尽可能的减少第三方的使用 也是可以降低混淆的难度\n            //Zipalign优化\n            zipAlignEnabled true\n            // 移除无用的resource文件\n            shrinkResources  true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n            signingConfig signingConfigs.release\n        }\n    }\n ```\n 完成上述配置后再次打 release 包\n\n```shell\nMode                LastWriteTime         Length Name\n----                -------------         ------ ----\n-a----         2020/5/6     22:25        1135908 app-release.apk\n-a----         2020/5/6     22:25            247 output.json\n```\n\n\n看一下 release 包的内容\n\n <img src=\"Android-App-包体积变化史/v1.0.2.jpg\" />\n\n 对比之前的截图，可以看到经过混淆的处理，classes.dex 整体压缩比非常高，从 1.3 MB 讲到了 332 kb。但是 res 文件夹内的资源文件并没有显著的效果，下面看看这部分是否有压缩空间。\n\n代码 [v1.0.3](https://github.com/REBOOTERS/MinApp/tree/v1.0.3)\n\n为了方便后面的分析，这里了解一下 Apk 包中各类文件的用处。\n\n### Apk 包分析\n\n我们都知道，Android 项目最终会编译成一个 .apk 后缀的文件，实际上它就是一个压缩包，和我们常接触的xxx.zip 以及 xxx.rar 本质上没有区别。因此，它内部还有很多不同类型的文件，这些文件，按照大小，共分为如下四类：\n\n1. 代码相关：classes.dex，我们在项目中所编写的 java 文件，经过编译之后会生成一个 .class 文件，而这些所有的 .class 文件呢，它最终会经过 dx 工具编译生成一个 classes.dex。\n\n2. 资源相关：res、assets、编译后的二进制资源文件 resources.arsc 和 清单文件 等等。res 和 assets 的不同在于 res 目录下的文件会在 .R 文件中生成对应的资源 ID，而 assets 不会自动生成对应的 ID，而是通过 AssetManager 类的接口来获取。此外，每当在 res 文件夹下放一个文件时，aapt 就会自动生成对应的 id 并保存在 .R 文件中，但 .R 文件仅仅只是保证编译程序不会报错，实际上在应用运行时，系统会根据 ID 寻找对应的资源路径，而 resources.arsc 文件就是用来记录这些 ID 和 资源文件位置对应关系 的文件。\n\n3. So 相关：lib 目录下的文件，这块文件的优化空间其实非常大。\n\n4. 还有 META-INF，它存放了应用的 签名信息，其中主要有 3个文件，如下所示\n\n   - MANIFEST.MF：其中每一个资源文件都有一个对应的 SHA-256-Digest（SHA1) 签名，MANIFEST.MF 文件的 SHA256（SHA1） 经过 base64 编码的结果即为 CERT.SF 中的 SHA256（SHA1）-Digest-Manifest 值。\n\n   - CERT.SF：除了开头处定义的 SHA256（SHA1）-Digest-Manifest 值，后面几项的值是对 MANIFEST.MF 文件中的每项再次 SHA256（SHA1） 经过 base64 编码后的值。\n\n   - CERT.RSA：其中包含了公钥、加密算法等信息。首先，对前一步生成的 CERT.SF 使用了 SHA256（SHA1）生成了数字摘要并使用了 RSA 加密，接着，利用了开发者私钥进行签名。然后，在安装时使用公钥解密。最后，将其与未加密的摘要信息（MANIFEST.MF文件）进行对比，如果相符，则表明内容没有被修改。\n\n再回过头看一下 release 刚才生成的包内资源相关的详细内容。\n\n<img src=\"Android-App-包体积变化史/v1.0.2_arsc.jpg\" />\n\n<br/>\n\n<img src=\"Android-App-包体积变化史/v1.0.2_res.jpg\" />\n\nres 内为了适配各类设备，包含各种类型的资源，比如 xxxh，xxh, v17,v4,v20 甚至是 watch 的适配。还会包含多语言的一些资源，大部分情况下，是不需要这么繁杂的适配的。因此，可以做如下配置 \n\n```gradle\nandroid {\n   ...else...\n\n    defaultConfig {\n         ...else...\n\n        resConfigs \"zh-rCN\",\"xxhdpi\"\n    }\n}\n```\n这样只会保留中文资源和 xxhdpi 的资源，当然，如果某个资源只在 xxxhdpi 下存在的话，那么也会智能的进行保留。\n\n完成上述配置后，再次进行打包。\n\n```shell\nMode                LastWriteTime         Length Name\n----                -------------         ------ ----\n-a----         2020/5/7     21:31         885611 app-release.apk\n-a----         2020/5/7     21:31            247 output.json\n```\n\n<img src=\"Android-App-包体积变化史/v1.0.3.jpg\" />\n\n可以看到 apk 的大小已经来到了 1 MB之内，只有 865 kb 了。[关于 APK Size 和 Download Size 的区别,可以点击链接了解一下](https://stackoverflow.com/questions/45024723/android-apk-raw-file-size-vs-download-size-how-to-shrink-the-raw-file-size)。总的来说，对国内用户似乎没有什么差异。\n\n通过配置去除国家化和单一分辨率，res 减少了 33%，同时使的 resources.arsc 文件减小了将近一半的大小。\n\n## 小结\n\n至此，已经完成了一个基础项目的最小化的常规操作。865 kb 是最小值了吗？其实不然，res 文件夹下仍有可以优化的空间，同时可以通过自定义打包流程，用自己的算法压缩 apk ,或者用第三方工具对 dex 文件进行更精细化的处理。\n\n**其实，控制包体积是一个长期的任务，因为随着业务代码的增加，包体积一定会一天天的增长，因此需要在版本迭代的过程中不断就引入的资源、三方库和自己写的代码，进行分析、规划和记录，在恰当的时候删除冗余的代码和资源，同时也要有节制的进行代码的添加（这里主要还是三方库的引入和资源文件的添加）**\n\n\n## 参考文档\n\n[深入探索 Android 包体积优化（匠心制作）](https://juejin.im/post/5e7ad1c0e51d450edc0cf053)","tags":["Android"]},{"title":"好看的视频","url":"%2F2020%2F05%2F05%2F%E7%8E%8B%E7%89%8C%E5%AF%B9%E7%8E%8B%E7%89%8C%2F","content":"\n\n## 综艺视频\n\n<!--more-->\n\n ### 测试一下\n\n\n- 极乐尽土\n\n<iframe src=\"//player.bilibili.com/player.html?aid=47328330&bvid=BV1fb41147nR&cid=82888432&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>","tags":["综艺"]},{"title":"Dart Learning Notes","url":"%2F2020%2F05%2F03%2FDart-Learning-Notes%2F","content":"\n## 前言\n\nDart 学习笔记\n\n<!--more-->\n\n## 内容\n\n```dart\n// 定义一个函数\nprintInteger(int aNumber) {\n  print('The number is $aNumber.'); // 打印到控制台。\n}\n\n// 应用从这里开始执行。\nmain() {\n  var number = 42; // 声明并初始化一个变量。\n  printInteger(number); // 调用函数。\n}\n```\n\n### 重要概念\n\n[重要的概念](https://www.dartcn.com/guides/language/language-tour)\n\n- 任何保存在变量中的都是一个 对象 ， 并且所有的对象都是对应一个 类 的实例。 无论是数字，函数和 null 都是对象。所有对象继承自 Object 类。\n\n- 尽管 Dart 是强类型的，但是 Dart 可以推断类型，所以类型注释是可选的。 在上面的代码中， number 被推断为 int 类型。 如果要明确说明不需要任何类型， 需要使用特殊类型 dynamic 。\n\n- Dart 支持泛型，如 List <int> （整数列表）或 List <dynamic> （任何类型的对象列表）。\n\n- Dart 支持顶级函数（例如 main（） ）， 同样函数绑定在类或对象上（分别是 静态函数 和 实例函数 ）。 以及支持函数内创建函数 （ 嵌套 或 局部函数 ） \n\n- 类似地， Dart 支持顶级 变量 ， 同样变量绑定在类或对象上（静态变量和实例变量）。 实例变量有时称为字段或属性。\n\n- 与 Java 不同，Dart 没有关键字 “public” ， “protected” 和 “private” 。 如果标识符以下划线（_）开头，则它相对于库是私有的。 有关更多信息，参考 库和可见性。\n\n- 标识符 以字母或下划线（_）开头，后跟任意字母和数字组合。\n\n- Dart 语法中包含 表达式（ expressions ）（有运行时值）和 语句（ statements ）（没有运行时值）。 例如，条件表达式 condition ? expr1 : expr2 的值可能是 expr1 或 expr2 。 将其与 if-else 语句 相比较，if-else 语句没有值。 一条语句通常包含一个或多个表达式，相反表达式不能直接包含语句。\n\n- Dart 工具提示两种类型问题：警告_和_错误。 警告只是表明代码可能无法正常工作，但不会阻止程序的执行。 错误可能是编译时错误或者运行时错误。 编译时错误会阻止代码的执行; 运行时错误会导致代码在执行过程中引发 [异常]（#exception）。\n\n### 关键字\n\nDart 关键字较多，和其他语言有些区别，比如 dynamic ,show 也是他的关键字，[更多参考](https://www.dartcn.com/guides/language/language-tour#%E5%85%B3%E9%94%AE%E5%AD%97)\n\n### 内建类型\n\n[内建类型](https://www.dartcn.com/guides/language/language-tour#%E5%86%85%E5%BB%BA%E7%B1%BB%E5%9E%8B)\n\n## 总结 \n\nDart 集合了很多语言的特点,和 Java 基本相同。但又比 Java 更加的方便些，有类似 Python 的方法参数和位置参数（是在学习 Python 的时候第一次了解到这种 feature),也有类似 Js 实现异步操作的 asnyc/await 等语法。\n\n## 快捷链接\n\n[Dart 中文学习网](https://www.dartcn.com/)\n\n[Dart 语法快速了解](https://www.dartcn.com/guides/language/language-tour)\n\n[Dart 常用库 core/asnyc/math/convert 指南](https://www.dartcn.com/guides/libraries/library-tour) \n\n","tags":["flutter"]},{"title":"Android IPC","url":"%2F2020%2F03%2F31%2FAndroid-IPC%2F","content":"\n\n## 前言\n\nAndroid IPC （Inter-Process Communication） 进程间通信或跨进程通信。\n\n主要是 Binder 、AIDL 及 Android 跨进程通信的实现方式及原理简单梳理。\n\n<!--more-->\n\n## Android 中如何实现多进程。\n\n通过给四大组件 （Activity、Service、Broadcast Receiver、ContentProvider ）在 AndroidManifest.xml \n文件中指定 ```android:process``` 属性即可。\n\n当然，除了自身实现多进程之外，和其他应用通信其实也是在不经意中做了跨进程通信的事情。\n\nService 多进程\n\n```xml\n        <service\n            android:name=\".ipc.messenger.MessengerService\"\n            android:enabled=\"true\"\n            android:process=\":remote\"\n            android:exported=\"false\" />\n```\n\nActivity 多进程\n\n```xml\n        <activity\n            android:name=\".ui.behavior.lifecycle.ActivityB\"\n            android:process=\"com.engineer.android.mini.remote\" />\n        <activity\n            android:name=\".ui.behavior.lifecycle.ActivityC\"\n            android:process=\":remote\" />\n```\n\n以上两种 process 属性的实现下，\n- ActivityB 的进程名即为: com.engineer.android.mini.remote， 同时此类进程属于全局进程，其他应用通过 ShareUID 的方式可以和他运行在同一个进程中。\n- ActivityC 的进程名为：{pacakage}:remote，同时此类进程属于当前应用的私有进程。\n\n## Android 跨进程的几种方式\n\n### Bundle \n\nActivity/Service/Receiver 都可以通过 Intent 传递数据，同时 Intent.putExtras(Bundle bundle) 方法支持传递 Bundle，通过 Bundle 我们可以封装细碎的数据，比如基本类似，实现了 Parcelable 接口的对象和 Android 支持的一些特殊的对象。\n\n### 使用文件共享\n\n并入 A 进程写入，B 进程进行读操作。当然，需要考虑并发读写的问题。SharedPerference 不支持多进程。\n\n### Messenger \n\nMessenger 其实就是对 AIDL 的一层封装，是一种轻量级的 IPC。 \n\n- 创建服务端 Service \n\n```java\npublic class MessengerService extends Service {\n    private static final String TAG = \"MessengerService\";\n\n    public MessengerService() {\n    }\n\n    private final Messenger messenger = MessengerDelegate.provideMessenger();\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        return messenger.getBinder();\n    }\n}\n```\n```xml\n    <service\n        android:name=\".ipc.messenger.MessengerService\"\n        android:enabled=\"true\"\n        android:process=\":remote\"\n        android:exported=\"false\" />\n```\nService 在启动之后，在 onBind 中就可以通过 Messenger 获取到 IBinder 了。\n\n - 客户端启动 Service \n\n ```java\n     private Messenger mRepliedMessenger = MessengerDelegate.provideMessenger();\n\n\n    private ServiceConnection mConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            Messenger messenger = new Messenger(service);\n            Message message = Message.obtain(null, IPCConstants.MESSAGE_FROM_CLIENT);\n            Bundle bundle = new Bundle();\n            bundle.putString(\"msg\", \"this is from client\");\n            message.setData(bundle);\n            message.replyTo = mRepliedMessenger;\n            try {\n                messenger.send(message);\n            } catch (RemoteException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n\n        }\n    };\n\n    // 启动 Service \n\n    Intent intent = new Intent(IpcActivity.this, MessengerService.class);\n    bindService(intent, mConnection, Context.BIND_AUTO_CREATE);   \n ```\n\n在 onServiceConnected 中，通过服务端返回的 IBinder 对象，我们创建了本地的 Messenger 对象。同时创建了一个 Message 通过 Messenger.send(Message) 的方式，将一些数据发送到服务端去。**同时设定 Message 的 replayTo 属性为我们在本地创建的另一个 Messenger；mRepliedMessenger 。下面看看 Messenger 是如何处理消息的。\n\n```java\npublic class MessengerDelegate {\n    private static final String TAG = \"MessengerDelegate\";\n\n    public static Messenger provideMessenger() {\n        return new Messenger(new MessengerHandler(Looper.myLooper()));\n    }\n\n    private static class MessengerHandler extends Handler {\n        public MessengerHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(@NonNull Message msg) {\n            super.handleMessage(msg);\n            switch (msg.what) {\n                case IPCConstants.MESSAGE_FROM_CLIENT:\n                    Bundle data = msg.getData();\n                    String result = data.getString(\"msg\");\n\n                    Log.e(TAG, \"handleMessage: data   = \" + data);\n                    Log.e(TAG, \"handleMessage: result = \" + result);\n\n                    Messenger client = msg.replyTo;\n                    Message reply = Message.obtain(null, IPCConstants.MESSAGE_FROM_SERVER);\n                    Bundle bundle = new Bundle();\n                    bundle.putString(\"reply\", \"server got message, and replied with happy\");\n                    reply.setData(bundle);\n                    try {\n                        client.send(reply);\n                    } catch (RemoteException e) {\n                        e.printStackTrace();\n                    }\n                    break;\n                case IPCConstants.MESSAGE_FROM_SERVER:\n                    Bundle data1 = msg.getData();\n                    String result1 = data1.getString(\"reply\");\n\n                    Log.e(TAG, \"handleMessage: data   = \" + data1);\n                    Log.e(TAG, \"handleMessage: result = \" + result1);\n                    break;\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n    }\n}\n```\n简单总结 ；\n\n1. 服务端收到客户端发送的消息后，通过 message.replyTo 获取到客户端要接收消息的 Messenger 对象。然后从服务端发送了新的消息去往客户端。\n2. 客户端接收消息也是，也是通过本地创建的 Messenger；mRepliedMessenger 的接收信息。\n3. 就服务端和客户端来说，他们本地的 Messenger 对象都是通过 Handler 创建的，客户端在启动服务端之后，为了向服务端发送消息，创建 Messenger 是通过服务端返回的 IBinder 对象实现的。\n\n可以看到 Messenger 主要是串行的在服务端和客户端之间进行消息的传递。\n\n### AIDL \n\n#### 准备\n\n- 创建实现了 Parcelable 接口的类，以便用于在进程间通信\n\n```java\npackage com.engineer.android.mini.ipc.aidl;\n\npublic class Book implements Parcelable {\n\n    public int bookId;\n    public String bookName;\n\n    public Book(int bookId, String bookName) {\n        this.bookId = bookId;\n        this.bookName = bookName;\n    }\n\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeInt(bookId);\n        dest.writeString(bookName);\n    }\n    public static final Parcelable.Creator<Book> CREATOR = new Parcelable.Creator<Book>() {\n\n        @Override\n        public Book createFromParcel(Parcel source) {\n            return new Book(source);\n        }\n\n        @Override\n        public Book[] newArray(int size) {\n            return new Book[size];\n        }\n    };\n\n    private Book(Parcel in) {\n        bookId = in.readInt();\n        bookName = in.readString();\n    }\n}\n```\n\n- 创建 AIDL 接口\n\n```aild\n// Book.aidl\npackage com.engineer.android.mini.ipc.aidl;\nparcelable Book;\n```\n```aidl\n// IBookInterface.aidl\npackage com.engineer.android.mini.ipc.aidl;\nimport com.engineer.android.mini.ipc.aidl.Book;\n\ninterface IBookInterface {\n\n    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,\n            double aDouble, String aString);\n//\n    List<Book> getBookList();\n    void addBook(in Book book);\n}\n```\n\n\n","tags":["Android"]},{"title":"Kotlin 实战读书笔记(三)","url":"%2F2020%2F03%2F26%2FKotlin-%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%89%2F","content":"\n\n<img src=\"Kotlin-实战读书笔记-三/kotlin.jpg\" width=40%>\n\n## 前言\n《 Kotlin 实战 》读书笔记。\n\n<!--more-->\n\n### 第二部分 拥抱 Kotlin\n\n#### 7 运算符重载及其他约定\n\n##### 约定\n\n在 Kotlin 中，某些功能和特定的函数命名相关。比如在类中定义了一个名为 plus 的特殊方法，那么按照**约定**，就可以在该类的实例上使用 +  运算符。\n\n##### 重载算数运算符\n\n```kotlin\ndata class Point(val x: Int, val y: Int) {\n    operator fun plus(other: Point): Point {\n        return Point(x + other.x, y + other.y)\n    }\n\n    /**\n     * 运算符不要求两个数是相同类型，按实际需求出发\n     */\n    operator fun Point.times(scale: Float): Point {\n        return Point((x * scale).toInt(), (y * scale).toInt())\n    }\n}\n\nfun main() {\n    val p1 = Point(1, 2)\n    val p2 = Point(3, 4)\n    println(p1 + p2)\n}\n```\n\n使用 operator 定义特定名称的方法（当然也可以是扩展函数），就可以按照普通的算数运算符使用，比如这里的 plus == + 。具体可以使用的方法名称如下表\n\n|表达式|函数名|\n|---|----|\n|a*b|times|\n|a/b|div|\n|a%b|mod|\n|a+b|plus|\n|a-b|minus|\n\n类似的可以有 minusAssign(重载复合运算符)、一元运算符、比较运算符、排序运算符等。\n\n##### 集合与区间约定\n\n- 下标运算符\n\n```kotlin\n    operator fun Point.get(index:Int) : Int {\n        return when (index) {\n            0 -> x\n            1 -> y\n            else -> throw IndexOutOfBoundsException()\n        }\n    }\n```\n\n也可以自定 **in,rangTo,interator**等。\n\n##### 解构声明和组件函数\n\n- 解构声明\n\n```kotlin\n    val p1 = Point(1, 2)\n    val (x,y) = p1\n    println(x)\n    println(y)\n```\n\n```shell\n1\n2\n```\n\n`val (x,y)` 称为**解构声明**，在初始化括号中的变量时，实际上是在调用名为 componentN 的函数，N为声明中变量的位置。对于数据类 `data class` 编译器为每个在柱构造方法中声明的属性生成了一个 componentN 函数。为了实现同样的功能，你也可以自定义这样的函数。\n其实这个功能类似于 Pair / Triple 类的定义。\n\n##### 委托属性\n\n```kotlin\nclass C {\n    var prop : Type by MyDelegate\n}\n\nval c = C()\n```\n\nMyDelegate 的实例会被保存在一个隐藏的属性中，通过这个隐藏属性的    setValue 和 getValue 实现。\n\n- by lazy \n\n```kotlin\n    val value: Int by lazy {\n         8 * 8\n    }\n```\n\nvalue 只有在被第一次使用的的时候才会完成初始化\n\n\n#### 8 lambda 作为形参和返回值\n\n##### 声明高阶函数\n\n高阶函数：用另一个函数作为参数或返回值的函数，在 Kotlin 中可以使用 lambda 或函数引用来表示。\n\n- 函数类型\n\n变量的类型 \n\n```kotlin\n    val any = Any()\n    val x = 4\n    val X = Integer(4)\n    val sum = { x: Int, y: Int -> x + y }\n    val enter = { println() }\n\n    println(any.javaClass.typeName)\n    println(x.javaClass.typeName)\n    println(X.javaClass.typeName)\n    println(sum.javaClass.typeName)\n    println(enter.javaClass.typeName)\n```\n\noutput\n\n```shell\njava.lang.Object\nint\njava.lang.Integer\ncom.fun.HighOrderFunKt$main$sum$1\ncom.fun.HighOrderFunKt$main$enter$1\n```\n可以看到 lambda 表达式引用的真实类型就是内部声明的lambda 表达式生成的类。\n\n- 声明 lambda 表达式(函数)作为参数的函数\n\n```kotlin\n/**\n * 高阶函数有返回值\n */\nfun highOrderNotNull(x: Int, block: () -> Float): Double {\n    if (x > 0) {\n        return block().toDouble()\n    } else {\n        return 0.0\n    }\n}\n\n/**\n * 高阶函数，无返回值，block 只是完成了一个 功能\n */\nfun highOrder(x: Int, block: () -> Unit) {\n    println(x)\n    block()\n}\n\n/**\n * 高阶函数，无返回值，block接收参数完成功能\n */\nfun highOrderParam(x: Int, y: Int, block: (Int, Int) -> Unit): Int {\n    block(x, y)\n    return x\n}\n\n/**\n * 高阶函数，接收参数，完成特定的 block 并将返回结果作为整个函数的结果返回\n */\nfun highOrderParams(age: Int, name: String, boy: Boolean,\n                    block: (age: Int, name: String, boy: Boolean) -> String): String {\n    return block(age, name, boy)\n}\n\n/**\n * 高阶函数，为 String 定义一个扩展函数，实现 exchange 工，具体实现由 block 提供\n */\nfun String.exchange(block: (String) -> String): String {\n    return block(this)\n}\n```\n\n**在 函数类型 block 变量声明时，其内部的方法参数声明类型即可，不需要名称，因为这个参数实际上是调用方的参数而已。** 但是声明了也有好处，在 IDE 中可以提升代码的可读性。\n\n\n在 Kotlin 中调用\n\n```kotlin \n    val m = highOrderParam(10, 100) { a, b ->\n        run {\n            println(\"a * b is ${a * b}\")\n        }\n    }\n\n    val origin = \"asdfjhjkl\"\n    val upper = origin.exchange {\n        it.toUpperCase()\n    }\n    val number = origin.exchange {\n        it.reversed()\n    }\n    println(upper)\n    println(number)\n```\n\n在 Java 中调用\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n\n        HighOrderFunKt.highOrderParam(1, 2, new Function2<Integer, Integer, Unit>() {\n            @Override\n            public Unit invoke(Integer integer, Integer integer2) {\n                System.out.println(integer);\n                System.out.println(integer2);\n                return Unit.INSTANCE;\n            }\n        });\n\n        HighOrderFunKt.highOrderParams(18, \"mike\", true, new Function3<Integer, String, Boolean, String>() {\n            @Override\n            public String invoke(Integer integer, String s, Boolean aBoolean) {\n                return integer + s + aBoolean;\n            }\n        });\n    }\n}\n```\n\n可以看到实际上**函数类型**被声明为普通的接口，一个函数类型的变量是 FunctionN 接口的一个实例。因此，在 Java 中调用带有函数类型的 Kotlin 方法时，创建 FunctionN 接口的实例即可。但是要注意的是，对于返回类型为 Unit 的方法，要显示的返回 Unit.INSTANCE。\n\n当然，在 Java8 中可以直接使用 lambda，因此以上代码可以简化为 \n\n```java\npublic class Test {\n    public static void main(String[] args) {\n\n        HighOrderFunKt.highOrderParam(1, 2, (integer, integer2) -> {\n            System.out.println(integer);\n            System.out.println(integer2);\n            return Unit.INSTANCE;\n        });\n\n        HighOrderFunKt.highOrderParams(18, \"mike\", true,\n                (integer, s, aBoolean) -> integer + s + aBoolean);\n    }\n}\n```\n\n当然，函数类型的参数也可以有默认值，这和普通函数的定义是一样的。同时可以就是否为null进行定义，也可以就函数类型本身是否可以为null 进行定义。\n\n```kotlin\nfun highOrderWithDefault(x: Int = 0, block: (Int) -> Unit) {\n    block(x)\n}\n\nfun highOrderWithNullParam(input: String? = null, block: (String?) -> Unit) {\n    // 函数类型的参数可空，调用时需要注意\n    block(input)\n}\n\nfun highOrderWithNull(input: String, block: () -> String?): String {\n    // 整个函数本身需要返回非空 String，但是由于函数参数返回了可空 String，因此\n    // 这里需要单独处理\n    return block() ?: input\n}\n\n/**\n * 提供了参数类型有默认实现的高阶函数，调用时如果没有提供 lambda，将以默认方式实现\n */\nfun highOrderDefault(input: String, block: ((String) -> String) = { \"null\" }): String {\n    return block.invoke(input)\n}\n\n/**\n * 提供了参数类型可空的高阶函数，调用时如果提供了空 ，用默认实现\n */\nfun highOrderNull(input: String, block: ((String) -> String)? = {\"null\"}): String {\n    return block?.invoke(input) ?: \"null\"\n}\n\nfun useHighOrder() {\n    highOrderWithDefault {\n        // 调用含有默认参数的，不用传参\n        println(it)\n    }\n    highOrderWithNullParam(\"a\") {\n        // 参数可空，需要判空\n        it?.apply { }\n    }\n\n    // lambda 的返回值，可为null，需要显示写明\n    highOrderWithNull(\"a\") {\n        null\n    }\n\n    highOrderDefault(\"a\") {\n        // 函数参数不可空时，默认实现似乎有问题\n        \"\"\n    }\n\n    highOrderNull(\"a\")\n}\n```\n\n- 声明 lambda 表达式(函数)作为返回值的函数\n\n这个功能感觉有点炫技，相同的功能完全可以用正常的代码实现。这里简单举例。\n\n```kotlin\n/**\n * 摄氏与华氏 计算公式\n *\n * 华氏度 = 32+ 摄氏度 × 1.8\n * 摄氏度 = (华氏度 - 32) ÷ 1.8\n */\nfun highOrderReturnFun(type: String): (Int) -> Float {\n    val base = 32\n    val factor = 1.8f\n    when (type) {\n        \"F\" -> return { input -> base + input * factor }\n        \"C\" -> return { input -> (input - base) / factor }\n        else -> return { input -> base + input * factor }\n    }\n}\n\n// invoke \n\n    var calc = highOrderReturnFun(\"F\")\n    println(\"38 ℃ ≈ ${calc(38)}\")\n    calc = highOrderReturnFun(\"C\")\n    println(\"100 ℉ ≈ ${calc(100)}\")\n\n```\noutput\n\n```shell\n38 ℃ ≈ 100.4\n100 ℉ ≈ 37.77778\n```\n\n这里定义了一个函数，根据highOrderReturnFun函数的参数，分别返回了不同的函数。坦白说，相同的功能完全可以用有阅读性的代码实现。所以，返回函数的函数，个人感觉很鸡肋。如果要用或阅读到了此类函数，两个关键点\n\n    - 函数返回值，即冒号后面，是一个 lambda 表达式\n    - 函数 return 结果必然在一个大括号里，因为要返回一个 lambda 表达式。\n\n\n##### 内联函数\n\n**lambda 表达式会被正常的编译成匿名类。因此，每调用一次lambda表达式，一个额外的类会被创建。并且如果lambda表达式捕获了某个变量，每次调用还会创建一个新的变量。** 这会带来额外的性能消耗。\n\n可以使用 inline 修饰函数，实现 lambda 表达式被内联的效果，但是其实是有限制的。比如以函数作为参数的时候，内联效果并不是完整的，同时有变量捕获的情况时，也是无法使用的。\n\n#### 9 泛型\n\nKotlin 泛型的大部分使用规则和 Java 是类似的。同时提供了更多增强性的功能。\n\n泛型允许我们定义带**类型形参**的类型。\n\n```kotlin\nfun <T> List<T>.slice(indices: IntRange): List<T>\n```\nT 就是类型形参，T 的默认类型是 Any?。 及可空的任意类型，这是需要注意的一点。\n\n泛型参数在运行是会被擦除，因此你在一般情况下无论是 Java 还是 Kotlin 中，你无法感知你的列表是一个字符串列表还是一个 People 的列表。\n\n在 Kotlin 中可以使用 inline 函数，声明带**实化类型**参数的函数。\n\n```kotlin\ninline fun <reified T> isA(value:Any) = value is T\n\n    println(isA<String>(\"aaa\"))\n    println(isA<String>(111))\n```\n\nout\n\n```shell\ntrue\nfalse\n```\n可以看到，在运行是我们是可以感知到泛型实际的类型的。\n\n\n用实化类型参数还可以替代类引用\n\n```kotlin\ninline fun <reified T:Activity> Context.startActivity() {\n    val intent = Intent(this, T::class.java)\n    startActivity(intent)\n}\n\n        final_one.setOnClickListener {\n//            startActivity(Intent(context, FinalActivity::class.java))\n            context?.startActivity<FinalActivity>()\n        }\n```\n\n可以看到，使用实化参数之后，FinalActivity 的类型在运行是得以保留，因此可以通过扩展函数获取到他对应的 Java Class 的类型来构建 Intent 。\n\n\n#### 10 注解与反射\n\n##### 注解定义与使用\n\n```kotlin\nannotation class Test(val path: String, val level: Int, val since: SinceKotlin)\n```\n\n在 kotlin 中定义注解。比 Java 中要简介一些。val 比不可少，同时也可以在注解中使用其注解比如这里的 SinceKotlin 作为参数）\n\n```kotlin\n    @Test(\"/user/fly/documents\", level, SinceKotlin(\"1.3.0\"))\n    val dir = \"home\"\n```\n这里需要注意的是，注解参数的值是编译期决定的，因此在使用时，要么直接使用字面量，要么比如使用 const val 定义的值，val 也不行，比如这里的 level 必须在类的最外层定义\n` const val level = 100` ,要么直接使用 100。\n\n在 Kotlin 中可以直接在表达式上面使用注解，比如@Suppress 这种，范围就可以进一步的缩小，不必为此单独写一个方法。同时 Kotlin 中注解默认的 @Retention 是 Runtime ，而在 Java 中则是 Class。\n\n更多细节可以参考 JKid 这个 Kotlin 实现的 JSON 序列化和反序列化的库。\n\n\n##### 反射\n\n在 Kotlin 中使用反射，可以用两种 API \n\n- java.lang.reflect 中 java 的 API（因为 kotlin 代码只是编译成了普通的 Java 字节码，这个是完全兼容的）\n- kotlin.reflect 中 kotlin 的 API 。**有意思的是，使用这个库的 API 做反射，并不限定有 kotlin 类，可以访问任何 JVM 语言写成的类。**\n\n在 Android 中，kotlin 反射的库并没有被默认依赖，如果需要使用时，要单独添加依赖 `org.jetbrains.kotlin:kotlin-reflect` 。\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"独轮车环游地球","url":"%2F2020%2F03%2F20%2F%E7%8B%AC%E8%BD%AE%E8%BD%A6%E7%8E%AF%E6%B8%B8%E5%9C%B0%E7%90%83%2F","content":"\n<img src=\"独轮车环游地球/1.jpg\" style=\"border-radius:5px\">\n\n\n## 前言\n\n讲述一个年轻人骑行独轮车环游地球的故事。自己平时在周末的时候一般都会出去骑行。尤其是夏天和秋天的时候，当车从下坡路高速行驶的时候，会觉得非常舒服。但是，自己也只是在居住地周边的道路骑行，从没有骑车去过很远的地方，对于这样的行为感到非常好奇和钦佩。\n\n<!--more-->\n\n## 独轮车环游地球\n\n初次看到这条消息是在[阮一峰的科技爱好者周刊：第 97 期](https://github.com/ruanyf/weekly/blob/master/docs/issue-97.md)上。\n\n> 英国青年埃德·普拉特（Ed Pratt）最近成为第一个骑独轮车环游世界的人。2015年3月，当时19岁的他从英国出发，经过3年时间，路经了欧洲、中东、中亚、中国、东南亚、澳大利亚、新西兰和美国之后，他终于回到了起点。\n\n>他的交通工具就是一辆独轮车，为了省力，选择了36英寸（91厘米）的轮胎。 他的所有装备也放在独轮车上（下图），一路上一共换过5次轮胎，平均每个轮胎可以使用8000公里。\n\n我们经常会听到开车自驾环游世界的新闻故事。但是这样一个仅凭骑车而且是独轮车完成这样一个很多人一生都无法企及的成就时，不得好奇他究竟是怎么做到的。在[这个链接](https://www.outsideonline.com/2407533/unicycle-travel-gear)关于这个事情的完整报道，不过是英文的。\n\n### 万一你想独轮车骑行 21000 英里\n\n\n\n\n一路上，普拉特在穿越澳大利亚沙漠时与逆风搏斗，在吉尔吉斯斯坦差点被一辆在冰上旋转的汽车撞到，还在一个藏族新年晚会上，为 Meatloaf 的“ Paradise by the Dashboard Light”表演了卡拉 ok。 他把自己的冒险和不幸记录在他的 YouTube 娱乐系列《世界独轮车之旅》（[World Unicycle Tour](https://www.youtube.com/channel/UCuNy42Y5egf07cSiHbF23wg)）中，并且仍然在播放他在美国各地旅行的新片段。\n\n在出发前，普拉特说他有信心每天骑行40到50英里。 主要的挑战是找到一种方法来携带他所有的装备，并且——他很快发现——更换所有随着时间推移而损坏或磨损的东西。 \n\n他就如何选择 自行车（独轮车）、轮胎、镶框手袋、框架、睡袋、睡垫、帐篷、鞋子、相机、地图 App、充气球、炉子这个12 个必备装备做了分享。\n\n<img src=\"独轮车环游地球/2.jpg\" style=\"border-radius:5px\">\n\n独轮车是相当不稳定的东西，他可能每周至少会摔一两次。\n\n<img src=\"独轮车环游地球/3.jpg\" style=\"border-radius:5px\">\n\n为了把行李架固定在独轮车上。 他的爷爷做了一个铝制框架作为附件，制作了从落地大摆钟到消防车比例模型的所有东西。\n\n<img src=\"独轮车环游地球/4.jpg\" style=\"border-radius:5px\">\n\n\n普拉特说：“我的第一个帐篷，Terra Nova Photon 2，做得不错。 杆子很细，钉子就像牙签一样，但是有这么轻的东西感觉真好。 最终，织物开始破裂，在土耳其，一只狗撕裂了它。 然后它在中国的一个沙丘顶上被风吹翻了，从此就不一样了。 所以一年半后，我买了一顶 MSR Hubba NX 单人帐篷，这顶帐篷支撑着我剩下的旅程。 这是一个很好的帐篷，有着合理的空间。”\n\n\n<img src=\"独轮车环游地球/5.jpg\" style=\"border-radius:5px\">\n\n\n“我不能携带很多额外的东西，因为我想尽可能地保持轻便，但我确实携带了一个小的充气球。 把孩子们带在身边，或者只是向人们展示我从哪里来，我要去哪里，这都是好事，在我不会说这种语言的地方，这很有用。”\n\n\n## 总结\n\n世上无难事，只怕有心人。\n\n\n\n\n\n","tags":["诗与远方"]},{"title":"墙裂推荐纪录片《越南战争》","url":"%2F2020%2F03%2F18%2F%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90%E7%BA%AA%E5%BD%95%E7%89%87%E3%80%8A%E8%B6%8A%E5%8D%97%E6%88%98%E4%BA%89%E3%80%8B%2F","content":"\n\n<img src=\"墙裂推荐纪录片《越南战争》/war.jpg\">\n\n## 前言\n\n这是关于越南战争，美国视角下一部质量上乘的纪录片。\n\n<!--more-->\n\n## 内容\n\n### 这部记录片讲什么\n\n在这段时间看完了这部在电脑硬盘里放了很久，一直想看又没有时间看的纪录片 [《越南战争》](https://movie.douban.com/subject/6397677/)。该片由美国著名的纪录片导演[肯·伯恩斯](https://movie.douban.com/celebrity/1025341/) 拍摄。豆瓣评分 9.5，总共 10 集，每集大约 110 分钟，全部看需要接近 18 个小时的时间，这也是这部纪录片直到现在才看完的一个重要原因。\n\n我在看之前对越南战争并不了解，所以在整个观看过程中对所有事态的进展和后果也是充满好奇。看完之后专门去百度百科了解了关于越南战争的历史背景、战争经过及影响的一些情况。（建议有兴趣看的可以按照这个顺序看，如果事先了解了一些关于战争的走势及结果，看的时候可能会有些影响，毕竟每一集都有 110 分钟，可能会不自主的跳过一些细节）。\n\n### 为什么推荐\n\n小时候看过一部洪金宝主演的电影《东方秃鹰》，具体故事细节已经忘记了，但是记得里面有很多非常惨烈的打斗场景，人的手被砍掉，被非常惨烈炸死、烧死等各种情节，留下了不少童年阴影，😭😭😭😭。这次看完电影后在网上搜关于越南战争的资料时无意中发现这部电影是发生在北越的。\n\n看完纪录片之后发现，真实的战争可能比电影里呈现的还要残酷。毕竟电影有特效、要做审查，战争中发生的一切都是每一个参与者真实的人生啊。\n\n好莱坞大片里经常出现主人公在危机关头用机枪把飞机突突下来，拯救大家的经典场景。以前觉得用枪把飞机打下来，完全就是扯淡，在记录片里你会发现这是真的，而且打下来的是美军的飞机。在残酷的环境里，为了生存，人类可以迸发出你难以想象的力量。\n\n<img src=\"墙裂推荐纪录片《越南战争》/people.jpg\">\n\n很多时候对战争的残酷没有什么概念，对战争中的伤亡也是纯粹的当做数字。但是经历过这次新冠疫情的影响，真是被自己以前的无知吓了一跳。这一次国内确诊 8 万多，在 3 个多月的时间里有 3 千多人死亡。国外的意大利、伊朗等过形势也是比较糟糕。这样的遭遇，已经让我们大多数都觉得人的生命是如此的脆弱，那些一天变化的不仅仅是数字，是一条条鲜活的生命啊。再反观战争，一次冲刺就可能直接死掉几万人，更有凡尔登绞肉机这种惨绝人寰的战斗场景。整个越南战争到最后有两三百万的人民死亡，五万多的美军士兵死亡，在现在这样一个时代，大部分人应该无法承受这样的伤亡所带来的精神冲击。\n\n<img src=\"墙裂推荐纪录片《越南战争》/sad.jpg\">\n\n而在这部纪录片里，印象最为深刻的是美军多次在伤亡惨重的情况下击退敌方，成功占领了某座山头，但是几天后，又放弃了。这就好比在工作中大家加班、熬夜，辛辛苦苦弄了好久，终于做完了，结果最后说用不上了，都白干了。试想作为参与者的你会多么的无奈，会对安排大家做这件事的领导有多少的怨言，甚至唾弃。到最后也许我们只是失去了一些宝贵的时间、对工作的激情和对领导的信任。但是在战场的士兵，失去的可能就是他们的生命和战友了。\n\n<img src=\"墙裂推荐纪录片《越南战争》/death.jpg\">\n\n有时候战争不仅仅是战争本身了，而是变成了有些领导者为了保全自己尊严和形象的事情，一错再错。\n\n战争是残酷的，他的残酷不仅仅是在战场上，而是会实实在在的反应到所有参与者的生活中，会影响他们的家人。动漫《海贼王》里有个情节，某个城市的人民由于受到能力者的控制，丧失了记忆。于是出现了丈夫看见自己的妻子在忘却自己后和别的人牵手走在大街上，然后丈夫前去理论，反而被当做坏人的场景。有些人士兵牺牲了，会告知家人，最终家人每一年可以去墓碑前祈祷祝福，好歹有个着落；有些士兵却失踪了，你不知道他怎么了，这对他的家人是非常大的折磨；最令人难忘的也许是战俘，在被俘虏后要遭敌方非人的对待，而最终有幸熬到最后，在战争结束后回到家乡时，却发现物是人非，妻子以为自己早已不在人世选择了改嫁，酿成了让所有人都难过的悲剧。而在整件事情当中，妻子错了吗？没有吧。作为战俘的丈夫错了吗？没有吧。真正的错误，就也许就是战争本身。同时战争中使用大量的武器，也对人们生存的环境造成了许多毁灭性的打击，大自然的创伤需要很多很多年才能慢慢恢复。\n\n<img src=\"墙裂推荐纪录片《越南战争》/forget.jpg\">\n<img src=\"墙裂推荐纪录片《越南战争》/girl1.jpg\">\n\n当然，这部片子最吸引的人一点还有就是他披露了许多非常机密的历史，包括一些录音，以及当权者为了自身利益做的一些勾当。另一方面，从美国人民自身的角度出发，人民对战争的支持、沉默到最终的反战大游行，从而激发的一系列矛盾冲突，甚至是从战场回来的老兵都在后期就自己在战时的经历，行为作出反思，公开的演讲质问战争的正确性。更有大量老兵公然扔掉作为战时荣耀的纪念勋章。\n\n影片中还有大量的配乐，使用都是非常经典的老牌知名歌手的歌曲。这些歌曲中有些就是在当时环境下所写，因此很多歌词都是和当时的社会背景是一致的。当然，旋律也很听。\n\n<img src=\"墙裂推荐纪录片《越南战争》/ptsd.jpg\">\n\n从 2016 年的《血战钢锯岭》到 2017 年的《敦刻尔克》再到 2019 年的《决战中途岛》，每一次看完这样的战争电影，都会感受到战争真是太残酷了。但是这些电影更多反映的是战场上的那一面。但是在战争年代，普通老百姓的生活也是非常凄惨的，这一点国内的很多抗日神剧倒是表现的很突出。在这部越南战争中也是不例外，越南人民从内战到抵抗美军，再到最终还是内战，为了实现最终的统一，战后全国留下 100多万的寡妇，20 万残疾人，超过 150 万的越南人民逃离越南，为了生存，远走他乡。\n\n<img src=\"墙裂推荐纪录片《越南战争》/loss1.jpg\">\n<img src=\"墙裂推荐纪录片《越南战争》/loss2.jpg\">\n\n\n对一场已经发生的战争，如果人类能从中获得一些反思，不再让相同的错误再次发生，这也是也是战争另一面的胜利。\n\n<img src=\"墙裂推荐纪录片《越南战争》/lesson.gif\">\n\n## 总结\n\n任何时候都不要轻易挑起战争，战争是解决事情中最糟糕的方式。\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["读书"]},{"title":"用 python 删除照片中的 exif 信息 & 一些常用 tips","url":"%2F2020%2F03%2F15%2F%E7%94%A8-python-%E5%88%A0%E9%99%A4%E7%85%A7%E7%89%87%E4%B8%AD%E7%9A%84-exif-%E4%BF%A1%E6%81%AF%2F","content":"\n<img src=\"用-python-删除照片中的-exif-信息/python.jpg\" >\n\n## 前言\n\nPython 快速实现去除照片中的 Exif 信息。\n\n很多 App 会请求地理位置信息，即便你没有授权，但是只要你上传过照片（这里特指自己用手机拍的图片），大概率还是会通过 Exif 信息暴露地理位置，然后会收到非常流氓的周边推广及广告。\n\n因此，决定用 Python 脚本删掉照片中的 Exif 信息。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [前言](#%e5%89%8d%e8%a8%80)\n- [实现](#%e5%ae%9e%e7%8e%b0)\n  - [读取 Exif](#%e8%af%bb%e5%8f%96-exif)\n  - [修改 Exif](#%e4%bf%ae%e6%94%b9-exif)\n  - [删除 Exif](#%e5%88%a0%e9%99%a4-exif)\n- [拓展](#%e6%8b%93%e5%b1%95)\n  - [Python toString()](#python-tostring)\n  - [文件夹遍历](#%e6%96%87%e4%bb%b6%e5%a4%b9%e9%81%8d%e5%8e%86)\n  - [接收命令行参数](#%e6%8e%a5%e6%94%b6%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%8f%82%e6%95%b0)\n- [总结](#%e6%80%bb%e7%bb%93)\n\n<!-- /TOC -->\n\n## 实现\n\n在 Python 中关于图片的操作，一般都会基于 PIL ，不再赘述。\n\n### 读取 Exif\n\n```shell\npip install exifread\n```\n**[exifread api](https://pypi.org/project/ExifRead/)**\n\n```python \ndef parse_image(path):\n    \"\"\"解析单张图片的信息\"\"\"\n    file = open(path, \"rb\")\n    tags = exifread.process_file(file)\n    info = Info()\n    for tag in tags.keys():\n        if tag not in ('JPEGThumbnail', 'TIFFThumbnail', 'Filename', 'EXIF MakerNote'):\n            print(\"Key: %s, value %s\" % (tag, tags[tag]))\n\n            info.ImageWidth = tags[\"Image ImageWidth\"]\n            info.ImageLength = tags[\"Image ImageLength\"]\n            info.Make = tags[\"Image Make\"]\n            info.Model = tags[\"Image Model\"]\n\n            info.GPSLatitudeRef = tags[\"GPS GPSLatitudeRef\"]\n            info.GPSLatitude = tags[\"GPS GPSLatitude\"]\n            info.GPSLongitudeRef = tags[\"GPS GPSLongitudeRef\"]\n            info.GPSLongitude = tags[\"GPS GPSLongitude\"]\n\n            info.DateTimeOriginal = tags[\"EXIF DateTimeOriginal\"]\n\n    return info\n```\n\n### 修改 Exif \n\n```shell\npip install piexif\n```\n**[piexif api](https://github.com/hMatoba/Piexif)**\n\n```python\ndef modify_gps(path, copy=True):\n    # 读取图片\n    img = Image.open(path)\n\n    try:\n        exif_dict = piexif.load(img.info['exif'])\n    except IOError:\n        print('加载文件地理位置异常！')\n        return\n    exif_dict['GPS'][2] = ((0, 0), (0, 0), (0, 0))\n    exif_dict['GPS'][4] = ((0, 0), (0, 0), (0, 0))\n\n    print(exif_dict['GPS'])\n\n    exif_bytes = piexif.dump(exif_dict)\n\n    if copy:\n        modify_path = path.replace(\".jpg\", \"_hack.jpg\")\n        modify = img.copy()\n        modify.save(modify_path, \"jpeg\", exif=exif_bytes)\n    else:\n        img.save(path, \"jpeg\", exif=exif_bytes)\n```\n这里简单粗暴，直接修改成了 0，当然如果有兴趣做位置伪装，也可以写入特定地址的经纬度信息。\n\n### 删除 Exif\n\n```python\ndef earse_exif(dir):\n    for root, dirs, files in os.walk(dir):\n        for name in files:\n            file = os.path.join(root, name)\n            if file.endswith(\"jpg\") or file.endswith(\"jpeg\"):\n                piexif.remove(file)\n                parse_image(file).to_string()\n```\n这里主要是 **piexif.remove(src)** 。非常方便，支持 jpeg 类型和 webp 类型的图片。内部完成了信息去除及二次写操作，直接调用即可。\n\n## 拓展\n\n### Python toString()\n\n实现类似 Java 中打印所有属性值的 toString() 方法。\n\n```python\nclass Info:\n    ImageWidth = \"\"\n    ImageLength = \"\"\n    Make = \"\"\n    Model = \"\"\n\n    GPSLatitudeRef = \"\"\n    GPSLatitude = \"\"\n\n    GPSLongitudeRef = \"\"\n    GPSLongitude = \"\"\n\n    DateTimeOriginal = \"\"\n\n    def to_string(self):\n        print('\\n'.join(['%s:%s' % item for item in self.__dict__.items()]))\n```\n\n### 文件夹遍历\n\n - 单层\n  \n  ```python\n  def list_dir(path):\n    files = os.listdir(path)\n    for file in files:\n        print(file)\n  ```\n\n - 多层嵌套\n  ```python\n  def list_dir(path):\n    result = os.walk(path)\n    for root, dirs, files in result:\n        for name in files:\n            file = os.path.join(root, name)\n            print(file)\n        for name in dirs:\n            print(os.path.join(root, name))\n  ```\n\n### 接收命令行参数\n\n```python\nif __name__ == '__main__':\n \n    print(sys.argv)\n    print(len(sys.argv))\n    print(str(sys.argv))\n```\n\n```shell\n > python ImageExif.py 1 2 3 4\n\n['ImageExif.py', '1', '2', '3', '4']\n5\n['ImageExif.py', '1', '2', '3', '4']\n\n```\n之前写了一些脚本，比如用来抓图或者爬虫的，但是目标经常会发生变化，因此每次不得不打开代码重新编辑。其实可以用命令行参数的方式把要变更的信息直接传传递过去。用过 sys.argv 接口就可以了。\n\n\n## 总结\n\n\nPython 🐂 🍺。","tags":["python"]},{"title":"当 Java 多态遇到方法重载和重写","url":"%2F2020%2F03%2F14%2FJava-%E5%A4%9A%E6%80%81%2F","content":"\n\n## 前言 \n\n关于 Java 多态 (Polymorphism)的一些 tips。\n\n\n<!--more-->\n\n<!-- TOC -->\n\n- [前言](#前言)\n  - [多态定义](#多态定义)\n- [在方法参数里的多态](#在方法参数里的多态)\n  - [多态的一般情况](#多态的一般情况)\n    - [方法声明和方法被调用](#方法声明和方法被调用)\n  - [总结](#总结)\n- [引用](#引用)\n\n<!-- /TOC -->\n\n\n### 多态定义\n\n- 多态是同一个行为具有多个不同表现形式或形态的能力。\n\n- 多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：\n\n## 在方法参数里的多态\n\n### 多态的一般情况\n\n对于多态，我们最熟悉的一种情况就是 引用类似被声明为父类后，可以把子类的实例赋值给这个引用。\n\n```java\n    Object any = new ArrayList<String>();\n    Object anyone = new String();\n    List<String> list = new LinkedList<>();\n```\n Object 是所有类型的父类，因此他声明的引用，可以执行任意他的子类对象，List 也是同理。\n\n 同时，我们也知道这个时候，这个引用在默认情况下也只能访问父类的属性和方法。比如这里的 any, 虽然想表达的是一个 ArrayList 对象，但是也只能访问 Object 的方法和属性。\n\n <img src=\"Java-多态/father.png\">\n\n当然，这里可以做强制类型转换。\n\n<img src=\"Java-多态/cast.png\">\n\n*这里只是举例，一般不会这么写代码的*\n\n#### 方法声明和方法被调用\n\n关于多态，我们还知道，如果父类和子类声明了相同的方法，那么运行时，会执行子类中的方法。\n\n现在，再来考虑下面这种情况。\n\n<img src=\"Java-多态/polymorphism.png\">\n\n**这里使用截图，没用代码块主要是想体现一下 print 方法的调用情况,可以看到这里第一个 print 方法是高亮的**\n\n结果会是什么呢？ \n\noutput \n\n```shell\nson invoked\nself ====== Son\n```\n\n可以看到，最终调用的是 Son 的 self 方法，但是执行的是第一个 print 方法，也就是参数类型为 Father 的方法。由此可见，方法匹配（暂时这么叫吧）是按声明类型执行的，但是在运行期，是按对象的实际类型执行的。\n\n这里很容易在不经意间产生 bug。假设 print(Father param) 是后添加的，那么他在无形中屏蔽掉子类为参数的方法。如果这两个方法除了调用具体类型的方法，其他逻辑有差异的话，就非常危险了。\n\n### 总结\n\n以上 \n- self() 方法的两次实现，其实是方法的重写；\n- print()方法的两次实现，其实是方法的重载；\n\n因此，便有一下规律\n\nJava的方法分派分为两种：\n\n- 静态分派 - 方法重载分派\n\n  - 编译器就确定\n\n  - 依据调用者的声明类型和方法的参数类型匹配\n\n- 动态分派 - 方法重写分派\n\n  - 运行时确定\n\n  - 依据调用者的实际类型分派\n\n## 引用\n\n[偷听来的Java方法分派策略](https://mp.weixin.qq.com/s?__biz=MzI5NzE0NzEzNQ==&mid=2247484487&idx=1&sn=688adbe73e1c41cbbaa197d326116194&chksm=ecb8cbd7dbcf42c1e960499d26c5a4e93732c004b318a34030ea03871d9f639d9eb454845401)\n\n\n\n\n\n","tags":["Java"]},{"title":"Kotlin 实战读书笔记(二)","url":"%2F2020%2F03%2F04%2FKotlin-%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%8C%2F","content":"\n\n<img src=\"Kotlin-实战读书笔记-二/kotlin.jpg\" width=40%>\n\n## 前言\n《 Kotlin 实战 》读书笔记（5~6章 & 附录及其他）。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [前言](#前言)\n- [《 Kotlin 实战 》读书笔记](#-kotlin-实战-读书笔记)\n  - [5 Lambda 编程](#5-lambda-编程)\n    - [集合的函数式 API](#集合的函数式-api)\n    - [惰性集合操作](#惰性集合操作)\n    - [函数式接口](#函数式接口)\n      - [lambda 表达式转换成函数式接口](#lambda-表达式转换成函数式接口)\n    - [带接收者的 lambda ：with & apply](#带接收者的-lambda-with--apply)\n  - [6 Kotlin 的类型系统](#6-kotlin-的类型系统)\n    - [Elvis 运算符 \"?:\"](#elvis-运算符-)\n    - [!! 非空断言](#-非空断言)\n    - [lateinit](#lateinit)\n    - [类型参数的可空](#类型参数的可空)\n    - [可控性和 Java](#可控性和-java)\n  - [其他](#其他)\n    - [位操作符](#位操作符)\n  - [附录](#附录)\n\n<!-- /TOC -->\n\n## 《 Kotlin 实战 》读书笔记\n\n### 5 Lambda 编程\n\nLambda,可以作为函数参数的代码块\n\n```kotlin\nval sum = {x: Int, y: Int -> x + y}\n```\n\n#### 集合的函数式 API\n - fliter 过滤 (保留符合 predicate=true 的值)\n - map 变换\n - all,any,count,find \n - groupBy 列表按 lambda 表达式提供的字段key 转换为 Map<key,List<T>>\n - flatMap 先对集合中的每个元素做 map 操作，然后把列表合并和一个\n - ~~flatten 直接平铺（合并）~~\n\n```kotlin\nfun main() {\n    val origin = listOf(\"a\", \"b\", \"c\", \"X\", \"H\", \"d\", \"efg\", \"hi\", \"mike\")\n\n    val filter = origin.filter { it.length > 1 }\n    println(filter)\n\n    val map = origin.map { it.toUpperCase() }\n    println(map)\n\n    val all = origin.filter { it.length == 1 }.all { it in \"a\"..\"z\" }\n    // 所有单个字母是否属于小写字母\n    println(all)\n\n    val any = origin.any { it in \"a\"..\"z\" }\n    // 至少有一个匹配 lambda 表达式\n    println(any)\n\n    val count = origin.count { it !in \"a\"..\"z\" }\n    // 综上，all 和 any 在逻辑上是互非的操作，可以按照理解选择\n    println(count)\n\n    val find = origin.find { it in \"e\"..\"z\" }\n    //  返回第一个找到的元素，还有 fiirstOrNull\n    println(find)\n\n    val groupBy = origin.groupBy { it.first() }\n    println(groupBy)\n\n    val flatMap = origin.flatMap { it.toList()}\n    println(flatMap)\n\n}\n```\noutput\n```shell\n[efg, hi, mike]\n[A, B, C, X, H, D, EFG, HI, MIKE]\nfalse\ntrue\n2\nefg\n{a=[a], b=[b], c=[c], X=[X], H=[H], d=[d], e=[efg], h=[hi], m=[mike]}\n[a, b, c, X, H, d, e, f, g, h, i, m, i, k, e]\n```\n**合理使用搭配操作符，避免出现相同操作被执行多次的情况，或者优先筛选，避免无谓的迭代查找**\n\n#### 惰性集合操作\n\n以上 API 操作，每一个操作符在中间会生成一系列的列表，即生成了许多中间的暂时对象，当列表数量巨大时，产生的开销也是巨大的，因此需要优化\n\n```kotlin\nfun userSequence() {\n    val origin = listOf(\"a\", \"b\", \"c\", \"X\", \"H\", \"d\", \"efg\", \"hi\", \"mike\")\n\n    val result = origin.asSequence()\n            .filter { it in \"c\"..\"h\" }\n            .map { \"<\".plus(it).plus(\">\") }\n            .toList()\n    println(result)\n}\n```\noutput\n```shell\n[<c>, <d>, <efg>]\n```\n**只有在执行最后一个操作符(比如上面的 toList())时才会进行所有运算。** 其实和 Java8 中 Stream 是类似的。\n\n#### 函数式接口\n\nSAM \n\n##### lambda 表达式转换成函数式接口\n\n```kotlin\nval run = Runnable { println(\"just run\") }\n```\n\n#### 带接收者的 lambda ：with & apply\n\n ##### with\n  \n  方法原型\n  \n  ```kotlin\n  public inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n  }\n  ```\n ##### apply\n  \n  ```kotlin\n  @kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n  }\n  ```\n\n\n首先从函数原型可以看出，二者都是对**接收者对象**进行了 lambda 表达式的操作。with 返回的是lambda 表达式结果, apply 返回的永远都是接收者对象本身。结合下面的例子：\n\n  使用方式：\n\n  ```kotlin\nval result = with(StringBuilder()) {\n        append(\"a\")\n        append(\"b\")\n        append(\"c\")\n        append(\"d\")\n        append(\"e\")\n        toString()\n        1\n    }\n    println(result)\n    println(result.javaClass)\n\n    val output = StringBuilder().apply {\n        append(\"a\")\n        append(\"b\")\n        append(\"c\")\n        append(\"d\")\n        append(\"e\")\n        toString()\n    }\n    println(output.javaClass)\n  ```\n  ```shell\n  1\n  int\n  class java.lang.StringBuilder\n  ```\n\n  结果和方法定义也是如出一辙。因此这就是二者的区别。apply 本质上是一个扩展函数。带接收者的 lambda 是构建 DSL 的好工具。\n\n\n\n### 6 Kotlin 的类型系统\n\n#### Elvis 运算符 \"?:\"\n\n```kotlin\nfun foo(s: String?) {\n  val length : Int = s?.length ?: 0\n}\n```\n#### !! 非空断言\n\n```kotlin\nfun foo(s: String?) {\n  val result = s!!\n  println(result.length)\n}\nfoo(null)\n```\n此时，在 s!! 的时候立即会发生 npe，而不是在使用的时候。\n\n对于控制还可以使用 let 操作符\n\n```kotlin\n// 使用\n\nval param: String? = \"\"\n  param?.let {\n    \n    println(it)\n  }\n// 函数原型\n\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n```\n**可以看到 let 函数和之前的 apply 函数有些相似，都是扩展函数，但是 let 返回的是 lamdba 执行的结果，而 apply 返回的永远都是接收者对象；再有和 let 和 with 也是不一样的，虽然都是返回 block 执行结果，但是with 的默认参数是 this 因此可以直接调用接收者方法，而 let 默认参数是 it ；必须用 it 才能调用接收者的方法。**\n\n#### lateinit\n  \n  个人经验，lateinit 比较坑，尽量不用吧\n\n```kotlin\nprivate lateinit var mm :Any\n....\n    if(::mm.isInitialized) {\n       // 最安全的使用场景\n    }\n```\n\n#### 类型参数的可空\n\n在 Kotlin 中所有泛型类和泛型函数的类似参数默认都是可空的。\n\n```kotlin \nfun <T> printHash(t: T) {\n  println(t?.hashCode())\n}\n```\n类型参数推导出的类型是 Any?，因此 T 虽然声明非空，但是其实是可空的。为了避免这种情况，可以这样声明：\n\n```kotlin\nfun <T :Any> printHash(t: T) {\n  println(t?.hashCode())\n}\n```\n\n#### 可控性和 Java\n\n - 包含注解\n\n  首先，如果 Java 代码写的比较规范，那么代码中\n  \n  ```java\n  @Nullable + Type == Type?\n  @Notable  + Type == Type\n  ```\n  如果 Type 没有注解，那么在 Kotlin 中会被当做平台类型\n  \n - 平台类型\n  \n  不知道可空性信息的类型，即使用者既可以当做空类型，也可以当做非空类型。进行操作是，自己决定是否需要判空。\n\n  常见的错误类型信息\n\n  ```shell\n  Type mismatch: inferred type is String,but Int was expected\n  ```\n\n  在用 Kotlin 继承实现 Java 的类时，一定要确定好参数的可控性，不要随意删掉参数后的 ？。**Kotlin 编译其会为你声明的每一个非空的参数生成非空断言，如果 java 代码传递了一个 null，断言就会触发，即便你从来都没用过这个参数**\n  \n  #### 基本数据类型和其他类型\n  \n  - Kotlin 不区分基本数据类型和包装类型\n  - Any,Unit & Nothing\n\n    - Any 所表达的含义类似于 Java 中的 Object。但是依旧要区分 Any 和 Any？。但是 Any 并不是 Object，没有继承关系。\n\n    ```kotlin\n    public open class Any {\n    \n    public open operator fun equals(other: Any?): Boolean\n    \n    public open fun hashCode(): Int\n\n  \n    public open fun toString(): String\n    }\n    ```\n\n    并没有 Object 的 wait 及 notify 等方法。\n\n    - Unit 表达 Java 中 void 的含义。大部分情况作为函数返回值使用，没有什么特别的。**在 Kotlin 中，Unit 是一个完备的类型，可以作为参数类型（就是泛型尖括号里内容），但是 void 是不行的。而且他有唯一的值，这个值也是 Unit，在返回为 Unit 的函数中会被隐式的返回。\n\n    ```kotlin\n    interface Processor<T> {\n      fun proc(): T \n    }\n\n    class NoResultProcessor : Processor<Unit> {\n        override fun proc() {\n          // 底层帮你显示的返回了这句，不用自己写\n          return Unit\n        }\n    }\n    ```\n    这个特性其实非常好，类似 Callable<T> 和 Runnable 其实并不需要重复定义了（当然只是对纯粹使用 Kotlin 的实现来说），比较在 Java 中为了表达返返回的**泛型为空**这件事代码得这么写\n\n    ```java\n    private static void simpleCallable() {\n\n        Callable call = new Callable<Void>() {\n\n            @Override\n            public Void call() throws Exception {\n                // 必须显示的写 return 语句\n                return null;\n            }\n        };\n      }\n    ```\n    - Nothing \n  \n    这个函数永不返回，一般用在抛出异常等场景。\n\n  #### 集合和数组\n\n  - 集合\n  \n  Kotlin 中结合区分为可变集合不可变集合。\n\n  |集合类型|只读|可变|\n  |---|---|---------------------|\n  |List|listOf|mutableListOf,arrayListOf|\n  |Set|setOf|mutableSetOf,hashSetOf,linkedSetOf,sortedSetOf|\n  |Map|mapOf|mutableMapOf,hashMapOf,linkedMapOf,sortedMapOf|\n \n 在 Kotlin 中使用 Java 中定义的方法是，对于方法中集合类型，需要结合实际业务决定集合的可空性、可变性等因素。\n\n - 数组\n\n  - 引用类型数组\n  \n    ```kotlin\n    // 引用类型的数组声明及创建方式\n    val strings: Array<String> = arrayOf(\"a\", \"b\", \"c\")\n    println(strings.joinToString())\n    val peoples: Array<People?> = arrayOfNulls<People>(5)\n    println(peoples.joinToString())\n    val people :Array<People> = Array(3) {\n        People(\"mike $it\",\"${it*it}\".toInt())\n    }\n    println(people.joinToString())\n    ```\n    ```shell\n    a, b, c\n    null, null, null, null, null\n    People(name=mike 0, age=0), People(name=mike 1, age=1), People(name=mike 2, age=4)\n    ```\n    引用类型，有 3 中方法可以创建数组，可以满足日常需求了。\n  \n  - 基础类型数组\n\n   ``` kotlin\n     // 基本数据类型的数组\n\n    val ints: Array<Int> = arrayOf(1, 2, 3, 4)\n    println(ints.javaClass)\n    println(ints.joinToString())\n\n    // 基础数据类型数组创建方式 1\n    val ints0 = IntArray(5)\n    println(ints0.javaClass)\n    println(ints0.joinToString())\n\n    // 基础数据类型数组创建方式 2\n    val ints1 = intArrayOf(0, 1, 2, 4)\n    println(ints1.joinToString())\n\n    // 基础数据类型数组创建方式 3\n    val ints2 = IntArray(4) { it * it }\n    println(ints2.joinToString())\n\n    // [Integer] 转换为 [int]\n    val ints3: IntArray = arrayOf(1, 2, 3, 4).toIntArray()\n    println(ints3.joinToString())\n    ```\n    ```shell\n    class [Ljava.lang.Integer;\n    1, 2, 3, 4\n    class [I\n    0, 0, 0, 0, 0\n    0, 1, 2, 4\n    0, 1, 4, 9\n    1, 2, 3, 4\n    ```\n    IntArray 对应于 int[],而 Array<Int> 对应于 Integer[],因此如果需要使用数组，应该经量选择 IntArray,ByteArray,CharArray 这些真正的基础类型。当然，也可以通过装箱类型的数组做转换。\n\n  - 数组遍历\n  \n    ```kotlin\n        // 带下标的遍历方式\n        for (i in ints2.indices) {\n            print(i)\n        } \n    ```\n\n### 其他\n在这本书里始终没有提到，但是有时候又会用到的东西。\n\n#### 位操作符\n\n```shell\nshl(bits) – 左移位 (Java’s <<)\nshr(bits) – 右移位 (Java’s >>)\nushr(bits) – 无符号右移位 (Java’s >>>)\nand(bits) – 与\nor(bits) – 或\nxor(bits) – 异或\ninv() – 反向\n```\n\n### 附录\n- 文档相关\n\n\n类似于 Java 的 Javadoc ，Kotlin 有 KDoc。 有 Java 相比有部分差异。Kotlin 的文档生成工具叫做 \n[Dokka](https://github.com/kotlin/dokka)","tags":["Kotlin"]},{"title":"Kotlin 实战读书笔记(一)","url":"%2F2020%2F03%2F03%2FKotlin-%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80%2F","content":"\n<img src=\"Kotlin-实战读书笔记-一/kotlin.jpg\" width=40%>\n\n## 《Kotlin 实战》读书笔记 （1~4 章）\n\n<!--more-->\n\n<!-- TOC -->\n\n- [《Kotlin 实战》读书笔记 （1~4 章）](#kotlin-实战读书笔记-14-章)\n  - [第一部分 Kotlin 简介](#第一部分-kotlin-简介)\n    - [1 Kotlin : 定义和目的](#1-kotlin--定义和目的)\n      - [Kotlin [Playground](http://try.kotl.in)](#kotlin-playgroundhttptrykotlin)\n      - [编译 Kotlin](#编译-kotlin)\n    - [2 Kotlin 基础](#2-kotlin-基础)\n      - [关于语句和表达式](#关于语句和表达式)\n      - [类和属性](#类和属性)\n      - [when & for](#when--for)\n      - [Kotlin 异常](#kotlin-异常)\n    - [3 函数的定义和调用](#3-函数的定义和调用)\n      - [集合的处理（可变参数、中缀调用和库的表示）](#集合的处理可变参数中缀调用和库的表示)\n      - [字符串分割 （更加友好）](#字符串分割-更加友好)\n      - [局部函数和扩展](#局部函数和扩展)\n    - [4 类、对象和接口](#4-类对象和接口)\n      - [修饰符](#修饰符)\n      - [内部类和嵌套类](#内部类和嵌套类)\n      - [密封类](#密封类)\n      - [自定义访问器](#自定义访问器)\n      - [编译器生成的方法： 数据类和类委托](#编译器生成的方法-数据类和类委托)\n        - [数据类](#数据类)\n        - [类委托](#类委托)\n        - [object 关键字用法](#object-关键字用法)\n\n<!-- /TOC -->\n### 第一部分 Kotlin 简介\n\n#### 1 Kotlin : 定义和目的\n\n针对 Java 平台的静态类型语言。\n\n##### Kotlin [Playground](http://try.kotl.in)\n##### 编译 Kotlin \n  \n  ```shell\n\n  kotlinc <source file or dir> -include-runtime -d xxx.jar\n  java xxx.jar\n\n  ```\n\n#### 2 Kotlin 基础\n\n##### 关于语句和表达式\n\n>在 Kotlin中，if 是表达式，而不是语句。语句和表达式的区别在于，表达式有值，并且能作为另一个表达式的一部分使用；而语句总是包围着它的代码块中的顶层元素，并且没有自己的值。\n\n>在 Java中，所有的控制结构都是语句。而在 Kotlin中，除了循环（for、do和 dowhile）以外大多数控制结构都是表达式。这种结合控制结构和其他表达式的能力让你可以简明扼要地表示许多常见的模式，稍后你会在本书中看到这些内容。\n\n>另一方面，Java中的赋值操作是表达式，在 Kotlin中反而变成了语句。这有助于避免比较和赋值之间的混淆，而这种混淆是常见的错误来源。\n\nif 是表达式的意义\n\n```kotlin\nfun max(a: Int,b: Int) = if (a > b) a else b\n```\n但这在 java 中是不可以的，因为 if 是语句\n\n##### 类和属性\n\n  - 自定义访问器\n\n  ```kotlin\n  class Rectangle(val h:Int,val w:Int) {\n    val isSquare : Boolean \n      get() = h == w \n  }\n  ```\n\n  - 枚举的定义，唯一的分号 ;\n  \n  ```kotlin\n  enum class Color(val r:Int) {\n    BLACK(0),WHITE(1); // 此处必须有分号\n\n    fun xxx(){}\n  }\n  ```\n\n##### when & for\n  \n  - when \n  \n  可以使用枚举，此时 when 是一个语句，可以直接作为返回值\n  ```kotlin\n  fun getXXX(color:Color) = \n    when(color) {\n      Color.WHITE -> \"xx\"\n      Color.BLACK -> \"oo\"\n    }\n  ```\n  和 Java 中 switch 的限制不同， when 可以使用任意对象，比如集合。还有一种不带参数的 when \n\n  ```kotlin\n  fun mix(c1:Color,c2:Color) = \n  when {\n    (c1 == RED && c2 == YELLOW) -> \"XX\"\n    (c1 == BLACK) -> \"OOO\"\n    (c2 == WHITE) -> \"ASDF\"\n  }\n  ```\n  因此，在 kotlin 中使用 when 似乎可以覆盖所有场景，包括各种 if-else 结构。\n\n  - for \n\n  ```kotlin\n  for(i in 0..10){} // 闭合区间\n  for(i in 0..10 step 2) // 调整步进\n  for(i in 100 downTo 1) // 反向\n  for(i in 0 until 10){} // 开区间，不包括 10\n\n  // map 循环输出\n  val map = TreeMap<Char,String>()\n  for(c in 'A'..'F') {\n    val value = Integer.toBinaryString(c.toInt())\n    map[c] = value\n  }\n  for((key,value) in map) {\n    println(\"$key == $value\")\n  }\n\n  // 列表带下标输出\n  val list = arrayListOf(\"a\",\"b\",\"c\")\n  for((index,element) in list.withIndex()) {\n    println(\"$index : $element\")\n  }\n\n  // !in 区间判断\n  val number = 5 !in 'a'..'c'\n  val letter = 'a' !in 0..9 \n  ```\n\n##### Kotlin 异常\n\n   - Kotlin 不区分受检异常和未受检异常（因为没有意义），因此不需要抛出未受检异常\n   - try 可以作为表达式\n\n\n#### 3 函数的定义和调用\n\n ##### 更好的函数定义\n   - 默认参数值\n  \n   ```kotlin\n   fun <T> doXX(list:Collection<T>,\n                a: String? = \"A\",\n                b: String = \"B\" ) :String\n   ``` \n\n   由于 Java 没有默认参数值，因此调用 doXX 时必须传所有参数。但也可以用 **JvmOverloads** 注解 doXX 方法，在编译期会帮忙生成重载方法，从最后一个参数开始省略\n\n   - 可以直接在kotlin 文件中定义函数和属性，比如 Util.kt \n     ```kotlin\n     @file:JvmName(\"CustomUtil\")\n     package com\n\n     fun foo() {}\n     ```\n     调用\n\n     ```java\n     import com.UtilKt // 当未使用 @file:Jvm 注解时默认的类名\n     import com.CustomUtil // 注解后的类名\n\n     fun my() {\n       CustomUtil.foo() \n     }\n     ```\n     同理可以定义属性，这一特性称为顶层函数和顶层属性\n\n  - 扩展函数和属性\n    - 扩展函数\n  \n    ```kotlin \n    // StringUtil.kt\n    package com\n\n    fun String.lastChar() : Char {\n      return this.get(this.length - 1)\n    }\n    ```\n    调用\n\n    ```koltin\n    import com.lastChar\n    import com.lastChar as last // 也可以重命名，解决冲突问题\n    val last = \"Hello World\".lastChar()\n    ```\n\n    其中 String 叫做 **接收者类型**，this(\"Hello World\") 叫做**接收者对象** . 扩展函数可以认为是类的成员函数。\n\n    **本质上，扩展函数是静态函数**，把调用对象作为第一个参数。因此在 java 代码中调用需要这样 \n\n    ```java\n    char c = StringUtilKt.lastChar(\"Java World\");\n    ```\n\n    由于扩展函数是静态函数，他不可以被重写，因此当父类和子类添加了相同的扩展函数时，他由变量的静态类型确定，而不是运行期的类型。同时如果扩展函数和类中的成员函数相同时，成员函数优先使用。\n\n    - 扩展属性 \n\n        ```kotlin \n        // StringUtil.kt\n        package com\n\n        fun String.lastChar : Char\n            get() = get(length -1)\n        ```\n\n        调用\n\n        ```kotlin\n        val result = \"kotlin\".lastChar // kotlin\n        ```\n        ```java\n        Char result = StringUtilKt.getLastChar(\"Java\");\n        ```\n##### 集合的处理（可变参数、中缀调用和库的表示）\n  - 可变参数函数定义\n  ```kotlin\n  fun listOf<T>(vararg values: T) : List<T> {}\n  ```\n  java 用 ... ，kotlin 用 vararg \n\n  - 中缀调用和结构处理\n\n  ```kotlin\n  val map = mapOf(1 to \"one\",2 to \"two\",3 to \"three\")\n  ```\n  to 是一种特殊的函数调用，即中缀调用。函数必须用 infix 修饰\n\n  ```kotlin\n  // 函数原型\n  infix fun Any.to(o: Any) = Pair(this,o)\n  ```\n\n   结构处理\n\n   ```kotlin\n   val (first,second) = 1 to \"one\"\n   ```\n\n##### 字符串分割 （更加友好）\n##### 局部函数和扩展\n\n相当于在方法内部定义方法，是代码更紧凑。淡然也可以把定义在内部的方法当做类的扩展函数处理，这个就看具体设计了。\n```kotlin\nfun saveUser(user:User) {\n  // validate 局部函数\n   fun validate(value:String,name:String) {\n     if(value.isEmpyt()){\n       throw Exception(\"error\")\n     }\n   }\n   validate(user.name,\"Name\")\n   validate(user.address,\"Address\")\n}\n```\n\n#### 4 类、对象和接口\n\n##### 修饰符\n\n - 访问修饰符\n  \nJava 的类和方法默认都是 open 的，而 Kotlin 中默认都是 final 的。\n\n|修饰符|相关成员|评注|\n|---|---------|-----------------|\n|final|不能被重写|类中成员默认|\n|open|可以被重写|需要明确地表明|\n|abstract|必须被重写|只能在抽象类中使用；抽象成员不能有实现|\n|override| 重写父类或接口中的成员|如果没有使用 final，表明重写的成员默认是开放的|\n\n  - 可见性修饰符\n\n在 Kotlin 中默认是 public 的，用 internal 表达模内部可见的含义。\n\n**internal 在编译阶段，最终会变成 public 的，因此会出现某些类可以通过 java 访问但不能通过 kotlin 访问的场景** \n\n|修饰符|类成员|顶层声明|\n|---|---------|----------|\n|public|所有地方可见|所有地方可见|\n|internal|模块中可见|模块中可见|\n|protected|子类中可见|-|\n|private|类中可见|文件中可见|\n\n##### 内部类和嵌套类\n\n在 Kotlin 中由于 fun 是一等公民，而不像 Java 中的类，因此在同一个文件中声明的类的包含关系有差异。\n\n|类 A 在另一个类 B 中声明|在 Java 中|在 Kotlin 中|\n|---|---------|-----------------|\n|嵌套类(不存储外部类的引用）|static class A |class A |\n|内部类（持有外部类的引用）| class A |inner class A |\n\n##### 密封类\n\n被 scaled 标识的类，其直接子类必须嵌套在父类中，保证了代码边界条件的规范性。\n\n```kotlin\nscaled class Expr {\n  class Num() : Expr()\n  class Sum() : Expr()\n}\n```\n\n##### 自定义访问器\n\n比较玄幻 \n\n##### 编译器生成的方法： 数据类和类委托\n\n######  数据类\n\n```kotlin\ndata class People(val name:String,val age:Int)\n```\ndata 标记的**数据类**会根据属性主动生成友好的 toString(),hashCode(),equals(),get()/set()  等方法。对上述 People 文件生成的 class 反转成 java 文件 \n\n```java\npublic final class People {\n   @NotNull\n   private final String name;\n   private final int age;\n\n   @NotNull\n   public final String getName() {\n      return this.name;\n   }\n\n   public final int getAge() {\n      return this.age;\n   }\n\n   public People(@NotNull String name, int age) {\n      Intrinsics.checkParameterIsNotNull(name, \"name\");\n      super();\n      this.name = name;\n      this.age = age;\n   }\n\n   @NotNull\n   public final String component1() {\n      return this.name;\n   }\n\n   public final int component2() {\n      return this.age;\n   }\n\n   @NotNull\n   public final People copy(@NotNull String name, int age) {\n      Intrinsics.checkParameterIsNotNull(name, \"name\");\n      return new People(name, age);\n   }\n\n   // $FF: synthetic method\n   public static People copy$default(People var0, String var1, int var2, int var3, Object var4) {\n      if ((var3 & 1) != 0) {\n         var1 = var0.name;\n      }\n\n      if ((var3 & 2) != 0) {\n         var2 = var0.age;\n      }\n\n      return var0.copy(var1, var2);\n   }\n\n   @NotNull\n   public String toString() {\n      return \"People(name=\" + this.name + \", age=\" + this.age + \")\";\n   }\n\n   public int hashCode() {\n      String var10000 = this.name;\n      return (var10000 != null ? var10000.hashCode() : 0) * 31 + Integer.hashCode(this.age);\n   }\n\n   public boolean equals(@Nullable Object var1) {\n      if (this != var1) {\n         if (var1 instanceof People) {\n            People var2 = (People)var1;\n            if (Intrinsics.areEqual(this.name, var2.name) && this.age == var2.age) {\n               return true;\n            }\n         }\n\n         return false;\n      } else {\n         return true;\n      }\n   }\n}\n```\n\n可以看到\n  - 由于在定义 People 的时候，name:String 默认非空，编译后的代码添加了 @NotNull 注解，并在构造函数里进行了空判断。\n  - toString 打印了所有属性\n  - hashCode 会优先根据 name 属性生成，name 为空时会用 age 生成\n  - equals 的实现和我们正常的实现思路基本一致，比较对象及所有属性。\n\n###### 类委托\n\n```kotlin\nclass DelegateCollection<T>(\n        innerList: Collection<T> = ArrayList()) : Collection<T> by innerList\n```\n\nDelegateCollection 实现 Collection 后默认行为通过 by 委托给 innerList(即 ArrayList 实现)，而需要包装的行为则可以由自己实现。避免了**装饰者模式**中的模板代码。\n\n> 装饰者模式一句话介绍： 创建一个新类，实现与原始类一样的接口并将原来的类的实例作为一个字段保存。与原始类拥有同样行为的方法不用被修改，只需要由原始类的实例进行装发。\n\n###### object 关键字用法\n\n**这个关键字定义一个类并同时创建一个实例**\n\n常用场景： \n\n - 对象声明，创建单例\n\n将类声明和该类的单一实例声明结合到一起实现\n\n  ```kotlin\n  object Single {\n      val prop = \"单例\"\n    \n      fun doXX() {}\n  }\n\n // 调用\n\n  val v = Single.prop\n  Single.doXX()\n  ```\n可以理解为用 object 标记的类在声明时就创建了该类的对象。同时他没有构造函数，其他地方也无法创建他的实例，因此他天然就是个单例。在 Java 中使用时稍微有些差别： \n\n```java\n        Single.INSTANCE.doXX();\n        String v = Single.INSTANCE.getProp();\n```\n\n可以用 @JvmStatic 注解方法或熟悉，避免 INSTANCE\n\n```kotlin\n    @JvmStatic\n    fun doXX() {}\n```\n```java\n    Single.doXX();\n```\n\n- 伴生对象\n\n```kotlin \nclass Factory private constructor(val brand: String) {\n    companion object {\n        val ONE_BYTE = 1024\n        val ONE_MB = ONE_BYTE * ONE_BYTE\n        val ONE_GB = ONE_MB * ONE_MB\n        fun appleFactory() = Factory(\"Apple\")\n        fun androidFactory() = Factory(\"Google\")\n    }\n}\n\n// 调用\n\nval oneByte = Factory.ONE_BYTE\nFactory.appleFactory()\nFactory.androidFactory()\n```\n相当于是 Java 中的静态方法和静态变量。通过 companion object 进行包裹即可。还可访问类的 private 构造函数，因此是工厂模式的典范。\n\n- 对象表达式\n\n用来声明匿名对象，替代 Java 中匿名内部类的用法。\n\n```kotlin\n    fun doSomeThing(param:Int) {\n        Thread(object :Runnable {\n            override fun run() {\n                println(\"$param\")\n            }\n\n        })\n    }\n```\n这可以看到，在内部类当中，可以直接访问方法参数，而在 Java 中这个参数必须是 final 的。Kotlin 会自动完成捕获。\n\n```kotlin\n   /**\n     *  用 object 可以实现多个接口\n     */\n    val multiInterfaceImpl  = object :Runnable ,Callable<Int>{\n        override fun call(): Int {\n            return 1\n        }\n\n        override fun run() {\n\n        }\n    }\n```\n\n可以看到用 object 可以实现多个接口，这是 Java 做不到的。\n\n**匿名对象并不是单例**","tags":["Kotlin"]},{"title":"Kotlin 和 Java 的细微差异与坑 （持续更新）","url":"%2F2020%2F02%2F25%2Fkotlin-%E5%92%8C-java-%E7%9A%84%E7%BB%86%E5%BE%AE%E5%B7%AE%E5%BC%82%2F","content":"\n<img src=\"kotlin-和-java-的细微差异/kotlin-logo.jpeg\" width=60%>\n\n## 前言\nKotlin 在使用过程中和 Java 的一些细微差异及一些坑\n\n<!--more-->\n\n<!-- TOC -->\n\n- [前言](#前言)\n- [差异](#差异)\n  - [for 循环最后的值](#for-循环最后的值)\n  - [== 和 ===](#-和-)\n  - [不要随意改变参数类型](#不要随意改变参数类型)\n- [总结](#总结)\n\n<!-- /TOC -->\n\n## 差异 \n\n### for 循环最后的值\n\n - java \n\n```java\n        int i = 3;\n        for (; i >= 0; i--) {\n            // 这里创造一种使整个循环退出的一种条件\n            if (i == 100) {\n                break;\n            }\n        }\n        System.out.println(\"i == \" + i);\n```\n最后结果\n\n```shell\ni == -1\n```\n通过上述循环，我们可以知道这个 for 循环之所以结束，是因为 i 最后变成了 -1 。\n\n - kotlin\n\n```kotlin\n    var i = 100\n    for (i in 3 downTo 1) {\n        // just test\n    }\n    println(\"i == $i\")\n```\n最后结果\n\n```shell\ni == 100\n```\n\n可以看到，在 Kotlin 中for 循环中变量 i 的作用域仅仅在 for 循环内，外部定义的同名变量不会被覆盖，也无法影响他。**因此，这种情况下 java 中某些算法，会在这种场景下失效，尤其是后续逻辑执行依赖 i 的情况下**\n\n### == 和 === \n\n表示相等性\n\n- 在Java中，可以使用 ＝＝ 运算符来比较基本数据类型和引用类型。如果应\n用在基本数据类型上，Java的 ＝＝ 比较的是值，然而在引用类型上＝＝比较的是引用。因此，在Java中，众所周知的实践是总是调用 equals，如果忘记了这样做当然也会导致众所周知的问题。\n- 在 Kotiin，＝＝ 运算符是比较两个对象的默认方式:本质上说它就是通过\n调用 equals来比较两个值的。因此，如果 equals在你的类中被重写了，你能够很安全地使用＝＝来比较实例。要想进行引用比较，可以使用＝＝＝运算符，\n这与Java中的＝＝比较对象引用的效果一模一样。\n\n### 不要随意改变参数类型\n\n假设现有 Java 接口 \n\n```java\n```\n然后在 Kotlin 中有实现\n\n```kotlin\nclass SimpleProcessor : StringProcessor {\n    override fun proce(input: String?): String {\n        return \"nothing\"\n    }\n}\n```\n如果用 IDE 默认帮你生成的话， 在 Kotlin 中参数 input 的可空性，默认是可以空的。但是如果你的实现中没有用到这个参数，然后你觉得这个参数空不空无所谓，把多余的问号删掉了 \n```kotlin\nproce(input: String)\n```\n当然，如果是在 Kotlin 中调用这个方法，那么IDE 会帮你检查参数的合法性。但是在 Java 中就做不到了，假设某个调用方，传递了 null 值。\n\n```java\n        StringProcessor simple = new SimpleProcessor();\n        simple.proce(null);\n```\n当然这个 null 肯定不是刻意传的，但是这个情况是有可能发生的。这个时候，就会发生\n```shell\njava.lang.IllegalArgumentException: Parameter specified as non-null is null: method com.test.SimpleProcessor.proce, parameter input\n```\n即便你从来都没有用过这个参数，但是编译器对这个非空参数是做了断言的，这个时候传 null，就悲剧了。\n\n\n\n## 总结\n\n从 Java 迁移到 Kotlin 整体上是比较简单的，但任有一些差异需要我们在日常开发中注意。","tags":["Kotlin"]},{"title":"两个对象 hashcode 相同，他们就一定相等吗？","url":"%2F2020%2F02%2F25%2FString-valueOf-%E6%96%B9%E6%B3%95%2F","content":"\n结合 String 不变的特性，从 String.valueOf 所引发的一个小 bug 出发，再次探索一下 == 和 equals 的区别 ，加深理解。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [前言](#%e5%89%8d%e8%a8%80)\n- [== vs equals](#vs-equals)\n- [String](#string)\n\n<!-- /TOC -->\n\n## 前言\n\nJava 中 String 类提供了一系列 valueOf 方法，方便开发者非常方便的将意义对象转换为 String。\n\n<img src=\"String-valueOf-方法/valueof.png\" width=60%/>\n\n## == vs equals \n\n```java\n\n    private static void testOnStringValueOf() {\n        char a = 'a';\n        char b = 'a';\n\n        System.out.println(\"a==b \" + (a == b));\n\n        String ab = \"aa\";\n        String a1 = String.valueOf(ab.charAt(0));\n        String a2 = String.valueOf(ab.charAt(1));\n\n        System.out.println(\"a1==a2 \" + (a1 == a2));\n        System.out.println(\"a1.equals(a2) \" + (a1.equals(a2)));\n\n        System.out.println(\"1==1 ? \" + (String.valueOf(1) == String.valueOf(1)));\n        System.out.println(\"1eq1 ? \" + (String.valueOf(1).equals(String.valueOf(1))));\n\n        String s1 = \"a\";\n        String s2 = \"a\";\n\n        System.out.println(\"s1==s2 \" + (s1 == s2));\n        System.out.println(\"s1.equals(s2) \" + (s1.equals(s2)));\n    }\n```\n\n可以事先在大脑中模拟输出一下结果 \n\n实际输出：\n\n```shell\na==b true\na1==a2 false\na1.equals(a2) true\n1==1 ? false\n1eq1 ? true\ns1==s2 true\ns1.equals(s2) true\n```\n\na1 a2 和 s1 s2 到底有什么区别，为什么比较结果不一致呢？\n\n我们回顾一下 == 和 equals 的区别 \n\n - 对于基本类型的数据，我们用 >,>=, <,<=, == 进行相等相等性的比较。 比如\n    ```java \n      int a = 4;\n      int b = 5;\n      boolean result = a >= 5;\n      result = a == b\n      ```\n\n- 对于对象(或者说是引用)类型的数据，当我们用 == 进行相等性比较时，其实是在比较对象在内存中地址，因此指向堆上两个不同对象的引用（或者说是指针）的大小一定是不同的。\n  \n```java\n\npublic class People {\n    private String name;\n\n    public People(String name) {\n        this.name = name;\n    }\n}\n\nObject obj1 = new People(\"mike\"); \nObject obj2 = new People(\"mike\");\nObject obj3 = obj2;\n\nSystem.out.println(\"====\" + obj1.hashCode());\nSystem.out.println(\"====\" + obj2.hashCode());\nSystem.out.println(\"====\" + obj3.hashCode());\n\nSystem.out.println(\"obj1 == obj2 ? =\" + (obj1 == obj2));\nSystem.out.println(\"obj3 == obj2 ? =\" + (obj3 == obj2));\n``` \n\n结果 \n\n```shell\n====1625635731\n====1580066828\n====1580066828\nobj1 == obj2 ? =false\nobj3 == obj2 ? =true\n```\n\nobj1 和 obj2 是通过 new 操作符创建的两个完全不同的对象，因此他们再内存中的地址必然是不一样的，因此直接进行 **==** 结果肯定是完全不相同。而 obj3 通过 **=** 赋值操作符，相等于和 obj2 指向了完全相同的地址，因此他们是相等的。\n\n~~这里内存地址的说法似乎比较玄学，我们就理解为对象的 hashCode 好了，至于这个值是怎么计算的，暂时不展开了。~~\n\n- 对于对象类型的数据，当我们用 equals() 方法进行比较时，就是比较其**内容**是否真的相等了。那么内容相等是什么意思呢？别着急，先看个代码\n\n```java\n\nSystem.out.println(\"obj1.equals(obj2) ? ==\" +(obj1.equals(obj2)));\nSystem.out.println(\"obj3.equals(obj2) ? ==\" +(obj3.equals(obj2)));\n```\n结果： \n\n```shell \nobj1.equals(obj2) ? ==false\nobj3.equals(obj2) ? ==true\n```\n\n结果似乎和 **==** 比较的结果一样啊。是的，默认就是一样的。因为Java 中超级父类 Object 进行 equals 比较时，默认进行的就是 == 比较。\n\n```java\n    public boolean equals(Object obj) {\n        return (this == obj);\n    }\n```\n🤣🤣🤣🤣🤣🤣🤣🤣🤣🤣\n\n现在来说**内容相同**这件事。什么叫内容相同呢？其实就是看定义类的作者如何去限定。比如这里的 People，当两个对象的 name 字段相同时我们便认为二者相等。\n\n```java\npublic class People {\n    private String name;\n\n    public People(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        People other = (People) obj;\n        return this.name.equals(other.name);\n    }\n}\n```\n这时候，再运行刚才的 equals 比较代码，就可以得到两个对象相同的结果了。当然，对一个复杂的对象，有时候我们可能还需要根据其他字段综合决定。但是一般情况下我们都会根据某个特定的字段决定，比如商品 id ,或订单 id 这样符合实际意义的字段确定。\n\n对于一般的相等性比较场景，覆写 equals 似乎已经足够了。但是你一定看到过这种说法**覆写 equals()方法的同时， 一般需要覆写 hashcode()方法**。 为什么一定要覆写 hashcode() 方法呢。因为所有以散列表（或者说 哈希表）为结构的数据集合（或者说是数据容器），其中 key 的相等性比较涉及 hashcode() 方法。比如这里的 People 对象，由于我们没有覆写 hashcode ,当我们用 People 对象作为哈希表的 key 时，两个相等的对象会被当做不相等的对象。因此，这里可以简单处理，按照 equals 比较中内容的 hashcode 决定。\n\n\n```java\n\n    @Override\n    public int hashCode() {\n        return this.name.hashCode();\n    }\n```\n\n\n话说回来，大部分情况我们都会用 String 作为 HashMap 的 key。这又是为何呢？\n\n## String \n\n看一下 String 类的 equals 方法和 hashcode 方法\n\n```java\n    public boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String)anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                        return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        int h = hash;\n        if (h == 0 && value.length > 0) {\n            char val[] = value;\n\n            for (int i = 0; i < value.length; i++) {\n                h = 31 * h + val[i];\n            }\n            hash = h;\n        }\n        return h;\n  }\n```\n**注意，这里的 value 是一个 char[],它存储的就是字符串的实际值**\n\n- equals() 可以看到字符串相等性比较，首先会进行 **==** 比较，也就是先比较两个 String 的内存地址，在内存地址不相等的情况下，是严格按照字符串中的每一个 char 进行精确比较的。\n- hashcode() 和字符串的实际值强相关，同时从算法也可以看出，两个字符串如果内容完全一致，那么他们的 hashcode 一定是相等的，而如果连个字符串哪怕相差一个字符，二者的 hashcode 可能会有天壤之别。\n\n再来回顾一下最开始的代码：\n\n```java\n        String ab = \"aa\";\n        String a1 = String.valueOf(ab.charAt(0));\n        String a2 = String.valueOf(ab.charAt(1));\n\n        System.out.println(\"a1 hashcode = \"+(a1.hashCode()));\n        System.out.println(\"a2 hashcode = \"+(a2.hashCode()));\n        System.out.println(\"a1 == a2 \" + (a1 == a2));\n        System.out.println(\"a1.equals(a2) \" + (a1.equals(a2)));\n\n        String s1 = \"a\";\n        String s2 = \"a\";\n\n        System.out.println(\"s1 hashcode = \"+(s1.hashCode()));\n        System.out.println(\"s2 hashcode = \"+(s2.hashCode()));\n        System.out.println(\"s1 == s2 \" + (s1 == s2));\n        System.out.println(\"s1.equals(s2) \" + (s1.equals(s2)));\n```\n\n结果：\n\n```shell\na1 hashcode = 97\na2 hashcode = 97\na1 == a2 false\na1.equals(a2) true\ns1 hashcode = 97\ns2 hashcode = 97\ns1 == s2 true\ns1.equals(s2) true\n```\n\n**注意 a1,a2,s1,s2 这个四个对象的 hashcode 是相同的，至于为什么是 97，按照上面的算法很容易就看出来了**，所以 hashcode 不一定是一长串内容，有时候可能很简单。\n\na1.equals(a2) 和 s1.equals(s2) 的结果没有什么好说的，这里看一下 **==** 比较的差异从何而来。\n\n这里首先看 s1 和 s2 两个不同的引用，但是 ”a\" 在内存中的地址是唯一的，因此他们其实是指向了同一块内存区域，也就是这两个指针是相等的。因此 s1 == s2 结果为 true 。再看一下 a1 和 a2 ，同样的内容 a 发生了什么呢？看一下 String.valueOf() 的实现。\n\n```java\n    public static String valueOf(char c) {\n        char data[] = {c};\n        return new String(data, true);\n    }\n```\n可以看到这是完全返回了一个新的对象，因此 a1 和 a2 这两个引用完全指向了不同的对象。因此 a1 == a2 的结果就必然为 false 了。\n\n**其实，由于 String 是 final 的，因此关于 String 的所有操作都会创建新对象，== 的比较结果必然是 false**\n\n\n\n\n\n\n\n\n\n\n","tags":["Java"]},{"title":"漫长的岁月","url":"%2F2020%2F02%2F07%2F%E6%BC%AB%E9%95%BF%E7%9A%84%E5%B2%81%E6%9C%88%2F","content":"\n\n\n<img src=\"漫长的岁月/dlrb.jpeg\" width =60% style=\"border-radius:10px;\" />\n\n**这是一段漫长的岁月，一段特殊的岁月**\n\n<!--more-->\n\n## 三月\n\n### 2020 年 3 月 14 日 晴天 星期六\n\n今天是个好天气，天特别的蓝，窗外的阳光特别的温暖。\n\n<img src=\"漫长的岁月/0314/1.jpg\" width=60% style=\"border-radius:10px;\"/>\n\n连续一个多月的远程办公，已经让我忘记了周末该有的样子。\n\n<img src=\"漫长的岁月/0314/2.jpg\" width=60% style=\"border-radius:10px;\"/>\n\n趁着这样的一个日子，出来转转。\n\n<img src=\"漫长的岁月/0314/3.jpg\" width=60% style=\"border-radius:10px;\"/>\n\n一直想去远方看风景，看人文景观，原来一直想看的风景就在身边。\n\n<img src=\"漫长的岁月/0314/4.jpg\" width=60% style=\"border-radius:10px;\"/>\n\n等春天真的来了，一定要来这里好好晒一次太阳\n\n<img src=\"漫长的岁月/0314/5.jpg\" width=60% style=\"border-radius:10px;\"/>\n\n这座城市的天空，似乎很低，有似乎很高。\n\n### 2020 年 3 月 11 日 晴天 星期三\n\n趁着出去买菜的空档，发现小区里的理发店开张了。\n\n终于理发了，感觉一下子从脑袋上减掉了好几斤肉，走路都有精神了。\n\n2004 年的时候，我上初二，理发 5 元一次，包括洗剪吹。\n现在，理发 50 一次，也只包括洗剪吹而已。\n\n2006 年的时候，我上高二，袋装方便面 1 元一袋，桶装没怎么吃过，不太记得。现在，袋装方便面也就 2 元一袋，桶装的老坛酸菜面加蛋的也就 5 元一桶。\n\n将近 15 年左右的时间，食物的涨价似乎并不明显，但服务业涨价就厉害了，有着 10 倍之多。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["诗与远方"]},{"title":"ReLearn C++","url":"%2F2020%2F02%2F02%2FReLearn-C%2F","content":"\n\n\n## 类定义\n\nC++ 类的声明和定义通常是分开在两个不同的文件中，分别是 .h 头文件 和 .cpp 文件\n\n<!--more-->\n\n### 定义一个类\n\n - 头文件\n\n ```h\n// A.h\n\nclass A\n{\nprivate: //私有属性\n    int a; \n    void f1();\n\nprotected: //子类可见\n    int b;\n    void f2(int i);\n\npublic: //公开属性\n    int c = 2;\n    int f3(int j);\n    \n    A(int a, int b); // 构造函数\n    ～A(); //析构函数\n\n};\n\n ```\n- 头文件对应的 cpp 文件\n\n```c++\n// A.cpp\n\n/**\n * 实现构造函数\n */\nA::A(int a, int b): \na(a),\nb(b) {\n    \n}\n\n// 等价于\n\n/*\nA::A(int a, int b) {\n    this.a = a;\n    this.b = b;\n}\n*/\n\n/**\n * 实现析构函数\n */\nA::~A() {\n    \n}\n\n/**\n * 实现 f1 方法\n */\nvoid A::f1() {\n\n    \n}\n\n/**\n * 实现 f2 方法\n */\nvoid A::f2(int j) {\n    this.b = j\n}\n\n/**\n * 实现 f3 方法\n */\nint A::f3(int j) {\n    this.c = j\n}\n\n```"},{"title":"音视频入门","url":"%2F2020%2F02%2F01%2F%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9F%A5%E8%AF%86%2F","content":"\n## 音视频基础知识\n\n\n### 什么是视频\n\n<img src=\"音视频知识/video.gif\"/>\n\n<!--more-->\n\n#### 视频帧\n帧，是视频的一个基本概念，表示一张画面，如上面的翻页动画书中的一页，就是一帧。一个视频就是由许许多多帧组成的。\n\n#### 帧率\n帧率，即单位时间内帧的数量，单位为：帧/秒 或fps（frames per second）。如动画书中，一秒内包含多少张图片，图片越多，画面越顺滑，过渡越自然。\n帧率的一般以下几个典型值：\n24/25 fps：1秒 24/25 帧，一般的电影帧率。\n30/60 fps：1秒 30/60 帧，游戏的帧率，30帧可以接受，60帧会感觉更加流畅逼真。\n85 fps以上人眼基本无法察觉出来了，所以更高的帧率在视频里没有太大意义。\n\n#### 色彩空间\n\n- YUV\n\n早期的电视都是黑白的，即只有亮度值，即Y。有了彩色电视以后，加入了UV两种色度，形成现在的YUV，也叫YCbCr。\n\nY：亮度，就是灰度值。除了表示亮度信号外，还含有较多的绿色通道量。\n\nU：蓝色通道与亮度的差值。\n\nV：红色通道与亮度的差值。\n\n采用YUV有什么优势呢？\n\n>人眼对亮度敏感，对色度不敏感，因此减少部分UV的数据量，人眼却无法感知出来，这样可以通过压缩UV的分辨率，在不影响观感的前提下，减小视频的体积。\n\n- RGB和YUV的换算\n\n```s\nY = 0.299R ＋ 0.587G ＋ 0.114B \nU = －0.147R － 0.289G ＋ 0.436B\nV = 0.615R － 0.515G － 0.100B\n——————————————————\nR = Y ＋ 1.14V\nG = Y － 0.39U － 0.58V\nB = Y ＋ 2.03U\n```\n\n### 什么是音频\n\n音频数据的承载方式最常用的是脉冲编码调制，即PCM。\n\n#### 采样率和采样位数\n\n采样率，即采样的频率。\n采样率要大于原声波频率的2倍，人耳能听到的最高频率为20kHz，所以为了满足人耳的听觉要求，采样率至少为40kHz，通常为44.1kHz，更高的通常为48kHz。\n\n### 视频编码\n\n#### H264编码简介\nH264是目前最主流的视频编码标准，所以我们后续的文章中主要以该编码格式为基准。\n\nH264由ITU和MPEG共同定制，属于MPEG-4第十部分内容。\n\n#### 视频帧 \n\n视频是由一帧一帧画面构成的，但是在视频的数据中，并不是真正按照一帧一帧原始数据保存下来的（如果这样，压缩编码就没有意义了）。\nH264会根据一段时间内，画面的变化情况，选取一帧画面作为完整编码，下一帧只记录与上一帧完整数据的差别，是一个动态压缩的过程。\n在H264中，三种类型的帧数据分别为\nI帧：帧内编码帧。就是一个完整帧。\nP帧：前向预测编码帧。是一个非完整帧，通过参考前面的I帧或P帧生成。\nB帧：双向预测内插编码帧。参考前后图像帧编码生成。B帧依赖其前最近的一个I帧或P帧及其后最近的一个P帧。\n\n#### 音视频容器\n\n前面我们介绍的各种音视频的编码格式，没有一种是我们平时使用到的视频格式，比如：mp4、rmvb、avi、mkv、mov...\n没错，这些我们熟悉的视频格式，其实是包裹了音视频编码数据的容器，用来把以特定编码标准编码的视频流和音频流混在一起，成为一个文件。\n例如：mp4支持H264、H265等视频编码和AAC、MP3等音频编码\n\n> 以上就是 音视频相关的一些概念和术语的简单了解，后续如果有更多奇怪的支持增加了，会持续补充。\n\n - [ ] 视频旁路 sei 插帧技术\n\n\n## 音视频硬解码流程：封装基础解码框架\n\n>主要简介Android使用硬解码API实现硬解码的流程，包含MediaCodec输入输出缓冲、MediaCodec解码流程、解码代码封装和讲解。\n\n**** \n\n参考链接及更多细节\n\n[【Android 音视频开发打怪升级：音视频硬解码篇】一、音视频基础知识](https://juejin.cn/post/6844903949451919368)","tags":["音视频"]},{"title":"ASM 匿名内部类 & Lambda 表达式的处理","url":"%2F2020%2F01%2F12%2FASM-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A4%84%E7%90%86%2F","content":"\n## 前言\n\n简单总结使用 ASM 时遇到匿名内部类时，如何对匿名内部类（一般来说接口）的方法实现插桩。\n\n<!--more-->\n\n## 痛点\n\n通过之前的[当 Java 字节码遇到 ASM](https://zhuanlan.zhihu.com/p/102327062)一文，对如何使用 ASM 已经有了初步的了解。这里再来看一种比较特殊的情况，当遇到匿名内部类时，如何确定 hack 结点。\n\n### 接口作为匿名内部类实现\n\n\n\n<details>\n<summary>\n  接口 Callback\n</summary>\n\n\n\n```java\npackage com.asm.internal;\n\nimport com.asm.Music;\n\npublic interface Callback {\n\n    void noParams();\n\n    void withParams(int a, Music music);\n}\n\n```\n</details>\n\nWithAnonymousClass.java \n \n```java\n\npublic class WithAnonymousClass {\n\n    public String name = \"with\";\n\n    public void justCallback(World world) {\n\n        world.setCallback(new Callback() {\n            @Override\n            public void noParams() {\n                System.out.println(\"红桃四\");\n            }\n\n            @Override\n            public void withParams(int a, Music music) {\n                System.out.println(\"a==\" + a + \" music is \" + music);\n            } \n        });\n        System.out.println(\"call back\");\n    }\n\n    public void foo(int a) {\n        System.out.println(\"foo method\");\n    }\n}\n```\nWithAnonymousClass 内部 justCallback 方法，通过匿名内部类的方法实现了这个接口，假设现在需要在 noParams() 和 withParams() 内实现插桩，该怎么办呢？回看一下上一篇中对方法的插桩。\n\n<details>\n<summary>\n  visitMethod 方法 \n</summary>\n\n```java\n    @Override\n    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n        \n\n        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n\n        if (name.equals(\"run\")) {\n            mv = new MyMethodVisitor(Opcodes.ASM6, mv);\n        }\n\n        if (name.equals(\"getValue\")) {\n            mv = new MyMethodVisitorWithReturn(Opcodes.ASM6, mv);\n        }\n\n        return mv;\n    }\n```\n</details>\n\n在 visitMethod 方法里是根据方法名确定 hack 结点的，那么对于匿名内部类这样的方法可行吗？这里首先从 ClassVisitor 的 visitMethod 开始，看看是否可以直接访问这些方法。\n\n```java\npublic class WithAnonymousClassVisitor extends ClassVisitor {\n    private static final String TAG = \"WithAnonymous\";\n\n\n    @Override\n    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n        super.visit(version, access, name, signature, superName, interfaces);\n        Log.d(TAG, \"visit() called with: version = [\" + version + \"], access = [\" + access + \"], name = [\" + name + \"], signature = [\" + signature + \"], superName = [\" + superName + \"], interfaces = [\" + interfaces + \"]\");\n    }\n\n    @Override\n    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n        Log.d(TAG, \"visitMethod() called with: access = [\" + access + \"], name = [\" + name + \"], desc = [\" + desc + \"], signature = [\" + signature + \"], exceptions = [\" + exceptions + \"]\");\n        return super.visitMethod(access, name, desc, signature, exceptions);\n    }\n\n    @Override\n    public void visitEnd() {\n        Log.d(TAG, \"visitEnd() called\");\n        super.visitEnd();\n    }\n}\n```\n我们可看一下输出日志：\n\n```shell\nWithAnonymous ==> visit() called with: version = [52], access = [33], name = [com/asm/WithAnonymousClass], signature = [null], superName = [java/lang/Object], interfaces = [[Ljava.lang.String;@2ff4acd0]\n\nWithAnonymous ==> visitMethod() called with: access = [1], name = [<init>], desc = [()V], signature = [null], exceptions = [null]\n\nWithAnonymous ==> visitMethod() called with: access = [1], name = [justCallback], desc = [(Lcom/asm/internal/World;)V], signature = [null], exceptions = [null]\n\nWithAnonymous ==> visitMethod() called with: access = [1], name = [foo], desc = [(I)V], signature = [null], exceptions = [null]\n\nWithAnonymous ==> visitEnd() called\n```\n\n可以看到，visitMethod 只访问了 WithAnonymousClass 内的方法（包括默认的构造函数），并没有访问到 Callback 的匿名实现类当中的方法。\n这里为什么方位不到匿名内部类的方法呢？道理其实很简单，举个简单的例子就明白了。\n\n#### 匿名内部类的编译结果\n\n```java\npublic class Main {\n  public static void main(String[] args) {\n      Thread thread = new Thread(new Runnable() {\n          @Override\n          public void run() {\n              // \n          }\n      });\n  }\n}\n```\n上面这个类很简，Thread 需要一个 Runnable 接口的实现，这里采用了匿名内部类的方式。执行命令\n\n```shell\njavac Main.java\n```\n编译完成后，可以看到\n\n```shell\n-<%>- ls\nMain$1.class Main.class   Main.java\n```\n除了预期的 Main.class 之外，还生成了一个额外的 Main$1.class 的 class。这就是 java 编译器的规则，对当前类内部的匿名内部类会生成单独的一个类。如果有多个匿名类，会依次按 $n 生成多个类。当然，如果当前类直接 implements 改接口，就没有这种现象了。关于这一点，我们从类的 class 文件也可以看到。\n\n```class\npublic class com/asm/WithAnonymousClass {\n\n  // compiled from: WithAnonymousClass.java\n  // access flags 0x0\n  INNERCLASS com/asm/WithAnonymousClass$1 null null\n\n  // access flags 0x1\n  public Ljava/lang/String; name\n\n  // access flags 0x1\n  public <init>()V\n   L0\n    LINENUMBER 6 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.<init> ()V\n    ...\n}\n```\n\n#### 解决方法\n\n好了，找到了问题的根源，我们就可以从内部类开始找出口。ClassVisitor 提供了 visitInnerClass 可以用于访问内部类。\n\n```java\n    @Override\n    public void visitInnerClass(String name, String outerName, String innerName, int access) {\n        Log.d(TAG, \"visitInnerClass() called with: name = [\" + name + \"], outerName = [\" + outerName + \"], innerName = [\" + innerName + \"], access = [\" + access + \"]\");\n        super.visitInnerClass(name, outerName, innerName, access);\n    }\n```\n产生输出：\n\n```shell\nWithAnonymous ==> visitInnerClass() called with: name = [com/asm/WithAnonymousClass$1], outerName = [null], innerName = [null], access = [0]\n```\n\n可以看到 \n\n```java\n com/asm/WithAnonymousClass$1\n```\n\n这个类名和 javac 编译的结果是一致的（有兴趣同学可以自己验证一下，这里就不详细展开了）。 这个类就我们代码中 Callback 对应的匿名内部类吗？刚才也说了，如果有多个匿名内部的实现，会生成多个这样的 \n\n```java\ncom/asm/WithAnonymousClass$n\n```\n\n这里就产生了一个有意思的问题，**如何确定一个类是否实现了某个接口或某些接口**。好在这个问题已经被前人解决了，我们再一次可以站在巨人的肩膀上继续前行 😁😁。\n\n\n<details>\n<summary>\n  判断某类是否实现了指定接口集合\n</summary>\n\n```java\npublic class SpecifiedInterfaceImplementionChecked {\n\n    /**\n     * 判断是否实现了指定接口\n     *\n     * @param reader       class reader\n     * @param interfaceSet interface collection\n     * @return check result\n     */\n    public static boolean hasImplSpecifiedInterfaces(ClassReader reader, Set<String> interfaceSet) {\n        if (isObject(reader.getClassName())) {\n            return false;\n        }\n        try {\n            if (containedTargetInterface(reader.getInterfaces(), interfaceSet)) {\n                return true;\n            } else {\n                ClassReader parent = new ClassReader(reader.getSuperName());\n                return hasImplSpecifiedInterfaces(parent, interfaceSet);\n            }\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    /**\n     * 检查当前类是 Object 类型\n     *\n     * @param className class name\n     * @return checked result\n     */\n    private static boolean isObject(String className) {\n        return \"java/lang/Object\".equals(className);\n    }\n\n    /**\n     * 检查接口及其父接口是否实现了目标接口\n     *\n     * @param interfaceList 待检查接口\n     * @param interfaceSet  目标接口\n     * @return checked result\n     * @throws IOException exp\n     */\n    private static boolean containedTargetInterface(String[] interfaceList, Set<String> interfaceSet) throws IOException {\n        for (String inter : interfaceList) {\n            if (interfaceSet.contains(inter)) {\n                return true;\n            } else {\n                ClassReader reader = new ClassReader(inter);\n                if (containedTargetInterface(reader.getInterfaces(), interfaceSet)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n}\n\n```\n</details>\n\n好了，一旦可以确定某个匿名内部类是否实现了某个接口，那么后续流程，就又回到了我们熟悉得节奏。\n\n```java\n    @Override\n    public void visitInnerClass(String name, String outerName, String innerName, int access) {\n        \n        super.visitInnerClass(name, outerName, innerName, access);\n\n        HashSet<String> set = new HashSet<>();\n        set.add(\"com/asm/internal/Callback\");\n        try {\n            ClassReader reader = new ClassReader(name);\n            if (SpecifiedInterfaceImplementionChecked.hasImplSpecifiedInterfaces(reader, set)) {\n                Log.d(TAG, \"visitInnerClass: find it\");\n\n                ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n                ClassVisitor visitor = new InterfaceVisitor(writer);\n                reader.accept(visitor, ClassReader.EXPAND_FRAMES);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n当这个匿名内部类确定是实现了我们期望的接口时，就可以把他当做普通类来处理了，这样的流程就是上一篇讲得内容。我们看一下 InterfaceVisitor\n\n```java\npublic class InterfaceVisitor extends ClassVisitor {\n    private static final String TAG = \"InterfaceVisitor\";\n    public InterfaceVisitor(ClassVisitor cv) {\n        super(Opcodes.ASM6, cv);\n    }\n\n    @Override\n    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n        Log.d(TAG, \"visitMethod() called with: access = [\" + access + \"], name = [\" + name + \"], desc = [\" + desc + \"], signature = [\" + signature + \"], exceptions = [\" + exceptions + \"]\");\n        return super.visitMethod(access, name, desc, signature, exceptions);\n    }\n}\n```\n\n输出：\n\n```shell\nInterfaceVisitor ==> visitMethod() called with: access = [0], name = [<init>], desc = [(Lcom/asm/WithAnonymousClass;)V], signature = [null], exceptions = [null]\n\nInterfaceVisitor ==> visitMethod() called with: access = [1], name = [noParams], desc = [()V], signature = [null], exceptions = [null]\n\nInterfaceVisitor ==> visitMethod() called with: access = [1], name = [withParams], desc = [(ILcom/asm/Music;)V], signature = [null], exceptions = [null]\n```\n\n可以看到，现在 ClassVistor 的 visitMethod 方法已经可以正常访问到接口中的方法了（也就是我们之前匿名内部类当中的方法），这样这个 hack 结点就获取到了，就可以为所欲为了。\n\n\n### Lambda 表达式\n\n再来看一种似乎很特殊的情况，Lambda 表达式。经历过曾经的 RxJava 和现在的 Kotlin 的洗礼 ，我们的代码中一定有很多 Lambad 表达式的实现。比如\n\n```java \n    public void justRun() {\n        Thread thread = new Thread(() -> System.out.println(\"just run\"));\n    }\n\n    public void justCallable() {\n        // 只用举例，无实际意义\n        FutureTask futureTask = new FutureTask(() -> \"null\");\n    }\n```\n\nLambda 表达式的写法，你可以当做是对匿名内部类的简化。那么这些方法结点的获取是不是和匿名内部类一样呢？我们可以先看一下日志。\n\n```shell\nWithAnonymous ==> visitMethod() called with: access = [1], name = [<init>], desc = [()V], signature = [null], exceptions = [null]\n\nWithAnonymous ==> visitMethod() called with: access = [1], name = [justRun], desc = [()V], signature = [null], exceptions = [null]\n\nWithAnonymous ==> visitMethod() called with: access = [1], name = [justCallable], desc = [()V], signature = [null], exceptions = [null]\n\nWithAnonymous ==> visitMethod() called with: access = [1], name = [justCallback], desc = [(Lcom/asm/internal/World;)V], signature = [null], exceptions = [null]\n\nWithAnonymous ==> visitMethod() called with: access = [1], name = [foo], desc = [(I)V], signature = [null], exceptions = [null]\n\nWithAnonymous ==> visitMethod() called with: access = [4106], name = [lambda$justCallable$1], desc = [()Ljava/lang/Object;], signature = [null], exceptions = [[Ljava.lang.String;@3a71f4dd]\n\nWithAnonymous ==> visitMethod() called with: access = [4106], name = [lambda$justRun$0], desc = [()V], signature = [null], exceptions = [null]\n\nWithAnonymous ==> visitEnd() called\n```\n\n哈哈，原来lambda 表达式的是可以直接被访问到的，因此我们就可以通过方法 desc 确定要进行插桩的方法了。\n\n## 总结\n\n通过对 ASM 使用过程中，接口作为匿名内部类使用时，其方法是无法直接通过外部类（这里相对于匿名内部类）直接访问到的，因此需要通过 visitInnerClass 方法找到并确定匿名类是否实现了特定的接口，然后把这个 javac 生成的中间类当做一个普通的类，按照常规流程再次通过 ClassVistor 的一系列 API 来确定要进行插桩的结点。\n\n\n\n\n\n\n \n\n","tags":["ASM"]},{"title":"Gradle Transform + ASM 探索","url":"%2F2020%2F01%2F04%2FGradle-Transform-ASM-%E6%8E%A2%E7%B4%A2%2F","content":"\n\n## 前言\n\n\n\n使用 Gradle Transform + ASM 实现代码插桩的使用已经非常普遍。本文试图探索如何更加快速简洁的利用 Transform 实现代码插桩，并尝试实现\n\n- 通过注解对任意类当中所有的方法**实现计算方法耗时**的插桩\n- 通过配置实现对任意类（主要是针对第三方库）当中指定方法的**实现计算方法耗时**的插桩\n- 对工程中所有的点击事件进行插桩，方便埋点或确定代码位置\n- ......\n\n<!--more-->\n\n## Transform + ASM 能做什么\n\n简单来说就是利用 AGP 提供的 Transform 接口，在应用打包的流程中，对 java/kotlin 编译生成的 class 文件进行二次写操作，插入一些自定义的逻辑。这些逻辑一般是重复且有规律的，并且大概率和业务逻辑无关的。\n\n一些统计应用数据的 SDK，会在页面展现和退出的生命周期函数里，在应用编译期插入统计相关的逻辑，统计页面展现数据；这种对开发者非常透明的实现，一方面接入成本非常低，另一方面也减少了三方库对现有工程的显示侵入，尽可能的减少了耦合。\n\n也有常见的代码耗时统计的实现，在方法体开始的时候，利用 System.currentTimeMillis() 方法记录开始时间，在方法返回之前，进行统计。当然，这样的功能早在 2013 年已经由[JakeWharton](https://github.com/JakeWharton) 大神用 aspectj的方案 [实现过了](https://github.com/JakeWharton/hugo)。\n\n## Transform 基本流程\n\n关于如何创建一个基于的 Gradle 插件项目，以及如何在 Plugin 中注册的具体实现就不展开了，网上可以找到好多这种教程，这里从 Transform 的实现说起。\n\n<img src=\"Gradle-Transform-ASM-探索/transform.png\">\n\n可以看到实现一个自定义的 Transform 需要做的事情还是非常有规律的。继承 Transform 这个抽象类，覆写这几个方法一般来说就够用了。每个方法具体的功能从方法名就可以了解了。\n\n- getName 这个transform 的名称，一个应用内可以由多个 Transform，因此需要一个名称标记，方便后面调试。\n- getInputTypes 输入类型，ContentType 是一个枚举，这个输入类型是什么意思呢？其实看一下这个枚举的定义你就明白了。\n\n<details>\n<summary>\nContentType 点击展开\n</summary>\n\n```java\nenum DefaultContentType implements ContentType {\n        /**\n         * The content is compiled Java code. This can be in a Jar file or in a folder. If\n         * in a folder, it is expected to in sub-folders matching package names.\n         */\n        CLASSES(0x01),\n\n        /** The content is standard Java resources. */\n        RESOURCES(0x02);\n\n        private final int value;\n\n        DefaultContentType(int value) {\n            this.value = value;\n        }\n\n        @Override\n        public int getValue() {\n            return value;\n        }\n    }\n```\n</details>\n\n**这里可以注意一下，使用 Transform 我们还可以对 resources 文件做处理**，你应该听说过或者用过 [AndResGuard](https://github.com/shwenzhang/AndResGuard) 来混淆资源文件吧，看到这里你是不是觉得自己也有点思路了呢。\n\n- isIncremental 是否支持增量编译。对于一个稍微庞大点儿的项目，Gradle 现有的构建流程其实已经很耗时了，对于耗时这件事归根结底唯一的解决方法就是并行和缓存，但是 Gradle 的很多任务是有依赖关系的，所以并行在很大程度上受到了限制。因此，缓存就成为了唯一可以去突破的方向。**一个自定义的 Transform 在可能的情况，支持增量编译，可以节省报一些编译时间和资源**，当然，由于 Transform 要实现功能的限制，必须每一次全量编译，那么一定要记得删除上一次编译编译的产物，以免产生 bug。关于如何实现这些细节，后面会有介绍。\n\n- getScopes 定义这个 Transform 要处理那些输入文件。ScopeType 同样是一个枚举，看一下他的定义。\n\n\n<details>\n<summary>\nScopeType 点击展开\n</summary>\n\n\n```java\n enum Scope implements ScopeType {\n        /** Only the project (module) content */\n        PROJECT(0x01),\n        /** Only the sub-projects (other modules) */\n        SUB_PROJECTS(0x04),\n        /** Only the external libraries */\n        EXTERNAL_LIBRARIES(0x10),\n        /** Code that is being tested by the current variant, including dependencies */\n        TESTED_CODE(0x20),\n        /** Local or remote dependencies that are provided-only */\n        PROVIDED_ONLY(0x40),\n\n        /**\n         * Only the project's local dependencies (local jars)\n         *\n         * @deprecated local dependencies are now processed as {@link #EXTERNAL_LIBRARIES}\n         */\n        @Deprecated\n        PROJECT_LOCAL_DEPS(0x02),\n        /**\n         * Only the sub-projects's local dependencies (local jars).\n         *\n         * @deprecated local dependencies are now processed as {@link #EXTERNAL_LIBRARIES}\n         */\n        @Deprecated\n        SUB_PROJECTS_LOCAL_DEPS(0x08);\n\n        private final int value;\n\n        Scope(int value) {\n            this.value = value;\n        }\n\n        @Override\n        public int getValue() {\n            return value;\n        }\n    }\n```\n</details>\n\n可以预知，这个范围定义的越小，我们的 Transform 需要处理的输入就越少，执行也就越快。\n\n- transform(transformInvocation: TransformInvocation?) 进行输入内容的处理。\n\n这里需要再次强调一点：**一个工程内会有多个 Transform，你定义的 Transform 在处理的是上一个 Transform 经过处理的输出，而经过你处理的输出，会由下一个 Transform 进行处理**。所有的 transform 任务一般都在 app/build/intermediates/transform/ 这个目录下可以看到。\n\n\n### transform() 深入\n\ntransform()方法的参数 TransformInvocation 是一个接口，提供了一些关于输入的一些基本信息。利用这些信息我们就可以获得编译流程中的 class 文件进行操作。\n\n<img src=\"Gradle-Transform-ASM-探索/transforms.png\" width=40%>\n\n从上图可以看到，transform 处理输入的思路还是很简单的，就是从TransformInvocation 获取到总的输入后，分别按照 class目录 和 jar文件 集合的方式进行遍历处理。（这里简单讨论普遍情况，当然 TransformInvocation 接口还提供了 getReferencedInputs，getSecondaryInputs 这些接口，让使用者处理一些特殊的输入，上图并没有体现，暂时不展开讨论）\n\ntransform 的核心难点有以下几个点：\n\n- **正确、高效的进行文件目录、jar 文件的解压、class 文件 IO 流的处理，保证在这个过程中不丢失文件和错误的写入**\n- **高效的找到要插桩的结点，过滤掉无效的 class**\n- **支持增量编译**\n\n\n\n## 实践\n\n上面说了一些流程和概念，下面就通过一个实例 (参考自 [Koala](https://github.com/lijiankun24/Koala)) 来具体看一下一个基于注解，在 transform 任务执行的过程中通过 ASM 插入统计方法耗时、参数、输出的实现。非常感谢 [Koala](https://github.com/lijiankun24/Koala)，感谢 [lijiankun24](https://github.com/lijiankun24) 的开源。\n\n\n### 效果\n\n为了方便后期叙述，这里首先看一下使用方式和最终效果。\n\n#### 添加注解\n\n我们在 MainActivity 中的部分方法添加注解\n\n<details>\n<summary>点击展开详细</summary>\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    @Cat\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        test()\n        test2(\"a\",100)\n        test3()\n        test4()\n        val result = Util.dp2Px(10)\n    }\n\n    @Cat\n    private fun test() {\n        println(\"just test\")\n    }\n\n    @Cat\n    private fun test2(para1: String, para2: Int): Int {\n        return 0\n    }\n\n    @Cat\n    private fun test3(): View {\n        return TextView(this)\n    }\n\n    private fun test4(){\n        println(\"nothing\")\n    }\n}\n```\n</details>\n\nMainActivity 中除了 test4()之外的所有方法，都打上了 @Cat 注解，并且所有方法都会被调用。\n\n#### 输出日志\n\n<details>\n<summary>点击展开详细</summary>\n\n```shell\n2020-01-04 11:32:13.784 E: ┌───────────────────────────────────------───────────────────────────────────------\n2020-01-04 11:32:13.784 E: │ class's name:       com/engineer/android/myapplication/MainActivity\n2020-01-04 11:32:13.784 E: │ method's name:      test\n2020-01-04 11:32:13.785 E: │ method's arguments: []\n2020-01-04 11:32:13.785 E: │ method's result:    null\n2020-01-04 11:32:13.791 E: │ method cost time:   1ms\n2020-01-04 11:32:13.791 E: └───────────────────────────────────------───────────────────────────────────------\n2020-01-04 11:32:13.791 E: ┌───────────────────────────────────------───────────────────────────────────------\n2020-01-04 11:32:13.791 E: │ class's name:       com/engineer/android/myapplication/MainActivity\n2020-01-04 11:32:13.792 E: │ method's name:      test2\n2020-01-04 11:32:13.792 E: │ method's arguments: [a, 100]\n2020-01-04 11:32:13.792 E: │ method's result:    0\n2020-01-04 11:32:13.793 E: │ method cost time:   0ms\n2020-01-04 11:32:13.793 E: └───────────────────────────────────------───────────────────────────────────------\n2020-01-04 11:32:13.794 E: ┌───────────────────────────────────------───────────────────────────────────------\n2020-01-04 11:32:13.795 E: │ class's name:       com/engineer/android/myapplication/MainActivity\n2020-01-04 11:32:13.795 E: │ method's name:      test3\n2020-01-04 11:32:13.796 E: │ method's arguments: []\n2020-01-04 11:32:13.796 E: │ method's result:    android.widget.TextView{8a9397d V.ED..... ......ID 0,0-0,0}\n2020-01-04 11:32:13.796 E: │ method cost time:   1ms\n2020-01-04 11:32:13.796 E: └───────────────────────────────────------───────────────────────────────────------\n2020-01-04 11:32:13.797 E: ┌───────────────────────────────────------───────────────────────────────────------\n2020-01-04 11:32:13.797 E: │ class's name:       com/engineer/android/myapplication/MainActivity\n2020-01-04 11:32:13.797 E: │ method's name:      onCreate\n2020-01-04 11:32:13.798 E: │ method's arguments: [null]\n2020-01-04 11:32:13.798 E: │ method's result:    null\n2020-01-04 11:32:13.798 E: │ method cost time:   156ms\n2020-01-04 11:32:13.798 E: └───────────────────────────────────------───────────────────────────────────------\n```\n\n</details>\n\n可以看到，日志输出了除 test4() 方法之外所有方法的方法耗时、方法参数、方法名称、方法返回值等信息，下面就来看看实现细节。\n\n### 实现细节\n\n##### 主动调用\n\n首先，对于一个上述的功能，如果用我们直接手写代码的方式，应该是很简单的。\n\n打印的日志有一些方法的信息，因此需要一个类来承载这些信息。\n\n- MethodInfo\n\n```kotlin\ndata class MethodInfo(\n    var className: String = \"\",\n    var methodName: String = \"\",\n    var result: Any? = \"\",\n    var time: Long = 0,\n    var params: ArrayList<Any?> = ArrayList()\n)\n```\n\n按照常规思路，我们需要在方法开始的时候，记录一下开始时间，方法 return 之前再次记录一下时间，然后计算出耗时。\n\n- MethodManager\n\n```kotlin\nobject MethodManager {\n\n    private val methodWareHouse = ArrayList<MethodInfo>(1024)\n\n    @JvmStatic\n    fun start(): Int {\n        methodWareHouse.add(MethodInfo())\n        return methodWareHouse.size - 1\n    }\n\n    @JvmStatic\n    fun end(result: Any?, className: String, methodName: String, startTime: Long, id: Int) {\n        val method = methodWareHouse[id]\n        method.className = className\n        method.methodName = methodName\n        method.result = result\n        method.time = System.currentTimeMillis() - startTime\n        BeautyLog.printMethodInfo(method)\n    }\n\n}\n```\n\n这里定义了两个方法 start 和 end ，顾名思义就是在方法开始和结束的时候调用，并通过参数传递一些关键信息，最后打印这些信息。\n\n这样我们可以在任何一个方法中调用这些方法\n\n```kotlin\n    fun foo(){\n        val index =MethodManager.start()\n        val start = System.currentTimeMillis()\n        \n        // some thing foo do\n        \n        MethodManager.end(\"\",this.localClassName,\"foo\",start,index)\n    }\n```\n\n诚然这样的代码写起来很简单，但是一方面这些代码和 foo 方法本来要做的事情是没有关系的，如果为了单次测试方法耗时加上去，有点丑陋；再有就是如果有多个方法需要检测耗时，需要把这样的代码写很多次。因此，便有了通过 Transform + ASM 实现代码插桩的需求。\n\n##### 插桩实现\n\n在一个方法内，我们自己写上述代码很简单，代开 IDE 找到对应的类文件，定位到要计算耗时的方法，在方法体开始和结束之前插入代码。但是，对于编译器来说，这些没有规律的事情是非常麻烦的。因此，为了方便，我们通过定义注解的方式，方便编译器在代码编译阶段可以快速定位要插桩的位置。\n\n这里定义了一个注解 Cat, 为啥取名 Cat，因为猫很萌啊。\n\n<img src=\"Gradle-Transform-ASM-探索/cat.jpeg\" width=40%>\n\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.CLASS)\npublic @interface Cat {\n}\n```\n\n按照上图 transform(transformInvocation: TransformInvocation?)  处理输入流程的流程，我们可以对所有的 class 文件进行处理。\n\n这里以处理 directoryInputs 为例\n\n```kotlin\ninput.directoryInputs.forEach { directoryInput ->\n                if (directoryInput.file.isDirectory) {\n                    FileUtils.getAllFiles(directoryInput.file).forEach {\n                        val file = it\n                        val name = file.name\n                        println(\"directory\")\n                        println(\"name ==$name\")\n                        if (name.endsWith(\".class\") && name != (\"R.class\")\n                            && !name.startsWith(\"R\\$\") && name != (\"BuildConfig.class\")\n                        ) {\n\n                            val reader = ClassReader(file.readBytes())\n                            val writer = ClassWriter(reader, ClassWriter.COMPUTE_MAXS)\n                            val visitor = CatClassVisitor(writer)\n                            reader.accept(visitor, ClassReader.EXPAND_FRAMES)\n\n                            val code = writer.toByteArray()\n                            val classPath = file.parentFile.absolutePath + File.separator + name\n                            val fos = FileOutputStream(classPath)\n                            fos.write(code)\n                            fos.close()\n                        }\n                    }\n                }\n\n                val dest = transformInvocation.outputProvider?.getContentLocation(\n                    directoryInput.name,\n                    directoryInput.contentTypes,\n                    directoryInput.scopes,\n                    Format.DIRECTORY\n                )\n\n\n                FileUtils.copyDirectoryToDirectory(directoryInput.file, dest)\n            }\n```\n\n这里的操作很简单，就是遍历所有的 class 文件，对所有符合条件的 Class 通过 ASM 提供的接口进行处理，通过访问者模式，提供一个自定义的 ClassVisitor 即可。这里我们的自定义 ClassVisitor 就是 CatClassVisitor,在 CatClassVisitor 内部的 visitMethod 实现中再次使用访问者的模式，返回一个自定义的 CatMethodVisitor，在其内部我们会根据方法注解，确定当前方法是否需要进行插桩。\n\n```kotlin\n  override fun visitAnnotation(desc: String, visible: Boolean): AnnotationVisitor {\n        // 当前方法的注解，是否是我们定义的注解。\n        if (Constants.method_annotation == desc) {\n            isInjected = true\n        }\n        return super.visitAnnotation(desc, visible)\n    }\n\n  override fun onMethodEnter() {\n        if (isInjected) {\n            \n            methodId = newLocal(Type.INT_TYPE)\n            mv.visitMethodInsn(\n                Opcodes.INVOKESTATIC,\n                Constants.method_manager,\n                \"start\",\n                \"()I\",\n                false\n            )\n            mv.visitIntInsn(Opcodes.ISTORE, methodId)\n\n            ... more details ...\n        }\n    }\n\n  override fun onMethodExit(opcode: Int) {\n        if (isInjected) {\n\n            ... other details ...\n\n            mv.visitMethodInsn(\n                Opcodes.INVOKESTATIC,\n                Constants.method_manager,\n                \"end\",\n                \"(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;JI)V\",\n                false\n            )\n        }\n    }\n```\n可以看到这样我们就确定了要进行代码插桩的位置，关于 ASM 代码插桩的具体细节已在[当 Java 字节码遇到 ASM](https://zhuanlan.zhihu.com/p/102327062) 有过介绍，这里不再展开。此处具体实现可以[查看源码](https://github.com/REBOOTERS/AndroidAnimationExercise/tree/master/buildSrc/src/main/kotlin/com/engineer/plugin/transforms/cat)。\n\n当然，我们还需要处理输入为 jarInputs 的场景。在组件化开发的时候，很多时候，我们是通过依赖 aar 包的方式，依赖其他小伙伴提供的业务组件或基础组件。或者是当我们依赖第三方库的时候，其实也是在依赖 aar。这时候，如果缺少了对 jarInputs 的处理，会导致插桩功能的缺失。但是从上面的流程图可以看到，对 jarInputs 的处理只是多了解压缩的过程，后续还是对 class 文件的遍历写操作。\n\n\n\n##### 增量编译\n\n说到 Transform 必须要谈的一个点就是增量编译，其实关于增量编译的实现，通过查看 AGP 自带的几个 Transform 可以看到其实很简单。\n\n```kotlin\nif (transformInvocation.isIncremental) {\n                    when (jarInput.status ?: Status.NOTCHANGED) {\n                        Status.NOTCHANGED -> {\n                        }\n                        Status.ADDED, Status.CHANGED -> transformJar(\n                            function,\n                            inputJar,\n                            outputJar\n                        )\n                        Status.REMOVED -> FileUtils.delete(outputJar)\n                    }\n                } else {\n                    transformJar(function, inputJar, outputJar)\n                }\n```\n\n所有的输入都是带状态的，根据这些状态做不同的处理就好了。当然，也可以根据前面提到的 getSecondaryInputs 提供的输入进行处理支持增量编译。\n\n#### 简化 Transform 流程\n\n回顾上面提到的 transform 处理流程及三个关键点，参考官方提供的 CustomClassTransform 我们可以抽象出一个更加通用的 Transform 基类。\n\n**默认支持 增量编译，处理文件 IO 的操作**\n```kotlin\n\nabstract class BaseTransform : Transform() {\n\n    // 将对 class 文件的 asm 操作，处理完之后的再次复制，抽象为一个 BiConsumer\n    abstract fun provideFunction(): BiConsumer<InputStream, OutputStream>?\n\n    // 默认的 class 过滤器，处理 .class 结尾的所有内容 （Maybe 可以扩展）\n    open fun classFilter(className: String): Boolean {\n        return className.endsWith(SdkConstants.DOT_CLASS)\n    }\n\n    // Transform 使能开关\n    open fun isEnabled() = true\n\n    ... else function ...\n\n    // 默认支持增量编译\n    override fun isIncremental(): Boolean {\n        return true\n    }\n   \n\n    override fun transform(transformInvocation: TransformInvocation?) {\n        super.transform(transformInvocation)\n\n        val function = provideFunction()\n\n        ......\n\n        if (transformInvocation.isIncremental.not()) {\n            outputProvider.deleteAll()\n        }\n\n        for (ti in transformInvocation.inputs) {\n            for (jarInput in ti.jarInputs) {\n                 ......\n                if (transformInvocation.isIncremental) {\n                    when (jarInput.status ?: Status.NOTCHANGED) {\n                        Status.NOTCHANGED -> {\n                        }\n                        Status.ADDED, Status.CHANGED -> transformJar(\n                            function,\n                            inputJar,\n                            outputJar\n                        )\n                        Status.REMOVED -> FileUtils.delete(outputJar)\n                    }\n                } else {\n                    transformJar(function, inputJar, outputJar)\n                }\n            }\n            for (di in ti.directoryInputs) {\n\n                ......\n                \n                if (transformInvocation.isIncremental) {\n                    for ((inputFile, value) in di.changedFiles) {\n\n                        ......\n\n                        transformFile(function, inputFile, out)\n\n                        ......\n                    }\n                } else {\n                    for (`in` in FileUtils.getAllFiles(inputDir)) {\n                        if (classFilter(`in`.name)) {\n                            val out =\n                                toOutputFile(outputDir, inputDir, `in`)\n                            transformFile(function, `in`, out)\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    @Throws(IOException::class)\n    open fun transformJar(\n        function: BiConsumer<InputStream, OutputStream>?,\n        inputJar: File,\n        outputJar: File\n    ) {\n        Files.createParentDirs(outputJar)\n        FileInputStream(inputJar).use { fis ->\n            ZipInputStream(fis).use { zis ->\n                FileOutputStream(outputJar).use { fos ->\n                    ZipOutputStream(fos).use { zos ->\n                        var entry = zis.nextEntry\n                        while (entry != null && isValidZipEntryName(entry)) {\n                            if (!entry.isDirectory && classFilter(entry.name)) {\n                                zos.putNextEntry(ZipEntry(entry.name))\n                                apply(function, zis, zos)\n                            } else { // Do not copy resources\n                            }\n                            entry = zis.nextEntry\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    @Throws(IOException::class)\n    open fun transformFile(\n        function: BiConsumer<InputStream, OutputStream>?,\n        inputFile: File,\n        outputFile: File\n    ) {\n        Files.createParentDirs(outputFile)\n        FileInputStream(inputFile).use { fis ->\n            FileOutputStream(outputFile).use { fos -> apply(function, fis, fos) }\n        }\n    }\n\n\n    @Throws(IOException::class)\n    open fun apply(\n        function: BiConsumer<InputStream, OutputStream>?,\n        `in`: InputStream,\n        out: OutputStream\n    ) {\n        try {\n            function?.accept(`in`, out)\n        } catch (e: UncheckedIOException) {\n            throw e.cause!!\n        }\n    }\n}\n\n```\n\n以上对 transform 处理流程中，文件 IO，增量编译的细节进行了封装处理。把对 class 的写操作和二次复制，统一为 InputStream 和 OutoutStream 对象的处理。\n\n\n## 使用注解实现类中所有方法的插桩\n\n前面我们通过定义注解 Cat 的方式，详细实现了一次方法耗时的插桩。但是这个注解的使用范围被限定在了方法上，如果我们想要对一个类里多个方法的耗时同时进行检测的时候，就比较繁琐了。因此，我们可以就这个注解简单升级一下，实现一个支持 Class 内所有方法耗时检测的插桩实现。\n\n### 注解定义 Tiger\n\n<img src=\"Gradle-Transform-ASM-探索/tiger.jpg\" width=40%>\n\n\nTiger 顾名思义，这里的实现就是在照猫画虎。\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.CLASS)\npublic @interface Tiger {\n}\n```\n\n### Transform 实现\n\n```kotlin\nclass TigerTransform : BaseTransform() {\n\n    override fun provideFunction(): BiConsumer<InputStream, OutputStream>? {\n        return BiConsumer { t, u ->\n            val reader = ClassReader(t)\n            val writer = ClassWriter(reader, ClassWriter.COMPUTE_MAXS)\n            val visitor = TigerClassVisitor(writer)\n            reader.accept(visitor, ClassReader.EXPAND_FRAMES)\n            val code = writer.toByteArray()\n            u.write(code)\n        }\n    }\n\n    override fun getName(): String {\n        return \"tiger\"\n    }\n}\n```\n\n通过直接继承刚才定义的 Transform 抽象类，我们可以把精力集中在如何处理 Class 文件的写入和输入上，也就是这里的 InputStream 和 OutputStream 的处理，直接和 ASM 的 ClassReader 以及 ClassWriter 接口交互。不必再关心增量编译，TransformInvocation 的输出和输入的 IO 这些内部细节了。\n\n我们看一下 TigerClassVisitor \n\n```kotlin\nclass TigerClassVisitor(classVisitor: ClassVisitor) : ClassVisitor(Opcodes.ASM6, classVisitor) {\n\n    private var needHook = false\n    private lateinit var mClassName: String\n\n    override fun visit(\n        version: Int, access: Int, name: String,\n        signature: String?, superName: String?, interfaces: Array<String>?\n    ) {\n        super.visit(version, access, name, signature, superName, interfaces)\n        println(\"hand class $name\")\n        mClassName = name\n    }\n\n    override fun visitAnnotation(desc: String?, visible: Boolean): AnnotationVisitor {\n        if (desc.equals(Constants.class_annotation)) {\n            println(\"find $desc ,start hook \")\n            needHook = true\n        }\n        return super.visitAnnotation(desc, visible)\n    }\n\n    override fun visitMethod(\n        access: Int,\n        name: String?,\n        desc: String?,\n        signature: String?,\n        exceptions: Array<out String>?\n    ): MethodVisitor {\n\n\n        var methodVisitor = super.visitMethod(access, name, desc, signature, exceptions)\n\n        if (needHook) {\n            .... hook visitor ...\n        }\n\n        return methodVisitor\n    }\n}\n```\n\n这里的关键就是 visitAnnotation 方法，在这个回调方法里，我们可以获取到当前 Class 的注解，而当这个 Class 的注解和我们定义的 Tiger 注解相等时，我们就可以对这个类当中的所有方法进行耗时检测代码的插桩了，在 visitMethod 方法内耗时代码的插桩，上面已经实现过了。\n\n\n我们可以到应用的 build 目录下查看插桩代码是否生效，比如 app/build/intermediates/transforms/tiger/{flavor}/{packageName}/xxx/\n目录下找到编译产物。\n\n\n<details>\n<summary>\n点击展开\n</summary>\n\n```java\n@Tiger\npublic class Util {\n    private static final float DENSITY;\n\n    public Util() {\n        int var1 = MethodManager.start();\n        long var2 = System.nanoTime();\n        MethodManager.end((Object)null, \"com/engineer/android/myapplication/Util\", \"<init>\", var2, var1);\n    }\n\n    public static int dp2Px(int dp) {\n        int var1 = MethodManager.start();\n        MethodManager.addParams(new Integer(dp), var1);\n        long var2 = System.nanoTime();\n        int var10000 = Math.round((float)dp * DENSITY);\n        MethodManager.end(new Integer(var10000), \"com/engineer/android/myapplication/Util\", \"dp2Px\", var2, var1);\n        return var10000;\n    }\n\n    public static void sleep(long seconds) {\n        int var2 = MethodManager.start();\n        MethodManager.addParams(new Long(seconds), var2);\n        long var3 = System.nanoTime();\n\n        try {\n            Thread.sleep(seconds);\n        } catch (InterruptedException var6) {\n            var6.printStackTrace();\n        }\n\n        MethodManager.end((Object)null, \"com/engineer/android/myapplication/Util\", \"sleep\", var3, var2);\n    }\n\n    public static void nothing() {\n        int var0 = MethodManager.start();\n        long var1 = System.nanoTime();\n        System.out.println(\"do nothing,just test\");\n        MethodManager.end((Object)null, \"com/engineer/android/myapplication/Util\", \"nothing\", var1, var0);\n    }\n\n    static {\n        int var0 = MethodManager.start();\n        long var1 = System.nanoTime();\n        DENSITY = Resources.getSystem().getDisplayMetrics().density;\n        MethodManager.end((Object)null, \"com/engineer/android/myapplication/Util\", \"<clinit>\", var1, var0);\n    }\n}\n```\n</details>\n\n可以看到这个打了 Tiger 注解的Util类，其所有方法内部都已经有插桩代码了。之后这些方法被调用的时候，就可以看到方法耗时了。如果有其他类的方法也需要同样的功能，要做的事情很简但，只需要用 Tiger 注解就可以了。\n\n\n\n## 配置任意类中方法的插桩\n\n上面的实现都是基于我们已有的代码做文章，但是有时候我们在做性能优化的时候，会需要统计一些我们使用的开源库的方法耗时，对于 public 方法也许还好，但是对于 private 方法或者是其他一些场景，就会比较麻烦了，需要借助代理模式（动态代理或静态代理）来实现我们需要的功能，或者是其他手段，但是这样的手段没有通用性，这次换个库要用，可能又要写一遍类似的功能，或者你也可以把三方库源码拉下来直接改也是可以的。\n\n这里其实可以借助 ASM 稍微做一些辅助，简化这些工作。这里以 Glide 为例。\n\n```java\nGlide.with(this).load(url).into(imageView);\n```\n\n上面的代码相信大家都不陌生，假设（只是假设）现在需要对统计 load 方法和 into 方法的耗时，那么怎么做呢？\n\n思考一下上面的两个实现，我们是基于注解确定了类和方法名，从而实现在特定的类或特定的方法中插入统计方法耗时的逻辑。那么现在这些方法的源码都无法访问了，注解也没法加了，怎么办呢？那就从问题的根本出发，直接由使用者告诉 transform 到底要在哪个类的哪个方法进行方法耗时的统计。\n\n我们可以像 build.gradle 的 android 闭包一样，自己定义一个这样的结点。\n\n```kotlin\nopen class TransformExtension {\n    // class 为键，方法名为值得一个 map\n    var tigerClassList = HashMap<String, ArrayList<String?>>()\n\n}\n```\n在 build.gradle 文件中配置信息\n\n```gradle\n    transform {\n        tigerClassList = [\"com/bumptech/glide/RequestManager\": [\"load\"],\n                          \"com/bumptech/glide/RequestBuilder\": [\"into\"]]\n    }\n```\n\n然后分别在 ClassVisitor 和 MethodVisitor 中根据类名和方法名确定要进行插桩的结点。\n\n```kotlin\n    init {\n        ....\n        classList = transform?.tigerClassList\n    }\n\n    override fun visit(\n        version: Int, access: Int, name: String,\n        signature: String?, superName: String?, interfaces: Array<String>?\n    ) {\n        super.visit(version, access, name, signature, superName, interfaces)\n        mClassName = name\n        if (classList?.contains(name) == true) {\n            methodList = classList?.get(name) ?: ArrayList()\n            needHook = true\n        }\n    }\n```\n\n可以简单看一下结果\n\n<details>\n<summary>\n点击展开\n</summary>\n\n```shell\n19407-19407 E/0Cat: ┌───────────────────────────────────------───────────────────────────────────------\n19407-19407 E/1Cat: │ class's name:       com/bumptech/glide/RequestManager\n19407-19407 E/2Cat: │ method's name:      load\n19407-19407 E/3Cat: │ method's arguments: [http://t8.baidu.com/it/u=1484500186,1503043093&fm=79&app=86&f=JPEG?w=1280&h=853]\n19407-19407 E/4Cat: │ method's result:    com.bumptech.glide.RequestBuilder@9a29abdf\n19407-19407 E/5Cat: │ method cost time:   1.52 ms\n19407-19407 E/6Cat: └───────────────────────────────────------───────────────────────────────────------\n19407-19407 E/0Cat: ┌───────────────────────────────────------───────────────────────────────────------\n19407-19407 E/1Cat: │ class's name:       com/bumptech/glide/RequestBuilder\n19407-19407 E/2Cat: │ method's name:      into\n19407-19407 E/3Cat: │ method's arguments: [Target for: androidx.appcompat.widget.AppCompatImageView{24ec8f4 V.ED..... ......I. 0,0-0,0 #7f08007c app:id/image}, null, com.bumptech.glide.RequestBuilder@31a00c76, com.bumptech.glide.util.Executors$1@1098060]\n19407-19407 E/4Cat: │ method's result:    Target for: androidx.appcompat.widget.AppCompatImageView{24ec8f4 V.ED..... ......I. 0,0-0,0 #7f08007c app:id/image}\n19407-19407 E/5Cat: │ method cost time:   5.78 ms\n19407-19407 E/6Cat: └───────────────────────────────────------───────────────────────────────────------\n19407-19407 E/0Cat: ┌───────────────────────────────────------───────────────────────────────────------\n19407-19407 E/1Cat: │ class's name:       com/bumptech/glide/RequestBuilder\n19407-19407 E/2Cat: │ method's name:      into\n19407-19407 E/3Cat: │ method's arguments: [androidx.appcompat.widget.AppCompatImageView{24ec8f4 V.ED..... ......I. 0,0-0,0 #7f08007c app:id/image}]\n19407-19407 E/4Cat: │ method's result:    Target for: androidx.appcompat.widget.AppCompatImageView{24ec8f4 V.ED..... ......I. 0,0-0,0 #7f08007c app:id/image}\n19407-19407 E/5Cat: │ method cost time:   10.88 ms\n19407-19407 E/6Cat: └───────────────────────────────────------───────────────────────────────────------\n\n```\n</details>\n\n可以看到，插桩已经成功了，RequestManager 的 load 方法打印了完整的方法信息，延伸一下，是不是可以在这里统计一下，到底用 Glide 加载过哪些 url 呢？当然，如上日志也看到，RequestBuilder 当中打印了两个 into 方法，通过方法名插桩是有点粗暴，目标类当中如果有多个同名的方法（方法重载），那么这些方法都会被插桩。这个问题其实也可以通过提供方法 desc (也就是方法参数，返回值等信息) 来做更精确的匹配。但是，这里如果只是做测试，这样粗粒度的也是可以的，毕竟这样对三方库的插桩还是比较hack的，线上环境最好还是不要使用。\n\n## Android 中点击事件的统计\n\n*这里的点击事件泛指实现了 View.OnClickListener* 接口的点击事件\n\n在一个成熟的 App 中肯定会包含埋点，埋点其实就是在统计用户的行为。比如打开了哪个页面，点击了哪个按钮，使用了哪个功能？通过对这些行为的统计，通过数据就可以获知用户最常用的功能，方便产品做决策。\n\n关于点击行为这件事，首先想想平时我们都是怎么实现的？无非就是两种情况，要么就是实现 View.OnClickListener 这个接口，然后在 onClick 方法中展开；要么就是匿名内部类，同样是在 onClick 方法展开。因此，如何确定 onClick 方法就成了我们需要关注的问题。我们不能按照之前方法名 equals 的简单规则进行定位。因为这样无法避免方法重名或者是参数重名的问题，假设某个小伙伴写了一个和 onClick(View view) 同名的普通方法，我们实际定位的 hook 结点可能就不是点击事件发生时的结点。因此，我们需要确保 ASM 访问的类实现了 android.view.View.OnClickListener 这个接口。\n\n```kotlin\n    override fun visit(\n        version: Int,\n        access: Int,\n        name: String?,\n        signature: String?,\n        superName: String?,\n        interfaces: Array<out String>?\n    ) {\n        super.visit(version, access, name, signature, superName, interfaces)\n        className = name\n\n              interfaces?.forEach {\n                if (it == \"android/view/View\\$OnClickListener\") {\n                    println(\"bingo , find click in class : $className\")\n                    hack = true\n                }\n            }\n        \n    }\n```\n\n这个实现其实也很简单，ClassVisitor 的 visit 方法提供了当前类实现了的所有接口，因此这里简单判断一下会比较准确。当然，这里也可以同时判断其他接口，比如我们要对应用内所有 TabBar 的选中事件进行插桩，就可判断当前类是否实现了 com.google.android.material.bottomnavigation.BottomNavigationView.OnNavigationItemSelectedListener 这个接口。\n\n由于 Transform 会访问 javac 编译生成的所有 class，包括匿名内部类，因此这里对于普通类和匿名内部类可以统一处理。（关于匿名内部类和普通类的使用 ASM 的差异可以[参考这篇](https://rebooters.github.io/2020/01/12/ASM-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A4%84%E7%90%86/))。\n\n当前类是否实现了接口确定之后，下一步就可以按照方法名及方法的参数和返回值进行更加精确的匹配了。\n\n```kotlin\noverride fun visitMethod(\n        access: Int,\n        name: String?,\n        desc: String?,\n        signature: String?,\n        exceptions: Array<out String>?\n    ): MethodVisitor {\n        var methodVisitor = super.visitMethod(access, name, desc, signature, exceptions)\n        if (hack) {\n            if (name.equals(\"onClick\") && desc.equals(\"(Landroid/view/View;)V\")) {\n                methodVisitor =\n                    TrackMethodVisitor(className, Opcodes.ASM6, methodVisitor, access, name, desc)\n            }\n        }\n\n        return methodVisitor\n    }\n```\n\n插桩的具体代码，本质上和之前的几个实现都是类似的，这里就不再贴代码了。这里简单看一下效果。\n\n```shell\nE/0Track: ┌───────────────────────────────────------───────────────────────────────────------\nE/1Track: │ class's name:             com.engineer.android.myapplication.SecondActivity\nE/2Track: │           view's id:      com.engineer.android.myapplication:id/button\nE/3Track: │ view's package name:      com.engineer.android.myapplication\nE/4Track: └───────────────────────────────────------───────────────────────────────────------\n````\n\n当一个点击事件发生时，我们可以获取实现这个点击事件的类，这个点击事件的 id 和包名。通过这些信息，我们就可以大概得知这个点击事件是在哪个页面（哪个业务）。因此，这个实现也可以帮助我们定位代码，有时候面对一份完全陌生的代码，很难定位到你所使用的功能到底在代码的哪个角落里，通过这个 Transform 实现，可以简单定位一下范围。\n\n自己测试的时候发现，在 Java 中如果使用了 lambda 表达式来实现匿名内部类，那么是不会按照常规的匿名内部类那样处理，并不会生成额外的匿名类。因此，对于使用 lambda 表达式实现的点击事件，这样是无法处理的。（暂时也没想到其他比较好的替代方案）\n\n看到这里，你是不是有一些想法了呢? 是不是可以考虑实现基于 Activity/Fragment 生命周期的代码插桩，来统计页面的展现时间和次数呢？是不是可以考虑将代码里的 Log.d 这样的代码统一删除掉？是不是可以将代码中没有引用和调用的代码删除掉呢？（这个可能有点难）\n\n\n## 总结\n\n首先明确一下，以上所有实现都是基于 Transform + ASM 技术栈的探索，只是简单的学习和了解一下 Transform + ASM 能够做什么以及怎么做。因此，部分实现也许有瑕疵甚至是 bug。[源码](https://github.com/REBOOTERS/AndroidAnimationExercise) 已同步到 Github 如果有想法，可以提 issue。\n\n通过对 Gradle Transform + ASM 的简单探索，可以看到在工程构建的过程中，从源码（包括java/kotlin/资源文件/其他） 到中间的 class 再到 dex 文件直至最终的 apk 文件生成，在整个过程中有很多的 task 被执行。而在 class 到 dex 这之间，利用 ASM 还是可以做很多文章的。\n\n这里我们只是简单的打印了 log，其实对一些关键信息，我们完全可以进行插桩式的收集，比如在 Glide 内部插入统计加载图片 URL 的代码，比如关键方法（例如 Application 的 onCreate 方法）的耗时统计，有时候我们关心的并不一定是具体的数据，而是数据所呈现出来的趋势。可以通过代码插桩将这些信息批量保存在本地甚至是上传到服务器，在后续流程中进一步的分析和拆解一些关键数据。\n\n## 参考文档\n\n[详解Android Gradle生成字节码流程](https://zhuanlan.zhihu.com/p/98909010)\n\n[从 Java 字节码到 ASM 实践](https://juejin.im/post/5bfa8ed8e51d451d3b51fd31)\n\n[App流畅度优化：利用字节码插桩实现一个快速排查高耗时方法的工具](https://juejin.im/post/5da33dc56fb9a04e35597a47)\n\n[ByteX](https://github.com/bytedance/ByteX)\n\n\n\n\n","tags":["Gradle"]},{"title":"2020 Book And Movie List","url":"%2F2020%2F01%2F01%2F2020-Book-And-Movie-List%2F","content":"\n**人生不止诗与远方和田野，还有眼前的苟且**\n\n<img src=\"2020-Book-And-Movie-List/happy.gif\" />\n\n<!--more-->\n\n## Book\n\n- book read once\n    - [x] **数学之美-吴军 ❤️❤️❤️❤️❤️**\n    - [x] **富爸爸穷爸爸 ❤️❤️❤️❤️❤️**\n    - [x] **小岛经济学 ❤️❤️❤️❤️❤️**\n    - [x] 事实 ❤️❤️❤️❤️❤️\n    - [x] 乡下人的悲歌 ❤️❤️❤️❤️\n    - [x] 夏目友人帐 ❤️❤️❤️❤️❤️\n    - [x] 经济学通识（薛兆丰·第二版）（没有读完 2021 继续）\n    - [x] 全球科技通史 （吴军）❤️❤️❤️❤️❤️\n    - [x] 原则 (没有读完 2021 继续)\n    - [x] 大唐狄公案 ❤️❤️❤️❤️❤️\n    - [x] 黄同学漫画二战史\n    - [x] 黄同学漫画经济学·经融危机篇 ❤️❤️❤️❤️❤️\n    - [x] 黄同学漫画经济学·生活常识篇 ❤️❤️❤️❤️❤\n    - [x] 瓜迪奥拉 - 胜利的另一种道路（吉列姆·巴拉格）\n    - [x] 你当像鸟飞往你的山 ❤️❤️❤️❤\n    - [x] 中国经济 2020 ❤️❤️❤️ (N)\n    - [x] 腾讯传 ❤️❤️❤️❤️❤️\n    - [x] 金瓶梅 （听书） ❤️❤️❤️❤️❤️\n    - [x] 陆小凤传奇全 7 册（1-38 章）❤️❤️❤️\n    - [x] 三体-地球往事 ❤️❤️❤️\n    - [x] 三体-黑暗森林 ❤️❤️❤️❤️❤️\n    - [x] 三体-死神永生 ❤️❤️❤️❤️❤️\n    - [x] 圣殿春秋 ❤️❤️❤️\n    - [x] 浪潮之巅 ❤️❤️❤️❤️❤️\n  \n\n- book on bed\n    - [x] 软技能\n    - [x] 并发编程之美\n    - [x] Kotlin 实战\n    - [x] Java8 实战\n    - [x] 算法（第 4 版\n    - [x] Think in Java\n    - [x] Android 开发艺术探索\n    - [x] Head First 设计模式\n\n## Movie\n\n- [x] **航海王·狂热行动** ❤️❤️❤️\n- [x] **何以为家❤️**\n- [x] **美丽心灵** ❤️❤️❤️❤️❤️\n- [x] **决战中途岛** ❤️❤️❤️❤️❤️\n- [x] **1917** ❤️❤️❤️ \n- [x] **神奇女侠2** ❤️❤️❤️❤️❤️\n- [x] **玩具总动员4 ❤️❤️❤️❤️**\n- [ ] **~~封神三部曲~~（没有上映 ）**\n- [ ] **~~拯救大兵瑞恩~~(一看就晕，此生无缘了) 😢**\n- [ ] **~~中国女排~~（主旋律弃了）**\n- [ ] **~~X战警：新变种人~~(评分坑爹，弃了)**\n- [ ] **~~速度与激情9~~(2021上映😂)**\n- [ ] **~~黑寡妇~~(2021 上映🤣)**\n- [ ] **花木兰**\n- [x] 姜子牙 ❤\n- [ ] 行骗天下\n- [ ] 极限职业\n- [x] 误杀 ❤️❤️❤️❤️\n- [x] 利刃出鞘 ❤️❤️❤️❤️❤️\n- [x] 囧妈 ❤️\n- [ ] 爱尔兰人\n- [ ] 南方车站的聚会\n- [ ] 花样年华\n- [ ] 大侦探皮卡丘\n- [x] 人在囧途 ❤️❤️❤️❤️ (N)\n- [x] 2046 ❤️❤️❤️ (N)\n- [x] 欲望都市 ❤️❤️❤ (N)\n- [x] 惊世狂花·贼女神偷 ❤️❤️❤️ (N)\n- [x] 误杀瞒天记 ❤️❤️❤️❤️❤️ (N)\n- [x] 大赢家 ❤️❤️❤️ (N)\n- [x] 绅士们 ❤️❤️❤️❤️❤️ (N)\n- [x] 雷神 1-3 ❤️❤️❤️ (N)\n- [x] 美国队长 2，3 ❤️❤️❤️❤️❤️ (N)\n- [x] 复仇者联盟 3，4 ❤️❤️❤️❤️❤️ (N)\n- [x] 龙之吻 ❤️❤️❤️ (N)\n- [x] 莫斯科陷落2 ❤ (N)\n- [x] 八佰 ❤ (N)\n- [x] 小妇人 ❤️❤️❤️❤️❤️ (N)\n- [x] 有希望的男人 ❤️❤️❤️❤️❤️ (N)\n- [x] 变形金刚3 ❤️❤️❤️❤️ (N)\n- [x] 东方秃鹰 ❤️❤️❤️❤️ (N)\n- [x] 老师好 ❤️❤️❤️❤️❤ (N)\n- [x] 天气之子 ❤(N)\n- [x] 乔乔的异想世界 ❤️❤️❤️❤️❤️ (N) \n- [x] 恶人传 ❤️❤️❤️❤️❤ (N)\n- [x] 缝纫机乐队 ❤️❤️❤️❤️❤ (N)\n- [x] 汉考克 ❤️❤️❤ (N)\n- [x] 一点就到家 ❤️❤️❤ (N)\n- [x] 信条 ❤️❤️❤ (N)\n\n\n## Tv\n\n- [x] **神盾局特工第7季-最终季**\n- [x] **摩登家庭第十一季-最终季**\n- [x] **无耻之徒第 9 季**\n- [x] **神探狄仁杰第一部**\n- [x] **小谢尔顿第三季**\n- [x] **爱情公寓第五季（最终季）**\n- [x] **越南战争纪录片PBS**\n- [x] 吐槽大会第四季 (N)\n- [x] 奔跑吧兄弟 （N）\n- [x] 王牌家族第四季 ❤️❤️❤️❤️❤️\n- [ ] 我爱我家第一部 (N)\n- [x] 美国囧案（第一季）(N)\n- [x] 庆余年 ❤️❤️❤️❤️ (N)\n- [x] 十日游戏 ❤️❤️❤️❤️ (N)\n- [x] 隐秘的角落 ❤️❤️ (N)\n- [x] 回来吧大叔❤️❤️❤️❤️ (N)\n- [x] 沉默的真相 ❤️❤️❤️❤️❤️ (N)\n- [x] 爱情公寓（4）❤️❤️❤️❤️ (N)\n- [x] 黑暗的欲望 ❤️❤️❤️\n- [x] 老友记 第一季 ❤️❤️❤️❤️❤️\n- [x] 老友记 第二季 ❤️❤️❤️❤️❤️\n- [x] 老友记 第三季 ❤️❤️❤️❤️❤️\n- [x] 老友记 第四季 21 集\n- [ ] ~~明星大侦探~~\n\n\n2021 年 1 月 1 日 09：00 盘点结果\n\n - 读书\n   - 人文类 22 本读完\n   - 技术类  7 本读完，《算法》 太长没有读完\n\n\n - 电影\n   - 36 部\n\n\n - 电视剧和综艺\n   - 美剧 10 部\n   - 国产剧 7 部\n   - 韩剧 1 部\n   - 综艺 3 部\n   - 纪录片 1 部\n\n 和 2019 年相比，整体用在看书上面的时间更多了一些，耗费在电视剧和电影以及综艺上面的时间少了很多。\n 新的一年希望可以继续保持，毕竟感觉读书得来的愉悦感比影音产品带来的更加的好。💪💪💪\n\n## PS\n\n1. **加粗**的内容是一定会看的\n2. 目标:多看点书\n(N) : 非计划中发生的事情\n\n## 有意思的梗\n\n### 吐槽大会\n  \n  > 男人来自火星，女人来自金星；金姐来自金星，金星来自火星\n\n[next 配置大全](https://www.jianshu.com/p/9f0e90cc32c2)","tags":["诗与远方"]},{"title":"远走高飞","url":"%2F2020%2F01%2F01%2F%E8%BF%9C%E8%B5%B0%E9%AB%98%E9%A3%9E%2F","content":"\n**凡事预则立不预则废**\n\n<br/>\n<img src=\"远走高飞/loading (9).gif\">\n\n<!--more-->\n\n<details>\n<summary>\n不要点开,千万不要点开\n</summary>\n<br/>\n<img src=\"远走高飞/girl.gif\">\n\n</details>\n<br/>\n<details>\n<summary>\n1 月 TODO \n</summary>\n\n- study\n    - [x] transform log + 埋点\n    - [x] transform blog\n    - [ ] gradle blog \n    - [ ] c++\n- read \n    - [x] 瓜迪奥拉传记 + notes\n\n- entertainment\n    - [x] 无耻之徒本季看完\n    - [x] 灵书妙探第一季看完\n- else\n    - [ ] auto every thing\n    - [x] StreetView better \n    - [x] StreetView push everyday\n    - [ ] TimeFly 1.0.1\n    - [ ] Try WeChat Game\n</details>\n\n<br/>\n<img src=\"远走高飞/loading (1).gif\">\n \n\n<details>\n<summary>\n2 月 TODO \n</summary>\n\n- study\n    - [ ] gradle blog \n    - [ ] java 并发\n    - [ ] android 热修复\n    - [ ] c++\n- read \n    - [ ] 大唐狄公案 （reading）\n    - [ ] 经济学讲义（薛兆丰 第二版）（reading）\n\n- entertainment\n    - [x] 神探狄仁杰第一部\n    - [ ] 越南战争\n    - [ ] 决战中途岛\n- else\n    - [ ] StreetView 10.0.8\n    - [ ] TimeFly 1.0.1\n    - [ ] Try WeChat Game\n\n\n\n2 月 Actual Results \n  \n  - study\n    - [ ] gradle blog \n    - [ ] java 并发\n    - [ ] android 热修复\n    - [ ] c++\n    - [x] 算法与数据结构学习(线性表&&排序&&二叉树&&堆)\n    - [x] openCv 入门\n    - [x] django 相关\n- read \n    - [x] 大唐狄公案 （reading to 47%）\n    - [x] 经济学讲义（薛兆丰 第二版）（reading to 18%）\n    - [x] 中国经济 2020 （reading to 24%) \n    - [x] Kotlin 实战 （第三章）\n\n- entertainment\n    - [x] 神探狄仁杰第一部\n    - [x] 小谢尔顿第三季到 12 集 \n    - [x] 美国囧案第一季\n    - [x] 爱情公寓最终季（2 月 12 日就看完了）\n    - [x] 吐槽大会第四季（每天健身做饭期间打发时间）\n    - [x] 越南战争 (到第六集)\n    - [x] 决战中途岛\n    - [x] 人在囧途\n    - [x] 2046  \n    - [x] 欲望都市（电影版）\n    - [x] 英超精华 1 期\n- else\n    - [x] StreetView 10.0.8 (改颜色)\n    - [x] StreetView 10.0.9 (添加游戏)\n    - [ ] TimeFly 1.0.1\n    - [ ] Try WeChat Game\n\nReview： \n\n - 由于网络原因，TimeFlay 及 WeChat Game 均暂停了。下月可以开始了\n - 读书效果还可以\n - 电影、电视时间投入过多，需要控制\n - opencv 电脑运行太慢，暂时被搁置，下面一周可以推进完成\n - 数据结构与算法效果不错，可以复习一次。\n\n</details>\n<br/>\n<img src=\"远走高飞/loading (2).gif\">\n\n\n<details>\n<summary>\n3月 TODO \n</summary>\n\n- study\n    - [ ] **数据结构与算法**\n    - [ ] **open-cv**\n    - [ ] **React**\n    - [ ] gradle blog \n    - [ ] java 并发\n    - [ ] android 热修复\n  \n- read \n    - [ ] **Kotlin 实战读完 + notes**\n    - [ ] 大唐狄公案 （reading to 70%）\n    - [ ] 经济学讲义（薛兆丰 第二版）（reading to 50%）\n    - [ ] **中国经济 2020 （reading to 100%)**\n  \n- entertainment\n    - [ ] **越南战争看完**\n    - [ ] **何以为家**\n    - [ ] 拯救大兵瑞恩\n- else\n    - [ ] StreetView 10.1.0\n    - [ ] StreetView 10.1.1\n    - [ ] StreetView 10.1.2\n    - [ ] **StreetView Web issue**\n    - [ ] **TimeFly 1.0.1**\n    - [ ] **Try WeChat Game**\n\n\n3 月 Actual Results \n\n- study\n    - [x] **数据结构与算法**\n    - [ ] **~~open-cv~~**\n    - [x] **React**\n    - [ ] ~~gradle blog~~ \n    - [ ] ~~java 并发~~\n    - [ ] ~~android 热修复~~\n\n  \n- publish blog\n    - [x] 微信公众号发文 3 篇\n    - [x] Java 多态 1 篇\n    - [x] Python Exif 及技巧一篇\n    - [x] Kotlin 实战 3 篇\n\n- read \n    - [x] **Kotlin 实战读完 + notes 3 篇**\n    - [x] 大唐狄公案 （reading to 70%）\n    - [ ] 经济学讲义（薛兆丰 第二版）（reading to 18%）\n    - [x] **中国经济 2020**\n    - [x] 黄同学漫画经济学·经融危机篇 ❤️❤️❤️❤️❤️\n    - [x] 黄同学漫画经济学·生活常识篇 ❤️❤️❤️❤️❤\n    \n  \n- entertainment\n    - [x] **越南战争看完**\n    - [ ] **何以为家**\n    - [ ] 拯救大兵瑞恩\n    - [x] 王牌对王牌 3 期\n    - [x] 误杀瞒天过记 ❤️❤️❤️❤️❤️\n    - [x] 惊世狂花·贼女神偷 ❤️❤️❤️\n\n- else\n    - [x] StreetView 10.1.0\n    - [x] StreetView 10.1.1\n    - [x] StreetView 10.1.2\n    - [x] StreetView 10.1.3\n    - [x] StreetView 10.1.4\n    - [x] StreetView 10.1.5\n    - [ ] **StreetView Web issue**\n    - [ ] **TimeFly 1.0.1**\n    - [x] **Try WeChat Game**\n\nReview: \n\n  -  数据结构及算法会长期进行\n  -  了解 React 组件创建方式及 SPA ，尝试了一些游戏及 canvas 动画的实践\n  -  每日阅读计划执行较好，继续保持\n  -  StreetView 保持了每周一次 release 的频率，但是改动也较多\n  -  TimeFly And WeChat Game 继续搁浅，原因：没有清楚的产品原型\n  -  看了两部计划外的电影，看电影次数及时间较上月大幅下降，读书时间增多\n  \n</details>\n<br/>\n\n<br/>\n<img src=\"远走高飞/loading (4).gif\">\n\n<details>\n<summary>\n4月 TODO \n</summary>\n\n- study\n  - [ ] **数据结构与算法**\n    - [x] **iOS**\n    - [ ] **wechat**\n      - [x] TimeFly 1.0.1\n      - [ ] Try a game\n\n- publish blog\n    - [ ] 微信公众号发文 4 篇\n      - [ ] Price And Development\n      - [ ] Time And Time\n      - [ ] Morden Family Final Review\n      - [ ] pending\n    - [x] iOS learning notes\n    - [ ] 收集箱清理 （pending)\n  \n- read \n    - [x] **大唐狄公案 （reading to 100%）in 86%**\n    - [ ] 经济学讲义（薛兆丰 第二版）（reading to 50%）\n    - [ ] 事实（比尔盖茨推荐） （reading to 100%)\n    - [x] **你当像鸟飞往你的山 （reading to 100%)**\n    - [ ] **算法 第 5 章**\n  \n- entertainment\n    - [ ] **何以为家**\n    - [ ] **拯救大兵瑞恩**\n    - [x] 庆余年（to 40）\n    - [x] 绅士们 \n    - [x] 王牌对王牌2期\n\n- else\n    - [ ]**auto video**\n    - [x] StreetView 10.1.6\n      - [x] menu-bug \n      - [x] better game\n    - [x] StreetView 10.1.7\n      - [x] load more support\n    - [x] StreetView 10.1.8\n      - [x] beauty refresh\n    - [x] StreetView 10.1.9\n      - [x] time machine\n    - [x] StreetView 10.2.0\n      - [x] time machine better\n    - [ ] **StreetView Web issue**\n  \n\n  Review: \n    StreetView 控制发版频率，每周一版投入产出比不划算\n    读书完成一本，读书效率可以提供一些\n    好好规划一下时间，写公众号文章还是有点意思的\n    本月只看了一部电影，看电视剧及综艺花费时间较多\n\n</details>\n<br/>\n\n<br/>\n<img src=\"远走高飞/loading (5).gif\">\n\n<details>\n<summary>\n5月TODO \n</summary>\n\n- Try A New Product\n\n- Study\n  - [ ] **数据结构与算法**\n  - [ ] **wechat**\n      - [x] TimeFly 1.0.2\n      - [ ] Try a game\n\n- publish blog\n    - [x] **dart learning notes**\n    - [ ] flutter product\n    - [ ] **微信公众号发文至少 4 篇**\n      - [ ] Price And Development\n      - [ ] Time And Time\n      - [ ] Morden Family Final Review\n      - [ ] pending\n    - [ ] 收集箱清理 （pending)\n  \n- read \n    - [x] **大唐狄公案 （reading to 100%）**\n    - [x] 陆小凤传奇 (reading to 16%) （**N**）\n    - [x] 金瓶梅听书 (6/89集) （**N**）\n    - [ ] ~~经济学讲义（薛兆丰 第二版）（reading to 50%）~~\n    - [ ] ~~原则~~\n    - [x] 事实（比尔盖茨推荐） （reading to 19%)\n    - [ ] **算法 第 5 章**\n    - [x] Head First 设计模式（学习了 7 个)  （**N**）\n    - [x] 公众号累计文章阅读\n  \n- entertainment\n    - [x] **何以为家**\n    - [ ] **拯救大兵瑞恩**\n    - [x] 庆余年（看完）\n    - [x] **摩登家庭最终季**\n    - [x] 小谢尔顿第三季12-21集 （**N**）\n    - [x] 误杀\n    - [x] 斯巴达克斯血与沙第一季\n    - [ ] 极速车王\n    - [x] 王牌对王牌10-12期（完结）\n\n- else\n    - [ ]**auto video**\n    - [x] StreetView 10.2.1\n      - [x] 附近推荐分页加载\n    - [x] StreetView 10.2.2\n      - [x] 更换广告 SDK \n      - [ ] 室内景分页加载\n      - [ ] 室内景-时光机效果\n    - [x] StreetView 10.2.3\n       - [x] 更换广告 SDK \n    - [X] **StreetView Web issue**\n\n \n\n Review:\n \n - 看电视剧似乎真的没有什么意义，看完也就忘了，还是少看吧。\n - 广点通广告 SDK 忽然的对个人开发者的放弃真是让人猝不及防，先用 mimo 的试运行两周看看效果吧。\n - 开始习惯于阅读和梳理知识，感觉找到了很多被荒废掉的东西\n - flutter 还是学起来\n - blog 要多写\n - 公众号还是写起来吧\n\n</details>\n<br/>\n\n<br/>\n<img src=\"远走高飞/loading (6).gif\">\n\n\n<details>\n<summary>\n6月TODO\n</summary>\n\n- Try A New Product\n\n- Study\n  - [ ] **数据结构与算法**\n  - [ ] **wechat**\n    - [ ] **Try a game**\n      - [ ] draw path game\n    - [x] **TimeFly 1.3.0**\n      - [x] 倒计时添加\n    - [x] TimeFly 1.3.1\n      - [ ] ~~倒计时自定义(无法过审)~~\n    - [ ] TimeFly 1.3.2\n      - [ ] 动态沙漏\n\n\n- publish blog\n    - [ ] **微信公众号发文至少 4 篇**\n      - [ ] Price And Development\n      - [ ] 高考 2008\n      - [ ] Morden Family Final Review\n      - [ ] 学习的价值和理论\n      - [ ] pending\n      - [x] 半年度 review\n    - [ ] **技术 博客**\n      - [x] **Python 处理 excel 表格分类**\n      - [x] **Git 非常规操作**\n      - [ ] **Android Native IO**\n      - [x] **Mini-App 终极**\n      - [ ] Flutter 插件\n      - [ ] Flutter 混合开发\n    - [ ] 收集箱清理 （pending)\n  \n- read \n    - [x] 陆小凤传奇 (reading to 45%)\n    - [x] 金瓶梅听书 (48/103集) \n    - [x] 事实（比尔盖茨推荐） （reading to 40%)\n    - [ ] **算法 第 5 章**\n    - [x] 公众号累计阅读累计45个番茄钟\n    - [x] 腾讯传\n    - [x] 吴军-数学之美 80%\n  \n- entertainment\n    - [ ] **小妇人**\n    - [ ] **1914**\n    - [ ] 神盾局特工最终季\n    - [x] 雷神 1-3 部 (N)\n    - [x] 十日游戏 (N)\n    - [x] 奔跑吧兄弟 3 集 (N)\n    - [x] 美国队长 2~3 部（N）\n    - [x] 复仇者联盟 3~4 部（N)\n\n- else\n    - [ ]**auto video**\n    - [x] StreetView 10.2.4\n      - [ ] ~~替换剩余广告（小米 AD 真坑）~~\n      - [x] 替换会广点通广告\n    - [x] StreetView 10.2.5\n      - [ ] ~~try a map game~~\n      - [x] replace ad with xiaomi\n\n\n\nReview: \n\n帝都疫情的二次爆发，有点打乱计划，让原本可以被执行的事情，在环境上变得困难，只能做一些其他的事情，打发时间。很多时候就是这样，计划赶不上变化。所以，面对这样突如其来的变化，下一次要做的就是及时调整目标和策略，及时止损，不要破罐子破摔。因为，生活终究会回归到平常，时间并不会停止，更不会倒退。水滴石穿，绳锯木断，很多时候需要的就是每一天不断的积累和坚持，没有什么捷径和偶然。\n\n延迟享受或者说延迟满足，也许是一件可以尝试的事情。\n\n阅读和写作是一件值得投入的事情。\n\n\n</details>\n\n\n<br/>\n\n<br/>\n<img src=\"远走高飞/loading (7).gif\">\n\n\n<details>\n<summary>\n7 月 TODO\n</summary>\n\n- New Product (Gif-Revert )\n  - [x] some Research\n  - [ ] make a plan\n\n- Reading\n\n|List|OK|R|C|\n|----|----|---|---|\n|算法第五章|读完+笔记|||\n|金瓶梅|听完|听到 84 章，总共 103 章|正常节奏听|\n|数学之美|读完|done||\n|浪潮之巅|50%|25%|这本书挺好，值得细读|\n|事实|读完|done||\n|夏目友人帐|读完| done|咪咕阅读临时添加|\n|乡下人的悲歌|读完||咪咕阅读临时添加|\n|三体每日 15 分钟阅读| ||咪咕阅读临时添加|\n\n- Study\n\n|List|OK|R|C|\n|----|----|---|---|\n|TimeFly|动态添加禅定页面|done||\n||沙漏动画更仔细一些||29 周新增|\n|WeChat Game|简单游戏上线||这个需要再调研一下|\n\n- Writing\n\n|List|OK|R|C|\n|----|----|---|---|\n|技术类|5篇|||\n|     |**Review C**|done||\n|     |**Review C++**|done||\n|     |Android Native IO|||\n|     |Flutter|||\n|     |CSS|||\n|     |文件加密解密|done||\n|公众号|11篇|||\n|      |**腾讯**|||\n|      |**高考2008**|||\n|      |**Price And Development**|||\n|      |**Morden Family Final Review**|||\n|      |**Weekly More**|||\n\n- Entertainment\n\n|List|OK|R|C|\n|----|----|---|---|\n|Moive|4|||\n|     |小妇人|||\n|     |1914|||\n|     |玩具总动员4|done||\n|     |龙之吻|done||\n|     |莫斯科陷落2|done|临时添加|\n|TV   |1|||\n|     |神盾局特工|10||\n|综艺  |1|||\n|     |奔跑吧兄弟|4期||\n|     |英超精华|3期||\n|     |天下足球|3期||\n\n\n- Else \n\n|List|OK|R|C|\n|----|----|---|---|\n|StreetView|2|||\n|10.2.9|new ad all in revert|done|新平台广告全部下线|\n|10.2.8|new ad all in|done|新平台广告全量|\n|10.2.7|新 splash AD|done|https://static.mintegral.com/ 新平台尝试|\n|10.2.6| Refresh Issue Fix| done||\n|10.2.8| Replace all with New AD| done| 后期添加|\n\nneed more idea ? \n\n**Review** \n\n1. 关于新产品的实施一直在犹豫中，不知道值不值得做，需要再调研一下 google 对于 AD 的政策吧。\n2. 读书这件事变得越来越奢侈，时间总是过得很快，要继续坚持啊\n3. TimeFly 继续更新\n4. C 语法的了解\n5. 很多事情需要动力\n\n</details>\n\n<br/>\n\n<br/>\n<img src=\"远走高飞/loading (8).gif\">\n\n\n<details>\n<summary>\n8 月 TODO\n</summary>\n\n\n- New Product (Gif-Revert )\n  - [x] some Research\n  - [x] How about Google Console AD ？\n  - [ ] make a plan\n\n\n\n- Reading\n\n|List|OK|R|C|\n|----|----|---|---|\n|**金瓶梅**|听完|done||\n|**圣殿春秋**|30%|30%||\n|浪潮之巅|50%|80%||\n|三体-地球往事|读完|done||\n|三体-黑暗森林|50%|80%||\n|三体每日 15 分钟阅读|100%|100%||\n\n- Study\n\n|List|OK|R|C|\n|----|----|---|---|\n|TimeFly|沙漏动画|||\n\n- Writing\n\n|List|OK|R|C|\n|----|----|---|---|\n|技术类|3篇|||\n|     |Android Native IO|||\n|     |Flutter|||\n|     |CSS|||\n|公众号|11篇|||\n|      |**腾讯**|||\n|      |**高考2008**|||\n|      |**Price And Development**|||\n|      |**Morden Family Final Review**|||\n|      |**Weekly More**|||\n|      |**为什么大家都在讨论 Tik Tok**|done||\n\n- Entertainment\n\n|List|OK|R|C|\n|----|----|---|---|\n|Moive|4|||\n|     |小妇人|done||\n|     |1917|||\n|     |八佰|done|2020 影院第一场|\n|TV   |1|||\n|     |神盾局特工|完结（done）||\n\n\n- Else \n\n|List|OK|R|C|\n|----|----|---|---|\n|StreetView|2|||\n|10.3.1|umeng sdk,xiaomi-ad sdk,gradle upgrade|done||\n|10.3.2|school feed|done||\n|10.3.3|分类|||\n|10.3.4|photo edit | ||\n|10.3.5|AR ? | ||\n\n\n\n\n- **Review**\n\n- StreetView 由于需要隐私政策 链接地址的原因，暂时停止了更新，需要在个人站上线隐私政策的相关内容\n- 周末的时间都用来读书了。\n- 公众号以及技术 Blog 写作的问题，还需要再思考一下。\n\n</details>\n\n<br/>\n\n<br/>\n<img src=\"远走高飞/loading (9).gif\">\n\n\n<details>\n<summary>\n9 月 TODO\n</summary>\n\n\n\n- Reading\n\n|List|OK|R|C|\n|----|----|---|---|\n|**圣殿春秋**|40%|||\n|浪潮之巅|读完|done||\n|三体-黑暗森林|读完|done||\n|三体-死神永生|30%|done||\n|三体每日 15 分钟阅读|30 次|done||\n\n- Product\n\n|List|OK|R|C|\n|----|----|---|---|\n|TimeFly|沙漏动画|||\n|TimeFly|More Feature|||\n|GifRevert||||\n||开屏动画|||\n||设置、关于菜单页面|||\n||proguard stuff|||\n||publish prepare|||\n||publish go google|||\n|StreetView||||\n||webpage private url|||\n\n\n\n\n- Writing\n\n|List|OK|R|C|\n|----|----|---|---|\n|技术类|3篇|||\n|     |Android Native IO|||\n|     |Flutter|||\n|     |CSS|||\n|公众号|11篇|||\n|      |**腾讯**|||\n|      |**Price And Development**|||\n|      |**Tv Review**|||\n|      |**Weekly More**|||\n\n- Entertainment\n\n|List|OK|R|C|\n|----|----|---|---|\n|Moive|4|||\n|     |1917|||\n|     |~~花木兰~~||评分太低，放弃观看|\n|     |~~阿凡达~~||影院并没有上|\n|     |有希望的男人|done||\n|     |变形金刚 3|done|outing 时在宾馆看的|\n|     |东方秃鹰|done|老电影重温|\n|TV   |1|||\n|     |回来吧大叔|done|值得一看的韩剧|\n|     |沉默的真相|done||\n\n\n- **Review** \n\n  - 9 月份整体，阅读完成量较好，咪咕阅读 100 天的打卡计划已经完成。\n  - New Product 由于一些原因，再次被搁置了\n  - 写东西的计划，再次被打断，后面应该好好列个计划了。\n\n\n</details>\n\n<br/>\n\n<br/>\n<img src=\"远走高飞/loading (10).gif\">\n\n\n\n<details>\n<summary>\n10 月 todo \n</summary>\n\n\n- Reading\n\n|List|OK|R|C|\n|----|----|---|---|\n|**圣殿春秋**|读完|done||\n|**三体-死神永生**|读完|||\n|**算法**|重读一遍|||\n\n\n- Product\n\n|List|OK|R|C|\n|----|----|---|---|\n|TimeFly|沙漏动画|||\n|TimeFly|自定义倒计时|||\n|GifRevert||||\n||开屏动画|done||\n||设置、关于菜单页面|done||\n||proguard stuff|||\n||publish prepare|||\n||publish go google|||\n|StreetView||||\n||**webpage private url**|done||\n\n\n\n\n- Writing\n\n|List|OK|R|C|\n|----|----|---|---|\n|技术类|3篇|||\n|     |Android Native IO|||\n|     |Flutter|||\n|     |CSS|||\n|公众号|11篇|||\n|      |**腾讯**|||\n|      |**Price And Development**|||\n|      |**Tv Review**|||\n|      |**Weekly More**|||\n\n- Entertainment\n\n|List|OK|R|C|\n|----|----|---|---|\n|Moive|5|||\n|     |1917||done|\n|     |我和我的家乡||等院线下映了看吧|\n|     |恶人传|done| \n|     |老师好|done|国庆回家的火车上看的|\n|     |天气之子|done|国庆回家的火车上看的|\n|     |乔乔的异想世界|done|国庆回家的火车上看的|\n\n- Review \n\n  - StreetView 添加 privacy 之后，进行了连续的版本发布，修复了一些潜在的问题。后续可以考虑一下 push 相关的内容，提高留存及 DAU。\n  - 读书的时间越来少，还是尽量找一些时间吧\n  - 写东西总是有很多顾虑\n\n\n</details>\n\n<br/>\n\n<br/>\n<img src=\"远走高飞/loading (12).gif\">\n<br/>\n\n\n<details>\n<summary>\n11 月 todo \n</summary>\n\n- Reading\n\n|List|OK|R|C|\n|----|----|---|---|\n|**三体-死神永生**|读完|done||\n|**全球科技通史**|30%|done||\n|**算法**|重读一遍|||\n\n\n- Product\n\n|List|OK|R|C|\n|----|----|---|---|\n|TimeFly|沙漏动画|||\n|TimeFly|自定义倒计时|||\n|GifRevert||||\n||picture select change|done||\n||save function change|done||\n||revert function check|done||\n||proguard stuff|done||\n||publish prepare|done||\n||publish go google|done||\n|StreetView||||\n|1037|**push stuff**|done||\n|1038| push weekly and ui-fix|done||\n|1039| crash issue and self-update|done||\n|1040| xiaomi ad update and some-fix|done||\n|103*|try use usplash picture|||\n|103*|try a picture list with flutter|||\n|103*|~~try support night mode~~|||\n\n\n\n\n- Writing\n\n|List|OK|R|C|\n|----|----|---|---|\n|技术类|3篇|||\n|     |Android Native IO|||\n|     |Flutter|||\n|     |CSS|||\n|公众号|11篇|||\n|      |**腾讯**|||\n|      |**Price And Development**|||\n|      |**Tv Review**|||\n|      |**Weekly More**|||\n\n- Entertainment\n\n|List|OK|R|C|\n|----|----|---|---|\n|Moive|2|||\n|     |美丽心灵|||\n|     |急先锋|abandon||\n|     |姜子牙|done||\n|     |汉考克|done||\n|     |缝纫机乐队|done||\n|     |一点就到家|done||\n|Tv|1|||\n|     |少年谢尔顿|||\n|     |老友记第一季|done||\n|     |老友记第二季|done||\n\n\n\n- Review \n\n- 老友记是针不戳，看起来完全停下来\n- StreetView 每周一更，继续下去\n- 没写的文章和东西，还是要补上的\n\n</details>\n\n<br/>\n\n<br/>\n<img src=\"远走高飞/loading (3).gif\">\n\n<br/>\n<details>\n<summary>\n12 月 todo \n</summary>\n- Reading\n\n|List|OK|R|C|\n|----|----|---|---|\n|**全球科技通史**|读完|done||\n|**Android 开发艺术探索**|再读+笔记|done|没有记笔记|\n|算法|30%|done||\n|进阶之光|重读| done||\n\n\n- Product\n\n|List|OK|R|C|\n|----|----|---|---|\n|TimeFly|沙漏动画 better |||\n|       |自定义倒计时|||\n|       |新的倒计时开始|done||\n|GifRevert||||\n||publish and again|done|12.5 在 GooglePlay 上架了|\n|StreetView||||\n|1041| show list in page feature|done||\n|1042| add a flippy bird game|done||\n|1042| **try a picture list with flutter**|||\n|1043| try use usplash picture|||\n|1043| sdk update |done||\n\n\n\n\n- Writing\n\n|List|OK|R|C|\n|----|----|---|---|\n|技术类|2篇|||\n|     |Android Native IO|||\n|     |Flutter embed with Native|||\n|公众号|11篇|||\n|      |**Year Review**|done||\n\n- Entertainment\n\n|List|OK|R|C|\n|----|----|---|---|\n|Moive|4|||\n|     |信条|done||\n|     |神奇女侠 1984|done||\n|     |美丽心灵|done||\n|     |南方车站的聚会|~~abandon~~||\n|Tv|2|||\n|     |少年谢尔顿-第四季|||\n|     |老友记第三季|done||\n|     |老友记第四季|22|看到了最后几集|\n\n\n\n- ReView\n\n  - 在 2020年 12 月 31 日 24 点之前完成了一年一度的年终盘点吧，用照片记录了过往的一年，简单的回忆了一下，算是一个好的记忆吧。\n  - GifRevert 的 App 在 Google Play 非常意外的很容易就上架了，真的是有点不敢相信自己，后面要继续维护起来。\n  - StreetView 自从广告收入锐减之后（其实之前也没有多少），在这个月通过稳定性的保证和新功能的增加，活跃用户量似乎有所回暖，还是本着技术学习的目标，不断的维护和更新吧。\n  - 时光机 Lite ，微信官方似乎放开了个人开发者进行日记功能的限制，没有了这个限制，后面可以扩展更多的功能了。\n  - 读了很多遍，依旧会忘记，所以还是用写的吧，博客维护和公众号的更新，要有计划的开始了。\n\n</details>\n\n***\n\nps: **N** 不是计划的，中途插入的事项","tags":["OKR"]},{"title":"当 Java 字节码遇到 ASM","url":"%2F2019%2F12%2F22%2F%E5%BD%93-Java-%E5%AD%97%E8%8A%82%E7%A0%81%E9%81%87%E5%88%B0-ASM%2F","content":"\n## 前言\n\n#### ASM 可以做什么\n\n>ASM 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。Java class 被存储在严格格式定义的 .class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [前言](#%e5%89%8d%e8%a8%80)\n    - [ASM 可以做什么](#asm-%e5%8f%af%e4%bb%a5%e5%81%9a%e4%bb%80%e4%b9%88)\n- [实践](#%e5%ae%9e%e8%b7%b5)\n    - [目标](#%e7%9b%ae%e6%a0%87)\n    - [依赖](#%e4%be%9d%e8%b5%96)\n    - [实现](#%e5%ae%9e%e7%8e%b0)\n      - [asm API](#asm-api)\n      - [run 方法的 Visitor](#run-%e6%96%b9%e6%b3%95%e7%9a%84-visitor)\n      - [getValue 方法的 MethodVisitor](#getvalue-%e6%96%b9%e6%b3%95%e7%9a%84-methodvisitor)\n    - [验证结果](#%e9%aa%8c%e8%af%81%e7%bb%93%e6%9e%9c)\n- [总结](#%e6%80%bb%e7%bb%93)\n- [引用](#%e5%bc%95%e7%94%a8)\n\n<!-- /TOC -->\n\n\n## 实践\n\n\n#### 目标\n\n```java\npackage com.asm;\n\npublic class Music {\n\n    public void run() {\n        // 编译期在这里插入代码 System.out.println(\"asm insert before\");\n        System.out.println(\"this is run\");\n        // 编译期在这里插入代码 System.out.println(\"asm insert after\");\n    }\n\n    public int getValue() {\n        System.out.println(\"this is run\");\n        // 编译期在 return 语句之前插入 System.out.println(\"insert before return\");\n        return 1;\n    }\n\n    public void put(String value) {\n        // 注意方法 desc \n    }\n\n    private void add(String value, Thread thread) {\n        // 注意方法 desc\n    }\n\n    protected Music fake(int[] nums, String[] values) {\n       // 注意方法 desc\n        return null;\n    }\n}\n```\n\n实现如上代码注释的目标，**在固定代码的前后，以及 return 语句之前插入逻辑**，这基本上就可以满足实际的需求了。下面看看如何实现。\n\n\n#### 依赖\n\n这里直接下载 asm-6.0.jar 文件放到lib 目录在依赖配置里添加即可。\n\n#### 实现\n\n```java\npublic class App {\n\n    private static Music music;\n\n    private static final String PATH = \"./out/production/JavaArt/com/asm/\";\n\n    public static void main(String[] args) {\n\n\n        try {\n            ClassReader classReader = new ClassReader(\"com.asm.Music\");\n//\n            ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n            ClassVisitor visitor = new MyVisitor(writer);\n            classReader.accept(visitor, ClassReader.EXPAND_FRAMES);\n\n            byte[] result = writer.toByteArray();\n\n            File file = new File(PATH + \"Music.class\");\n            FileOutputStream outputStream = new FileOutputStream(file);\n            outputStream.write(result);\n            outputStream.close();\n\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n```\n这里都是常规操作,ClassReader 读取内容，产生事件，接收一个 Visitor 进行对事件做特殊操作，ClassWriter 最终再次消费。**从编译路径读取要修改的Class 文件，通过 ASM 的访问者模式 API 进行操作，然后将操作完的结果再次覆写回去**。这里重点看一下 MyVisitor 的实现。\n\n\n```java\nprivate static class MyVisitor extends ClassVisitor {\n\n        MyVisitor(ClassVisitor cv) {\n            super(Opcodes.ASM6, cv);\n        }\n\n        @Override\n        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n            System.out.println(\"=====================\");\n            System.out.println(\"acce== \" + access);\n            System.out.println(\"name== \" + name);\n            System.out.println(\"desc== \" + desc);\n            System.out.println(\"sign== \" + signature);\n            System.out.println(\"=====================\");\n\n            MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n\n            if (name.equals(\"run\")) {\n                mv = new MyMethodVisitor(Opcodes.ASM6, mv);\n            }\n\n            if (name.equals(\"getValue\")) {\n                mv = new MyMethodVisitorWithReturn(Opcodes.ASM6, mv);\n            }\n\n            return mv;\n        }\n    }\n```\n\n##### asm API \n\n**asm 的 api 常规的有两种使用方式，树形和访问者模式，这里只说访问者模式。**\n\nClassVistor 是一个抽象类，这就是 asm API 的风格，对于类、方法提供了一系列的 XXXVisitor 抽象类，开发者通过继承这些抽象类或者他的子类，实现特定的方法，在这些方法里可以获取到关于大量关于这个类的信息，有了这些信息，就可以操纵这个类了。**比如这里的visitMethod方法**，我们可以看一下日志： \n\n```shell\n=====================\nacce== 1\nname== <init>\ndesc== ()V\nsign== null\n=====================\n=====================\nacce== 1\nname== run\ndesc== ()V\nsign== null\n=====================\n=====================\nacce== 1\nname== getValue\ndesc== ()I\nsign== null\n=====================\n=====================\nacce== 1\nname== put\ndesc== (Ljava/lang/String;)V\nsign== null\n=====================\n=====================\nacce== 2\nname== add\ndesc== (Ljava/lang/String;Ljava/lang/Thread;)V\nsign== null\n=====================\n=====================\nacce== 4\nname== fake\ndesc== ([I[Ljava/lang/String;)Lcom/asm/Music;\nsign== null\n=====================\n```\n\n和一开始定义的 Music.java 文件对比一下，对于这些字段及其含义应该很容易理解了。init 方法就是默认构造函数的名字。\n\n- accc 是方法的访问控制符的定义；\n- name 就是方法名，\n- desc 就是方法签名，简单来说就是方法参数和返回值的特定字符串。可以看到规律，\n  - V 就是代表返回值时 void；\n  - I 是 int；\n  - 返回值如果是特定的类，需要些完整包名，同时以 L 打头\n- 括号内就是方法参数\n  - 没有的话就什么都不写\n  - 有的话，还是以 L 打头的类完整包名\n  - 对于数组以 [ 打头，\n  - 多个参数之间用分号；进行分隔，需要注意的是，即便只有一个参数，也要写分号\n\n总结如下表\n\n<img width=50% src=\"当-Java-字节码遇到-ASM/code_type.jpg\"> \n\n**注意 boolean 类型是 Z，以后在字节码里看到 Z 可不要一脸懵逼哦😯。还有 long 也是比价特殊，对应类型是 J。**\n\n看完这些，再回到上面的代码里，可以看到对于 run 和 getValue 方法，返回了特定的 MyMethodVisitor ,而不是调用父类的。**再次重申一下，这就是 asm Visitor 模式的 API 使用方式** \n\n下面就来看看，对于这两个方法，做了什么处理。\n\n##### run 方法的 Visitor \n\n```java\n    private static class MyMethodVisitor extends MethodVisitor {\n\n        MyMethodVisitor(int api, MethodVisitor mv) {\n            super(api, mv);\n        }\n\n        @Override\n        public void visitCode() {\n            super.visitCode();\n            System.out.println(\"start hack before\");\n            hack(mv, \"asm insert before\");\n        }\n\n\n        @Override\n        public void visitInsn(int opcode) {\n            if (opcode == Opcodes.RETURN) {\n                System.out.println(\"start hack after\");\n                hack(mv, \"asm insert after\");\n            }\n            super.visitInsn(opcode);\n        }\n    }\n\n    private static void hack(MethodVisitor mv, String msg) {\n        mv.visitFieldInsn(\n                Opcodes.GETSTATIC,\n                Type.getInternalName(System.class),\n                \"out\",\n                Type.getDescriptor(PrintStream.class)\n        );\n        mv.visitLdcInsn(msg);\n        mv.visitMethodInsn(\n                Opcodes.INVOKEVIRTUAL,\n                Type.getInternalName(PrintStream.class),\n                \"println\",\n                \"(Ljava/lang/String;)V\",\n                false\n        );\n    }\n```\n\n- visitCode 当一个方法开始被访问时调用，因此在这里插入了第一个目标代码\n- visitInsn 当一个没有参数的方法的每一条指令被执行的时候，就会调用这个方法，这里当执行的方法返回这条指令时（注意是方法自身返回，可以理解为从方法调用栈弹出）进行拦截，在其之前插入我们的逻辑。具体的插入逻辑都在 hack 方法里。这么一长串代码实现的功能类似如下：\n\n```java\n    private static void hack(String msg) {\n        System.out.println(msg);\n    }\n```\n是的，就是这么简单。其实这也是使用 ASM 进行 AOP 最难也最最核心的地方。**在哪个类做 hack，在哪个方法内做 hack，在方法的哪个位置做 hack，ASM 发展时至今日已经提供了非常多的方法和 API，可以供开发者调用，但是如何用字节码实现一些特定逻辑，就比较难了**。这里说难呢，其实也不难，我们可以借助类似[asm-bytecode-outline](https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline/)这样的插件非常方便的帮助我们生成 java 代码对应的字节码。上面的 hack 方法其实就是用这个插件生成的。\n\n##### getValue 方法的 MethodVisitor \n\n```java\n    private static class MyMethodVisitorWithReturn extends MethodVisitor {\n\n        public MyMethodVisitorWithReturn(int api, MethodVisitor mv) {\n            super(api, mv);\n        }\n\n        @Override\n        public void visitInsn(int opcode) {\n            System.out.println(\"opcode==\" + opcode);\n            if (opcode == Opcodes.IRETURN) {\n                hack(mv, \"insert before return\");\n            }\n            super.visitInsn(opcode);\n        }\n    }\n  ```\n\n这里唯一需要关注的一点就是 hack 结点的获取，由于这个方法有返回值了，因此这个 return 拦截的 code 值需要改变为 Opcodes.IRETURN。 这里的 I 是不是似曾相识，其实就是参数类型。\n\n\n\n#### 验证结果\n\n好了,写了半天，到底有没有生效呢？我们可以运行一下，看看效果。\n\n```java\n  public static void main(String[] args) {\n\n        ... 插桩过程 ...\n\n        music = new Music();\n        music.run();\n    }\n```\n\n输出：\n\n```shell\nasm insert before\nthis is run\nasm insert after\n```\n同时可以打开 Music.class 文件验证一下\n\n```java\npackage com.asm;\n\npublic class Music {\n    public Music() {\n    }\n\n    public void run() {\n        System.out.println(\"asm insert before\");\n        System.out.println(\"this is run\");\n        System.out.println(\"asm insert after\");\n    }\n\n    public int getValue() {\n        System.out.println(\"this is run\");\n        System.out.println(\"insert before return\");\n        return 1;\n    }\n\n    public void put(String value) {\n    }\n\n    private void add(String value, Thread thread) {\n    }\n\n    protected Music fake(int[] nums, String[] values) {\n        return null;\n    }\n}\n```\n完美，这就是 asm 插桩的实现。\n\n\n这里在说一下关于 hack 结点（也就是插桩位置）的获取。这里我们也可以使用 asm-commons.jar 包里提供的 AdviceAdapter 这样的类更加方便的获取到 hack 结点。其本质也是按 visitor 方法执行的顺序进行了二次封装，提供了诸如 onMethodEnter/onMethodExit 这样对开发者更友好的 API，方便我们更加关注于具体 hack 代码的生成，而不是纠结于 hack 结点的获取。\n\n## 总结\n\n在为 AOP 编程中最被推崇的 asm ,对于开发者来说，可以借助第三方插件帮我们实现插桩代码后，似乎已经变得非常简单。\n\n但是我们想一下，插件实现的插桩代码是不是有执行效率问题，是不是有潜在 bug，是不是完全符合我们的需求。而要解决这些问题，依旧需要我们去了解 虚拟机是如何加载字节码的，字节码中的代码又有怎样的规则，GETSTATIC，INVOKEVIRTUAL，pop,ALOAD_0……，这些指令到底是什么意思。想要真正用好 asm ,发挥其最大的威力，不仅要知其然，还要知其所以然。\n\n最后， 《深入理解 Java 虚拟机》真是一本值得读很多很多次的书。\n\n\n## 引用\n\n[asm 官方网站](https://asm.ow2.io/)（文档还是官方的稳）\n\n[asm 仓库全家桶](https://mvnrepository.com/artifact/org.ow2.asm)\n\n[AOP 的利器：ASM 3.0 介绍](https://www.ibm.com/developerworks/cn/java/j-lo-asm30/index.html)\n\n[深入字节码 -- 使用 ASM 实现 AOP](https://my.oschina.net/ta8210/blog/162796)\n\n[美团热更方案ASM实践](http://www.easemob.com/news/729)\n\n\n","tags":["ASM"]},{"title":"如何在代码里调用执行命令行（有可能持续更新）","url":"%2F2019%2F12%2F08%2F%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%2F","content":"\n## 前言\n\n在电脑上可以打开 cmd/powershell/iTerm2/Git Bash 进行命令行的操作，但是如何用其他语言比如 Python/Java 执行命令行呢？\n这么做当然不是闲的蛋疼，而是有些工作的确依赖这样的实现。\n\n<!--more-->\n\n## Java/Kotlin \n\nJava 和 Kotlin 本质上都是运行在 jvm 虚拟机上，都是调用 Runtime 接口提供的方法。以下以 Java为例。\n\n```java\npublic class CmdShell {\n    public static void main(String[] args) {\n        run();\n    }\n\n    private static void run() {\n        String os = System.getProperty(\"os.name\").toLowerCase();\n        System.out.println(os);\n        if (os.toLowerCase().contains(\"mac\")) {\n            runOnMac(\"ls\");\n            runOnMac(\"ls -hl\");\n            runOnMac(\"adb devices\");\n        } else if (os.contains(\"windows\")) {\n            runOnWindows(\"dir\");\n            runOnWindows(\"git log\");\n        }\n    }\n\n    private static void runOnWindows(String cmd) {\n        Runtime runtime = Runtime.getRuntime();\n        String realCmd = \"cmd /c \" + cmd;\n        try {\n            Process p = runtime.exec(realCmd);\n            String result = StreamUtil.StreamToStringWithReader(p.getInputStream());\n            String output = String.format(\"execute cmd : %s and result is \\n\\n%s \", cmd, result);\n            System.out.println(output);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void runOnMac(String cmd) {\n        Runtime runtime = Runtime.getRuntime();\n        try {\n            Process p = runtime.exec(cmd);\n            String result = StreamUtil.StreamToStringWithReader(p.getInputStream());\n            String output = String.format(\"execute cmd : \\\" %s \\\" and result is \\n\\n%s \", cmd, result);\n            System.out.println(output);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**需要注意的是**\n- Mac Os X 和 Windows 上对命令行执行机制有些区别，因此需要按平台做一下区分\n- exec 有一系列的重构方法可以调用\n\n<img src=\"如何调用命令行/exec.jpg\">\n\n\n## Android \n\nAndroid 应用层的实现，本质上还是 Java 或 Kotlin，因此代码实现基本和上面👆一致。但是本质上执行命令的还是内核，因此需要执行某些命令是需要权限的，具体权限可能和厂商对 ROM 的实现有关。一些比较有用的命令还是可以执行的比如，**pwd,ifconfig,ping**,但是 **ls** 命令是需要权限的(估计 root 之后的手机是可以的，2019 年想 root 一个手机忽然发现已经很难了 😢)。借助 ping 命令可以做网络相关的一些事情。\n\n\n<img width=30% src=\"如何调用命令行/ifconfig.png\"> <img width=30% src=\"如何调用命令行/ls.png\">\n\n\n\n## Python \n\n```python\nimport os\ndef os_open():\n    \"\"\"\n    popen方法通过p.read()获取终端输出，而且popen需要关闭close().\n    当执行成功时，close()不返回任何值，失败时，close()返回系统返回值..\n    可见它获取返回值的方式和os.system不同\n    强调的一点是，不支持参数，不支持管道\n    :return:\n    \"\"\"\n    out = os.popen(\"dir\")\n    print(out.read())\n    out.close()\n```\npopen返回的是一个file对象，跟open打开文件一样操作了，r是以读的方式打开. **用 python 执行命令行，最有意思的实现莫过于之前很火爆的微信小程序游戏《跳一跳》的 [刷分程序](https://github.com/wangshub/wechat_jump_game)。就是通过分析图片计算位置，然后在程序内调用 adb shell swipe x,y 命令实现的** \n\n## gralde \n\n这里的 gradle 指工程构建过程的 build.gralde 或 customXXX.gradle 脚本文件。在这些脚本文件中，其实也是可以执行命令行的。\n\n```gradle\ndef getGitBranch() {\n    def stdout = new ByteArrayOutputStream()\n    exec {\n        commandLine \"git\"\n        args \"rev-parse\", \"--abbrev-ref\", \"HEAD\"\n        standardOutput = stdout\n    }\n    return stdout.toString().trim()\n}\n\next {\n    getGitBranch = this.&getGitBranch\n}\n```\n这样就可以使用 gitGitBranch 方法获取当前工程的 git 分支了。可以看到**最核心的实现，就是把要执行的命令写到 exec 的闭包当中，然后用一个 OutputStream 的装饰器接收一下输出就可以了**。当然，如果你要执行的命令，不关注结果，输出就可以忽略了。\n\n## groovy\n\n我们知道 groovy 编译后的字节码也是在 JVM 虚拟机上执行。只是他作为一种动态类型的语言，使用起来比较灵活。在 groovy 中执行命令行和 gradle 非常相似.\n\n```groovy\nclass GitTool {\n     static String getGitBranch(Project project) {\n        def out = new ByteArrayOutputStream()\n        project.exec {\n            it.commandLine(\"git\")\n            it.args(\"rev-parse\", \"--short\", \"HEAD\")\n            it.standardOutput = out\n        }\n        return out.toString().trim()\n    }\n}\n```\n你可以理解为把闭包的实现给展开了。\n\n## JavaScript\n\n关于 JavaScript 这里简单讨论一下之前自己使用 Node 时的场景。浏览器内是如何一番场景，不太了解不做分析。\n\n```javascript\nfunction run_cmd(cmd, args, callBack ) {\n    var spawn = require('child_process').spawn;\n    var child = spawn(cmd, args);\n    var resp = \"\";\n\n    child.stdout.on('data', function (buffer) { resp += buffer.toString() });\n    child.stdout.on('end', function() { callBack (resp) });\n}\n\nrun_cmd( \"ls\", [\"-l\"], function(text) { console.log (text) });\n```\n\nrun_cmd 方法定义了具体实现，后续使用此方法即可。\n\n\n…… may be continued ","tags":["高效工作"]},{"title":"如何把Java文件打包为Jar文件","url":"%2F2019%2F09%2F12%2F%E5%A6%82%E4%BD%95%E6%8A%8AJava%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%BAJar%E6%96%87%E4%BB%B6%2F","content":"\n## 前言\n\n通过本文了解一下从 Java 文件生成可执行的 jar 文件的过程。**有时候我们在使用第三方 SDK 的时候，如果其内部实现有 bug 或接口定义不够灵活时会一时间束手无策。我们了解了 jar 文件的实现机制，就可以对 SDK 进行二次加工。** 在不做破坏性改动的前提下，给自己的开发工作带来遍历。\n\n<!--more-->\n\n## java 到 jar \n\n### 所有文件在一个包下\n\n在同一个包 src 下有下面两个类\n\n- People\n\n```java\npublic class People {\n    private String name;\n    private int age;\n\n    public People(String name,int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public void print() {\n        System.out.println(\"people : \"+this.name+\",\"+this.age);\n    }\n}\n```\n\n- Main \n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"hello world\");\n        People people = new People(\"mike\",22);\n        people.print();\n    }\n}\n```\n\n命令行执行 javac xxx.java 后会生成对应的 .class 文件，然后执行 **java Main** 输出：\n\n```shell\nhello world\npeople : mike,22\n```\n\n> 为了保持代码的整洁，可以使用  **javac -d xxx**\n>\n> -d 参数指定生成的 class 文件的位置。 \n\n为了方便，可以把 class 打包成 jar 文件，方便运行。\n\n#### jar 文件生成\n\n准备一个 manifest.txt 文件，需要以下内容\n\n```shell\nMain-Class: Main\n\n```\n\n> **Main 即包含 main 方法的那个类**\n>\n> **Main 和冒号之前一定要有空格，Main 后面一定要有换行**\n> \n> manifest.txt 最好和 Main 这个 class 文件在同一目录下\n\n然后执行命令：\n\n```shell\njar -cvmf mainfest.txt app.jar *.class\n```\n\n可以简单看一下 jar 这个命令的帮助文档 \n\n<details>\n<summary> jar --help</summary>\n\n```shell\n用法: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files ...\n选项:\n    -c  创建新档案\n    -t  列出档案目录\n    -x  从档案中提取指定的 (或所有) 文件\n    -u  更新现有档案\n    -v  在标准输出中生成详细输出\n    -f  指定档案文件名\n    -m  包含指定清单文件中的清单信息\n    -n  创建新档案后执行 Pack200 规范化\n    -e  为捆绑到可执行 jar 文件的独立应用程序\n        指定应用程序入口点\n    -0  仅存储; 不使用任何 ZIP 压缩\n    -P  保留文件名中的前导 '/' (绝对路径) 和 \"..\" (父目录) 组件\n    -M  不创建条目的清单文件\n    -i  为指定的 jar 文件生成索引信息\n    -C  更改为指定的目录并包含以下文件\n如果任何文件为目录, 则对其进行递归处理。\n清单文件名, 档案文件名和入口点名称的指定顺序\n与 'm', 'f' 和 'e' 标记的指定顺序相同。\n\n示例 1: 将两个类文件归档到一个名为 classes.jar 的档案中:\n       jar cvf classes.jar Foo.class Bar.class\n示例 2: 使用现有的清单文件 'mymanifest' 并\n           将 foo/ 目录中的所有文件归档到 'classes.jar' 中:\n       jar cvfm classes.jar mymanifest -C foo/ .\n```\n</details>\n\n这里**有一点非常重要的是 : m f 这两个指令的顺序要和后面 清单文件名和归档文件名的顺序保持一致**。切记，切记。\n\n即可生成一个可执行的 jar 文件，执行命令 **java -jar app.jar** 输出结果：\n\n```shell\nhello world\npeople : mike,22\n```\n\n> jar -tf xxx.jar 可以查看 jar 文件内容\n> \n> jar -xf xxx.jar 可以解压 jar 文件\n\n### java 文件在不同的包中\n\n上面是理想的情况，所有类在一个文件夹下（包）下，但是这是很少见的，为了代码规范及防止包名冲突等原因，一般情况下我们都会分包，根据业务或代码架构的层级会把 java 文件放到不同的包里。因此生成的 class 文件也在不同的包里。\n\n<img src=\"如何把Java文件打包为Jar文件/ui.jpg\" >\n\n\n如上图，在 com.ui 包下，包含一个文件批量重命名的功能，并且包含一个简单的 java Swing 实现的UI 选择器。对于文件批量重命名的功能，可以用各种各样的脚步语言实现，但是这样的一个 java Swing 实现方案，可以用**鼠标** 灵活的选择路径和各种配置，因此生成 jar文件之后，可以有很强的复用性。\n\n下面就来看看，对于一个在**包** 内的 java 类如何打包成 jar 文件。\n\n其实具体实现和上面没有 包是类似的，我们稍微想一下，对于多个包名的 java 是如何执行的就可以找到规律了。例如，对于上图中 App 类，出于 com.ui package下，那么相比于普通的类，在执行的时候包含包名就可以了\n\n```shell\njava com.ui.App\n```\n你可能会好奇了，那么这个命令应该在哪个路径下执行呢？在项目根目录执行似乎是不可以的。这个就要回归到 javac 命令的执行逻辑了。\n\n大部分情况下，我们都是使用诸如 Eclipse/IntelliJ 系列/vscode... 等这些 IDE 进行编码工作，当我们写完代码执行一个 run 或者是 build 功能的按钮或快捷键，所有的关于编译的工作和运行的工作（当然这里以熟悉的 Java 和 Kotlin 为例，C/C++ 可能还涉及更多的步骤，Python/js 可能只需要最终的解释执行，但这不是重点）都会由 IDE 默默为我们完成，让我们把精力集中在编码中，去解决更多业务相关的问题。\n\n比如上图的 Java 项目，在 IntelliJ IDEA 中，运行后会在 out 目录下（这个目录是默认的，可以手动配置更改） 生成相关的编译产物。\n\n<img src=\"如何把Java文件打包为Jar文件/class-dir.jpg\" >\n\n因此，刚才上面执行的命令，在这里的 out/production/JavaArt 目录下执行即可。\n\n到这一步，其实和普通的 jar 包生成就非常相似了\n\n1. manifext.txt 文件的准备\n\n    ```shell\n    Main-Class: com.ui.App\n\n    ```\n\n2. 打包命令\n\n    ```shell\n    jar -cvmf manifest.txt app.jar com/ui\n    ```\n\n就是就这么简单，Main-Class 需要根据包名指定要 main 方法所在的类，打包的时候指定具体要打包的目录即可。\n\n最终结果，生产了 app.jar 文件。\n\n\n<img src=\"如何把Java文件打包为Jar文件/result.jpg\" >\n\n可以通过 **jar -tf app.jar** 命令查看一下生成的 jar 文件包含些什么。\n\n<img src=\"如何把Java文件打包为Jar文件/info.jpg\" >\n\n可以看到包含了 ui 包下所有的 class文件。\n\n这样，这个 app.jar 就可以当做一个小小的可执行程序，之后需要文件批量重命名的场景，java jar app.jar 就可以打开一个简单的 UI 视图进行操作了。\n\n\n## javac -d \n\n除了使用 IDE 指定的默认路径之外，我们也可以使用 javac -d 在编译的时候指定自定义的路径，来规定 class 文件生成的路径。这个路径确定好之后，后续步骤和 对 IDE 生成的 class 的处理没有区别了。\n\n## 总结\n\n简单了解一下 jar 文件的生成，通过不带包名的实现入门，了解了对于包含包名的类（毕竟这才是常态）的处理。\n\n开篇提到的对第三方 SDK 的二次加工就不展开了，简单来说就是生成同名的类，替换原来的 class 二次打包的过程。但是具体实施过程中，还需要很多细节需要考虑，比如原文件包含混淆时如何处理，要生成的同名类，如果包名类包含对其他类的依赖又该如何处理。\n","tags":["jar"]},{"title":"Android 单元测试入门","url":"%2F2019%2F09%2F02%2F%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F","content":"\n\n## Unit Test\n\n<!-- TOC -->\n\n- [Unit Test](#unit-test)\n- [Start](#start)\n  - [JUnit](#junit)\n  - [参考资料](#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99)\n\n<!-- /TOC -->\n\n## Start\n\n简单了解一下，如何依赖 Junit 进行 Java 代码的单元测试。依旧如何借助 Robolectric 进行 Android 方面的单元测试，主要是 Context 的获取。最后就网络请求的单元测试，简单叙述一下。\n\n<!--more-->\n\n### JUnit \n\n  - 依赖 \n\n```groovy\ntestImplementation 'junit:junit:4.12'\n```\n\n  - example \n\n```java\n\npublic class Tools {\n    private static final String TAG = \"Tools\";\n\n    public static String getCurrentTime() {\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\", Locale.CHINA);\n        Date curDate = new Date(System.currentTimeMillis());\n        return simpleDateFormat.format(curDate);\n    }\n\n    public static String getCurrentTime(long tempStap) {\n      SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年\", Locale.CHINA);\n      Date curDate = new Date(tempStap);\n      return simpleDateFormat.format(curDate);\n    }\n}\n\n```\n```java\npublic class ToolsUnitTest {\n\n    @BeforeClass\n    public static void setUp() {\n        System.out.println( ToolsUnitTest.class.getSimpleName()+ \"=====单元测试开始\");\n    }\n\n    @AfterClass\n    public static void end() {\n        System.out.println( ToolsUnitTest.class.getSimpleName()+ \"=====单元测结束\");\n    }\n\n    @Test(expected = NullPointerException.class)\n    public void getCurrentTimeTest() {\n        assertNotEquals(\"1111\",Tools.getCurrentTime());\n        // 起码在 2019 年，这条测试是可以通过的\n        assertEquals(\"2019年\",Tools.getCurrentTime(System.currentTimeMillis()));\n    }\n}\n\n```\n执行顺序： @BeforeClass –> @Before –> @Test –> @After –> @AfterClass\n\n - 可用  API \n\n<img src=\"单元测试/assert_api.png\" width=40%/>\n\n都是 Assert 的静态方法，**对有返回值的方法，用断言非常好用**，你甚至可以测试异常\n\n\n\n- 高级用法\n  - @RunWith(Parameterized.class) 参数化\n  - assertThat用法\n  - @Rule用法\n\n\n- 问题来了\n\n```java\n public static String getAppVersion(Context mContext) { ... }\n ```\n \n Android 中的 context 怎么搞 ？\n\n\n### Robolectric\n\n - 配置\n    - 依赖\n    ```groovy\n    testImplementation 'androidx.test:core:1.2.0'\n    testImplementation 'androidx.test:rules:1.2.0'\n    testImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n    testImplementation 'org.robolectric:robolectric:4.3'\n    ```\n\n   - 允许 robolectric 读取 assets、resources 和 manifests，在 build.gradle 中添加\n\n  **一定要添加以下配置，否则将导致单元测试运行异常**\n\n  **一定要添加以下配置，否则将导致单元测试运行异常**\n\n  **一定要添加以下配置，否则将导致单元测试运行异常**\n\n    ```groovy\n    testOptions {\n        unitTests {\n            includeAndroidResources = true\n        }\n    }\n    ```\n\n    - 在 gradle.properties 中添加\n\n    ```groovy\n    android.enableUnitTestBinaryResources=true\n    ```\n\n - example \n\n ```kotlin\n\n@RunWith(RobolectricTestRunner::class)\n@Config(sdk = [27])\nclass RobolectricUnitTest {\n\n    @Test\n    fun assertContext() {\n        val context = ApplicationProvider.getApplicationContext<Context>()\n\n        val version = AppUtils.getAppVersion(context)\n        // 单元测试，也可以打印日志\n        println(\"version ==$version\")\n\n        assertEquals(\"1.0\", version)\n    }\n\n    companion object {\n\n        @BeforeClass\n        fun setup() {\n            // for Fresco\n            SoLoader.setInTestMode()\n        }\n    }\n}\n ```\n\n 单元测试也可以用 Kotlin 写，😬😬😬\n\n \n#### Context 是什么 ？\n\n```java\n@RunWith(RobolectricTestRunner.class)\n@Config(sdk = 28, manifest = Config.NONE)\npublic class ContextTest {\n\n    @Test\n    public void useContextTest() throws Utils.SystemUtilsException {\n        Context context = ApplicationProvider.getApplicationContext();\n\n        System.out.println(\"context ===\" + context.getClass().getName());\n\n        assertEquals(Constants.PACKAGE_NAME, Utils.getPackageName(context));\n        assertEquals(Constants.PACKAGE_VERSION, Utils.getPackageVersionName(context));\n    }\n\n    @Test\n    public void screenInfoTest() {\n        Context context = ApplicationProvider.getApplicationContext();\n        Resources resources = context.getResources();\n        DisplayMetrics displayMetrics = resources.getDisplayMetrics();\n        \n        float density = displayMetrics.density;\n        float width = displayMetrics.widthPixels;\n        float height = displayMetrics.heightPixels;\n\n        System.out.println(\"density==\" + density);\n        System.out.println(\"width  ==\" + width);\n        System.out.println(\"height ==\" + height);\n    }\n}\n```\n-output \n\n```bash\ndensity==1.0\nwidth  ==320.0\nheight ==470.0\n```\n\n- 可能遇到的问题\n  \n  Application 中某些方法无法被初始化，比如 Fresco，详见\n\n  [GitHub issue](https://github.com/facebook/stetho/issues/440)\n\n  [Fresco issue](https://github.com/facebook/fresco/issues/2060)\n\n   及解决方案。\n\n**Robolectric 很强大，可以在不使用真机及模拟器的情况下，进行 UI 测试**\n\nRobolectric 可以认为是一个虚拟的模拟器\n\n#### 网络测试 \n\n>网络测试有以下困难\n>- 请求结果是异步返回的，无法直接进行断言，需要进行同步转换\n>- 后端会做 cookie 和  headers 的校验，Robolectric 只是模拟器，请求时没有这些信息。\n对 okhttp 添加 intercept ，拦截返回值，进行任意返回结果，测试后续逻辑。\n\n- simple\n\n```java\n    @Test\n    public void netTest() {\n\n        final Retrofit mRetrofit = initRetrofit();\n\n        GankApi mGankApi = mRetrofit.create(GankApi.class);\n        Observable<GankAndroid> mAndroidObservable = mGankApi.getData(\"10/1\");\n        mAndroidObservable.subscribe(gankAndroid -> {\n            doAssert(gankAndroid.getResults().get(0));\n        }, throwable -> System.out.println(\"fail\"));\n    }\n\n    private void doAssert(GankAndroid.ResultsEntity entity) {\n        assertEquals(\"5d423ff19d2122031ea52264\", entity.get_id());\n        assertEquals(\"web\", entity.getSource());\n        assertEquals(\"Android\", entity.getType());\n        assertEquals(\"潇湘剑雨\", entity.getWho());\n    }\n```\n\n这个就可以对网络请求回来的数据，进行各种业务逻辑的测试了。\n\n但是也可以添加 interceptor ,创建特定的返回结果\n\n- 添加 Interceptor 拦截返回结果，方便测试后续逻辑。\n\n```java\n    @Test\n    public void netWithInterceptTest() {\n        String json = \"404\";\n        SimpleIntercept errorIntercept = new SimpleIntercept(json, 404);\n\n//        SimpleIntercept successIntercept = new SimpleIntercept(json, HTTP_OK);\n\n        final Retrofit mRetrofit = initRetrofit(errorIntercept);\n\n        GankApi mGankApi = mRetrofit.create(GankApi.class);\n        Observable<GankAndroid> mAndroidObservable = mGankApi.getData(\"10/1\");\n        mAndroidObservable.subscribe(gankAndroid -> {\n                },\n                throwable -> {\n                    // for example \n                    assertEquals(\"HTTP 404 404\", throwable.getMessage());\n                });\n    }\n```\n\n<details>\n<summary>SimpleIntercept</summary>\n\n```java\npublic class SimpleIntercept implements Interceptor {\n\n    private static final String APPLICATION_JSON = \"application/json\";\n\n    private String expectedResult;\n    private int code;\n\n    public SimpleIntercept(@NonNull String expectedResult, int code) {\n        this.expectedResult = expectedResult;\n        this.code = code;\n    }\n\n    @Override\n    public Response intercept(Chain chain) {\n        Response response = new Response.Builder()\n                .code(code)\n                .message(expectedResult)\n                .request(chain.request())\n                .protocol(Protocol.HTTP_1_1)\n                .body(ResponseBody.create(MediaType.parse(APPLICATION_JSON), expectedResult))\n                .addHeader(\"content-type\", APPLICATION_JSON)\n                .build();\n        return response;\n    }\n}\n```\n\n</details>\n\n\n### 参考资料\n\n[JUnit 入门](https://blog.csdn.net/qq_17766199/article/details/78243176)\n\n[Android单元测试(四)：Robolectric框架的使用](https://blog.csdn.net/qq_17766199/article/details/78710177)\n","tags":["单元测试"]},{"title":"kotlinc vs javac","url":"%2F2019%2F08%2F24%2Fkotlinc-vs-javac%2F","content":"\n\n# 前言\n\n对比一下 java 和 kotlin 编译源码文件（source.java 或 source.kt) 到 class 的区别。这种区别产生的结果是什么，看看其中的优缺点。\n\n<!--more-->\n\n## javac \n\n```java\npublic class Hello {\n    public static void main(String[] args) {\n      System.out.println(\"hello world\");\n    }\n}\n```\n\n以上代码执行 javac Hello.java 将生成 Hello.class 文件,用 javap 命令对生成的 Hello.class 文件做一下解析，得到结果\n\n### Hello.clsss 解析后的信息\n<details>\n<summary>点击展开</summary>\n\n\n```class\n\nClassfile /Users/mac/Desktop/javadir/Hello.class\n  Last modified 2019-8-24; size 415 bytes\n  MD5 checksum cb7981a0b53212d3f3005746f14b245a\n  Compiled from \"Hello.java\"\npublic class Hello\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #6.#15         // java/lang/Object.\"<init>\":()V\n   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;\n   #3 = String             #18            // hello world\n   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V\n   #5 = Class              #21            // Hello\n   #6 = Class              #22            // java/lang/Object\n   #7 = Utf8               <init>\n   #8 = Utf8               ()V\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               main\n  #12 = Utf8               ([Ljava/lang/String;)V\n  #13 = Utf8               SourceFile\n  #14 = Utf8               Hello.java\n  #15 = NameAndType        #7:#8          // \"<init>\":()V\n  #16 = Class              #23            // java/lang/System\n  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;\n  #18 = Utf8               hello world\n  #19 = Class              #26            // java/io/PrintStream\n  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V\n  #21 = Utf8               Hello\n  #22 = Utf8               java/lang/Object\n  #23 = Utf8               java/lang/System\n  #24 = Utf8               out\n  #25 = Utf8               Ljava/io/PrintStream;\n  #26 = Utf8               java/io/PrintStream\n  #27 = Utf8               println\n  #28 = Utf8               (Ljava/lang/String;)V\n{\n  public Hello();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 1: 0\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         3: ldc           #3                  // String hello world\n         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n         8: return\n      LineNumberTable:\n        line 3: 0\n        line 4: 8\n}\nSourceFile: \"Hello.java\"\n\n```\n\n</details>\n\n可以得到一些关键信息:\n\n- 生成的 .class 文件大小 415 bytes\n- .class 文件中除了 main 方法的指令之外，还默认添加了一个 Hello 类的构造函数，即 init 方法。\n\n## kotlinc \n\n下面看看，用 Kotlin 语言实现同样的功能，然后编译之后的.class 文件又是怎样的。\n\n### kotlinc \n\n### 安装 kotlinc \n> \n> 命令行输入\n> \n> brew install kotlin\n\n### Hello1.kt\n\n```kotlin\nobject Hello1 {\n    @JvmStatic\n    fun main(args: Array<String>) {\n        println(\"hello world\")\n    }\n}\n```\n这段代码和上述 Hello.java 是实现了同样的功能，方法参数也是一样。\n\n以上代码执行 kotlinc Hello1.kt 后将生成 Hello1.class 文件,用 javap 命令对生成的 Hello1.class 文件做一下解析，得到结果\n\n\n### Hello1.clsss 解析后的信息\n<details>\n<summary>点击展开</summary>\n\n```class\nClassfile /Users/mac/Desktop/javadir/Hello1.class\n  Last modified 2019-8-24; size 1236 bytes\n  MD5 checksum 884060fdf34740300f1c8d187afb4c6a\n  Compiled from \"Hello1.kt\"\npublic final class Hello1\n  minor version: 0\n  major version: 50\n  flags: ACC_PUBLIC, ACC_FINAL, ACC_SUPER\nConstant pool:\n   #1 = Utf8               Hello1\n   #2 = Class              #1             // Hello1\n   #3 = Utf8               java/lang/Object\n   #4 = Class              #3             // java/lang/Object\n   #5 = Utf8               main\n   #6 = Utf8               ([Ljava/lang/String;)V\n   #7 = Utf8               Lkotlin/jvm/JvmStatic;\n   #8 = Utf8               Lorg/jetbrains/annotations/NotNull;\n   #9 = Utf8               args\n  #10 = String             #9             // args\n  #11 = Utf8               kotlin/jvm/internal/Intrinsics\n  #12 = Class              #11            // kotlin/jvm/internal/Intrinsics\n  #13 = Utf8               checkParameterIsNotNull\n  #14 = Utf8               (Ljava/lang/Object;Ljava/lang/String;)V\n  #15 = NameAndType        #13:#14        // checkParameterIsNotNull:(Ljava/lang/Object;Ljava/lang/String;)V\n  #16 = Methodref          #12.#15        // kotlin/jvm/internal/Intrinsics.checkParameterIsNotNull:(Ljava/lang/Object;Ljava/lang/String;)V\n  #17 = Utf8               hello world\n  #18 = String             #17            // hello world\n  #19 = Utf8               java/lang/System\n  #20 = Class              #19            // java/lang/System\n  #21 = Utf8               out\n  #22 = Utf8               Ljava/io/PrintStream;\n  #23 = NameAndType        #21:#22        // out:Ljava/io/PrintStream;\n  #24 = Fieldref           #20.#23        // java/lang/System.out:Ljava/io/PrintStream;\n  #25 = Utf8               java/io/PrintStream\n  #26 = Class              #25            // java/io/PrintStream\n  #27 = Utf8               println\n  #28 = Utf8               (Ljava/lang/Object;)V\n  #29 = NameAndType        #27:#28        // println:(Ljava/lang/Object;)V\n  #30 = Methodref          #26.#29        // java/io/PrintStream.println:(Ljava/lang/Object;)V\n  #31 = Utf8               [Ljava/lang/String;\n  #32 = Utf8               <init>\n  #33 = Utf8               ()V\n  #34 = NameAndType        #32:#33        // \"<init>\":()V\n  #35 = Methodref          #4.#34         // java/lang/Object.\"<init>\":()V\n  #36 = Utf8               this\n  #37 = Utf8               LHello1;\n  #38 = Utf8               INSTANCE\n  #39 = Utf8               <clinit>\n  #40 = Utf8               Lkotlin/Metadata;\n  #41 = Utf8               mv\n  #42 = Integer            1\n  #43 = Integer            15\n  #44 = Utf8               bv\n  #45 = Integer            0\n  #46 = Integer            3\n  #47 = Utf8               k\n  #48 = Utf8               d1\n  #49 = Utf8               \u0000\u001c\\n\u0002\u0018\u0002\\n\u0002\u0010\u0000\\n\u0002\b\u0002\\n\u0002\u0010\u0002\\n\u0000\\n\u0002\u0010\u0011\\n\u0002\u0010\u000e\\n\u0000\bÆ\u0002\u0018\u00002\u00020\u0001B\u0007\b\u0002¢\u0006\u0002\u0010\u0002J\u001b\u0010\u0003\u001a\u00020\u00042\f\u0010\u0005\u001a\b\u0012\u0004\u0012\u00020\u00070\u0006H\u0007¢\u0006\u0002\u0010\b\n  #50 = Utf8               d2\n  #51 = Utf8\n  #52 = Methodref          #2.#34         // Hello1.\"<init>\":()V\n  #53 = NameAndType        #38:#37        // INSTANCE:LHello1;\n  #54 = Fieldref           #2.#53         // Hello1.INSTANCE:LHello1;\n  #55 = Utf8               Hello1.kt\n  #56 = Utf8               Code\n  #57 = Utf8               LineNumberTable\n  #58 = Utf8               LocalVariableTable\n  #59 = Utf8               RuntimeVisibleAnnotations\n  #60 = Utf8               RuntimeInvisibleParameterAnnotations\n  #61 = Utf8               SourceFile\n  #62 = Utf8               SourceDebugExtension\n{\n  public static final Hello1 INSTANCE;\n    descriptor: LHello1;\n    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL\n\n  public static final void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL\n    Code:\n      stack=2, locals=3, args_size=1\n         0: aload_0\n         1: ldc           #10                 // String args\n         3: invokestatic  #16                 // Method kotlin/jvm/internal/Intrinsics.checkParameterIsNotNull:(Ljava/lang/Object;Ljava/lang/String;)V\n         6: ldc           #18                 // String hello world\n         8: astore_1\n         9: iconst_0\n        10: istore_2\n        11: getstatic     #24                 // Field java/lang/System.out:Ljava/io/PrintStream;\n        14: aload_1\n        15: invokevirtual #30                 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V\n        18: return\n      LineNumberTable:\n        line 4: 6\n        line 5: 18\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      19     0  args   [Ljava/lang/String;\n    RuntimeVisibleAnnotations:\n      0: #7()\n    RuntimeInvisibleParameterAnnotations:\n      0:\n        0: #8()\n\n  static {};\n    descriptor: ()V\n    flags: ACC_STATIC\n    Code:\n      stack=2, locals=1, args_size=0\n         0: new           #2                  // class Hello1\n         3: dup\n         4: invokespecial #52                 // Method \"<init>\":()V\n         7: astore_0\n         8: aload_0\n         9: putstatic     #54                 // Field INSTANCE:LHello1;\n        12: return\n      LineNumberTable:\n        line 1: 0\n}\nSourceFile: \"Hello1.kt\"\nSourceDebugExtension:\n  SMAP\n  Hello1.kt\n  Kotlin\n  *S Kotlin\n  *F\n  + 1 Hello1.kt\n  Hello1\n  *L\n  1#1,6:1\n  *E\nRuntimeVisibleAnnotations:\n  0: #40(#41=[I#42,I#42,I#43],#44=[I#42,I#45,I#46],#47=I#42,#48=[s#49],#50=[s#37,s#51,s#33,s#5,s#51,s#9,s#51,s#51,s#6])\n\n```\n\n</details>\n\n可以得到一些关键信息:\n\n- 首先最直观的一点，这个 class 文件的信息变多了\n- Hello1.class 文件的信息，达到了 1236 bytes\n- 多出来的信息，主要是 SourceDebugExtension，RuntimeVisibleAnnotations，RuntimeInvisibleParameterAnnotations 和 LocalVariableTable（本地变量表的信息）\n- 构造函数的 init  基本相似，变化不大\n- 常量池 Constant Pool 变大了近乎一倍之多。\n- main 方法由于要做参数检测，也是变大了许多。\n\n\n# 总结\n\n## Hello.class vs Hello1.class \n\n最终直观感受一下：\n\n```shell\n-rw-r--r--   1 mac  staff   415  8 24 09:37 Hello.class\n-rw-r--r--@  1 mac  staff   114  8 24 08:37 Hello.java\n-rw-r--r--   1 mac  staff  1236  8 24 09:37 Hello1.class\n-rw-r--r--   1 mac  staff    92  8 24 09:34 Hello1.kt\n```\n\n用 kotlin 实现和 java 代码相同的功能，kotlin 在源文件上是占优的，这也是 kotlin 的优势，代码简洁，但是产生的代价就是 class 文件的变大(当然这里的为了实现 static 的 main 方法，使用了类似单例的写法，可能不太恰当，但是总体趋势是类似的)\n\n## 扩展\n\n我们知道 javac 编译生成的 xxx.class 文件是可以通过 java xxx 直接运行的，那么 kotlinc 生成的 yyy.class 文件改怎么运行呢？可以直接用 java yyy 吗？我们试一下\n\n```shell\n──> java Hello1                                                 ──(六, 824)─┘\nException in thread \"main\" java.lang.NoClassDefFoundError: kotlin/jvm/internal/Intrinsics\n\tat Hello1.main(Hello1.kt)\n```\n结果是不行的，虽然源码可以互相调用，但是 class 文件还的各来各的。因此需要用 kotlin yyy\n\n```shell\n──> kotlin Hello1                                           1 ↵ ──(六, 824)─┘\nhello world\n```\n\n\n\n\n","tags":["Kotlin"]},{"title":"ARouter API 简单分析","url":"%2F2019%2F07%2F20%2FARouter-API-%E5%88%86%E6%9E%90%2F","content":"\n<img src=\"ARouter-API-分析/contruct.png\" width=40%>\n\n## 前言\n\nARouter 使用已久，在组件化中非常有用，既解决了页面跳转的问题，同时还解决了同等级组件之间的依赖问题。这里结合源码分析一下其核心实现逻辑，本节主要分析其 API 的实现。同时结合之前[一个简单的路由](https://rebooters.github.io/2019/06/22/%E4%B8%80%E4%B8%AA%E8%B7%AF%E7%94%B1%E7%9A%84%E8%AF%9E%E7%94%9F/) 中我们对路由的思考来看看 ARouter 是怎么做的。\n\n<!--more-->\n\n\n\n## 基本功能\n\n对于 ARouter 来说，其最基本的用法便是其**初始化**和初级 **navigation** 的使用。这里就从 init 和 navigation 的基本用法出发，看看其中的奥秘。\n\n*基于 [ARouter GitHub 源码](https://github.com/alibaba/ARouter) arouter-api 1.5.0 版本分析*\n\n\n### init \n\nARouter 使用了门面模式，真正的实现都在 _ARoutre 里。其初始化的方法调用链如下\n\n<img src=\"ARouter-API-分析/init.png\" width=70%>\n\n核心逻辑在 LogisticsCenter.init(mContext, executor) 中\n\nexecutor 是一个自定义的线程池，关于如何使用 ThreadPoolExecutor 构建线程池，了解过 AsyncTask 的同学一定不陌生，老生常谈了，这里就不再赘述。\n\n<details>\n\n<summary>\nThreadPoolExecutor executor = DefaultPoolExecutor.getInstance();\n</summary>\n\n\n```java\npublic class DefaultPoolExecutor extends ThreadPoolExecutor {\n    //    Thread args\n    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();\n    private static final int INIT_THREAD_COUNT = CPU_COUNT + 1;\n    private static final int MAX_THREAD_COUNT = INIT_THREAD_COUNT;\n    private static final long SURPLUS_THREAD_LIFE = 30L;\n\n    private static volatile DefaultPoolExecutor instance;\n\n    public static DefaultPoolExecutor getInstance() {\n        if (null == instance) {\n            synchronized (DefaultPoolExecutor.class) {\n                if (null == instance) {\n                    instance = new DefaultPoolExecutor(\n                            INIT_THREAD_COUNT,\n                            MAX_THREAD_COUNT,\n                            SURPLUS_THREAD_LIFE,\n                            TimeUnit.SECONDS,\n                            new ArrayBlockingQueue<Runnable>(64),\n                            new DefaultThreadFactory());\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n</details>\n\n#### LogisticsCenter.init\n\n<details>\n<summary>\ninit \n</summary>\n\n\n```java\npublic synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException {\n        mContext = context;\n        executor = tpe;\n\n        try {\n            long startInit = System.currentTimeMillis();\n            //billy.qi modified at 2017-12-06\n            //load by plugin first\n            loadRouterMap();\n            if (registerByPlugin) {\n                logger.info(TAG, \"Load router map by arouter-auto-register plugin.\");\n            } else {\n                Set<String> routerMap;\n\n                // It will rebuild router map every times when debuggable.\n                if (ARouter.debuggable() || PackageUtils.isNewVersion(context)) {\n                    logger.info(TAG, \"Run with debug mode or new install, rebuild router map.\");\n                    // These class was generated by arouter-compiler.\n                    routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);\n                    if (!routerMap.isEmpty()) {\n                        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();\n                    }\n\n                    PackageUtils.updateVersion(context);    // Save new version name when router map update finishes.\n                } else {\n                    logger.info(TAG, \"Load router map from cache.\");\n                    routerMap = new HashSet<>(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, new HashSet<String>()));\n                }\n\n                logger.info(TAG, \"Find router map finished, map size = \" + routerMap.size() + \", cost \" + (System.currentTimeMillis() - startInit) + \" ms.\");\n                startInit = System.currentTimeMillis();\n\n                for (String className : routerMap) {\n                    if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) {\n                        // This one of root elements, load root.\n                        ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);\n                    } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) {\n                        // Load interceptorMeta\n                        ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);\n                    } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) {\n                        // Load providerIndex\n                        ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);\n                    }\n                }\n            }\n\n            logger.info(TAG, \"Load root element finished, cost \" + (System.currentTimeMillis() - startInit) + \" ms.\");\n\n            if (Warehouse.groupsIndex.size() == 0) {\n                logger.error(TAG, \"No mapping files were found, check your configuration please!\");\n            }\n\n            if (ARouter.debuggable()) {\n                logger.debug(TAG, String.format(Locale.getDefault(), \"LogisticsCenter has already been loaded, GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]\", Warehouse.groupsIndex.size(), Warehouse.interceptorsIndex.size(), Warehouse.providersIndex.size()));\n            }\n        } catch (Exception e) {\n            throw new HandlerException(TAG + \"ARouter init logistics center exception! [\" + e.getMessage() + \"]\");\n        }\n    }\n```\n</details>\n\n在 init 方法中，优先会调用 loadRouterMap ,在这里会由 arouter-auto-register 插件在编译期插入的代码自动注册路由表,这样 registerByPlugin = true ，上述代码中整个 else 分支就不会执行了。现在假设我们没有使用 arouter-auto-register 插件，那么就会执行下面的加载逻辑了。整个加载逻辑很简单，在 debug 模式或者是版本更新的情况下，会每次重新加载一份新的 class 信息，这些信息保存在一个 map 中；并把这份信息用 sp 直接存起来（感觉有点粗暴）；否则的话就每次从 sp 里读取类的信息。关键方法就是\n\n```java\nrouterMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);\n```\n这个 ClassUtils 很有意思,是直接从 galaxy 的 SDK copy 的 🐶🐶。\n\n```java\npackage com.alibaba.android.arouter.utils;\n\n// Copy from galaxy sdk ${com.alibaba.android.galaxy.utils.ClassUtils}\n\npublic class ClassUtils {\n}\n```\n>这里 **getFileNameByPackageName()** 这个方法顾名思义就是按按照包名获取文件名。 这个实现其实很有意思，他是**直接从 dex 文件获取 class 名称的，这里细节很简单就不展开了,可以参考[源码 ClassUtils](https://github.com/alibaba/ARouter/blob/master/arouter-api/src/main/java/com/alibaba/android/arouter/utils/ClassUtils.java) 。DexFile 类已经 Deprecated 了，但是依旧可以了解一下，在运行时如何读获取 apk 在手机上的位置，以及如何去获取 dex**.\n\n这里的 ROUTE_ROOT_PAKCAGE=“com.alibaba.android.arouter.routes”，最终获取的结果如下：\n\n<img src=\"ARouter-API-分析/routeMap.png\" width=70%>\n\n其实就是获取了所有由注解生成器生成的 class ，因为这些 class 包含了所有的路由信息。\n\n最后根据完整类名，对所有 class 简单做了一下归类。\n\n```java\n                for (String className : routerMap) {\n                    if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) {\n                        // This one of root elements, load root.\n                        ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);\n                    } \n                    ...else condition...\n                }\n```\n归类信息，存储在了 WareHouse 中。**可以再回顾一下上图中生成的 class 信息，每一个类的 classname 中， com.alibaba.android.arouter.routes.$$.xxx ,在 $$ 符后面有四类 packagename，包括 Group，Root,Interceptors 和 Providers。这些类之间的关系，简单来说， Group 是 Root,Interceptors , Providers 的子集。**\n\n<details>\n\n<summary>WareHouse</summary>\n\n```java\n\nclass Warehouse {\n    // Cache route and metas\n    static Map<String, Class<? extends IRouteGroup>> groupsIndex = new HashMap<>();\n    static Map<String, RouteMeta> routes = new HashMap<>();\n\n    // Cache provider\n    static Map<Class, IProvider> providers = new HashMap<>();\n    static Map<String, RouteMeta> providersIndex = new HashMap<>();\n\n    // Cache interceptor\n    static Map<Integer, Class<? extends IInterceptor>> interceptorsIndex = new UniqueKeyTreeMap<>(\"More than one interceptors use same priority [%s]\");\n    static List<IInterceptor> interceptors = new ArrayList<>();\n\n    static void clear() {\n        routes.clear();\n        groupsIndex.clear();\n        providers.clear();\n        providersIndex.clear();\n        interceptors.clear();\n        interceptorsIndex.clear();\n    }\n}\n\n```\n\n</details>\n\n可以看到所有的属性及方法都是静态的，你可以认为 WareHouse 就是一个运行期的全局仓库，存储了所有路由相关的信息。\n\n<img src=\"ARouter-API-分析/groupsIndex.png\" >\n\n**这里以 groupsIndex 为例，需要注意的是，在初始化的过程中，只是创建了 IRouteRoot 这个接口的实现类的实例，并添加到了相应的集合中。但是 Group 这个类并没有被实例话，这样这个接口的 loadInto 方法不会被调用。也就是说 ARouter 初始化的时候，并不会初始化所有的路由表中生成的 class。如上图 WareHouse 中现在存的都是一些*虚拟组*，真正的 RouteMate 还没有被添加 WareHouse 中。**\n\n<details>\n\n<summary> 举个例子 </summary>\n\nIRouteRoot 的某一个实现类\n\n```java\npublic class ARouter$$Root$$app implements IRouteRoot {\n  @Override\n  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {\n    routes.put(\"test\", ARouter$$Group$$test.class);\n    routes.put(\"yourservicegroupname\", ARouter$$Group$$yourservicegroupname.class);\n  }\n}\n```\nARouter$$Group$$test.class\n\n```java\npublic class ARouter$$Group$$test implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    atlas.put(\"/test/activity1\", RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, \"/test/activity1\", \"test\", new java.util.HashMap<String, Integer>(){{put(\"ser\", 9); put(\"ch\", 5); put(\"fl\", 6); put(\"dou\", 7); put(\"boy\", 0); put(\"url\", 8); put(\"pac\", 10); put(\"obj\", 11); put(\"name\", 8); put(\"objList\", 11); put(\"map\", 11); put(\"age\", 3); put(\"height\", 3); }}, -1, -2147483648));\n    atlas.put(\"/test/activity2\", RouteMeta.build(RouteType.ACTIVITY, Test2Activity.class, \"/test/activity2\", \"test\", new java.util.HashMap<String, Integer>(){{put(\"key1\", 8); }}, -1, -2147483648));\n    atlas.put(\"/test/activity3\", RouteMeta.build(RouteType.ACTIVITY, Test3Activity.class, \"/test/activity3\", \"test\", new java.util.HashMap<String, Integer>(){{put(\"name\", 8); put(\"boy\", 0); put(\"age\", 3); }}, -1, -2147483648));\n    atlas.put(\"/test/activity4\", RouteMeta.build(RouteType.ACTIVITY, Test4Activity.class, \"/test/activity4\", \"test\", null, -1, -2147483648));\n    atlas.put(\"/test/fragment\", RouteMeta.build(RouteType.FRAGMENT, BlankFragment.class, \"/test/fragment\", \"test\", null, -1, -2147483648));\n    atlas.put(\"/test/webview\", RouteMeta.build(RouteType.ACTIVITY, TestWebview.class, \"/test/webview\", \"test\", null, -1, -2147483648));\n  }\n}\n```\n</details>\n\n**展开上述代码，结合上面所叙述的内容。经过 init 归类之后，IRouteRoot 的某一个实现类（实际情况可能有多个，是由注解决定的）ARouter$$Root$$app 被添加到了 WareHouse.groupsIndex 集合中。但是 ARouter$$Root$$app 内部承载着另一个集合，这个集合才是最重要的，包含所有的 path 和 RouteMate 信息，但是这些信息并没有被加载。**\n\n#### 如何把所有元素都放到一个集合里 ？\n\n>关于这里的代码，还有一个有意思的点，就是如何向集合中添加元素。\n\n一般情况下，我们往集合里添加元素一般都是这么写\n\n```java\nlist.add(element)\n\nmap.put(\"key\",\"value\")\n```\n但是我们看上面 class 分组后添加到 WareHouse 仓库中的写法就很有意思了，简单翻译一下就是\n\n```java\n// 这里 new IRouteRoot 表达的意思是 IRouteRoot 这个接口的实现类\n// 的一个实例，并不是这个接口本身的实例，接口的实例本身也没有意义。\n\nnew IRouteRoot().loadInto(hashmap) \n```\n\n\n看一下 IRouteRoot \n\n```java\npublic interface IRouteRoot {\n\n    void loadInto(Map<String, Class<? extends IRouteGroup>> routes);\n}\n```\n\n他的一个实现类 ARouter$$Root$$app（是编译期 APT 生成的类，可以暂时忽略细节)\n\n<details>\n\n<summary>ARouter$$Root$$app</summary>\n\n```java\npublic class ARouter$$Root$$app implements IRouteRoot {\n  @Override\n  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {\n    routes.put(\"test\", ARouter$$Group$$test.class);\n    routes.put(\"yourservicegroupname\", ARouter$$Group$$yourservicegroupname.class);\n  }\n}\n```\n\n</details>\n\n其实本质都是一样，就是把 IRouteGroup 添加到一个 map 中。这里可以理解为通过 IRouteRoot 把**集合容器**注入到具体实现中，这里这么做是因为这个 map 的 key 是路由分组的组名（关于这个分组的概念，可以参考 ARouter 的使用），这个组名是定义在注解上的，是在编译期获取的，这样就可以在编译期直接按照组名把所有元素添加到 map 中 ,尽管此时 map 只是一个方法参数，并没有真正的 map 被创建。然后在运行期注入这个 map 容器，就完成了对 WareHouse 这个仓库的真正创建。\n\n当然，这里完全可以不这么做，编译期生成文件时，每个文件自己创建 map， 自己存数据，然后运行期把所有 map 中的数据在统一收集到 WareHouse 仓库中理论上也是可以的。\n\n个人感觉，使用容器注入的方式实现起来更加的友好和高效。本质来说，目标就是把所有类名加载到同一个集合中。\n\n##### 思考\n\n假设现在需要许多同等级业务组件把某个元素统一添加到一个集合中，但是这个集合属于上层业务，底层业务无法直接依赖整个集合的引用。也就是说不能直接 list.add(xxx),因为 list 在上层，不能被下层反向依赖。\n\n```java\npublic final class BusinessGod {\n    private List<String> allBusiness = new ArrayList<>();\n    private BusinessBlue mBusinessBlue;\n    private BusinessGreen mBusinessGreen;\n    private BusinessRed mBusinessRed;\n\n    ........\n}\n```\n如上 BusinessGod 作为顶级业务，依赖了 BusinessBlue，BusinessGreen，BusinessRed 这些底层业务。现在需要把一些核心信息收集到 allBusiness 这个集合中时，由于这个 引用无法被下层依赖，那么一种可行的做法便是依赖接口。我们定义接口\n\n\n```java\npublic interface IContainerInterface<T> {\n\n    void loadInto(List<? super T> list);\n}\n```\n然后让所有业务实现这个接口即可\n\n<details>\n\n<summary> 细节</summary>\n\n```java\npublic class BusinessBlue implements IContainerInterface<String>{\n\n    @Override\n    public void loadInto(List<? super String> list) {\n        list.add(\"this is blue\");\n    }\n}\n\npublic class BusinessRed implements IContainerInterface<String>{\n\n    @Override\n    public void loadInto(List<? super String> list) {\n        list.add(\"this is red\");\n    }\n}\n\npublic class BusinessGreen implements IContainerInterface<String> {\n\n    @Override\n    public void loadInto(List<? super String> list) {\n        list.add(\"this is green\");\n    }\n}\n```\n\n</details>\n\n这样我们就可以在顶层业务中，通过注入集合到底层业务的方式收集核心信息了\n\n```java\n    public List<String> getAllBusiness() {\n        mBusinessBlue.loadInto(allBusiness);\n        mBusinessGreen.loadInto(allBusiness);\n        mBusinessRed.loadInto(allBusiness);\n        return allBusiness;\n    }\n```\n这是一个关于如何把元素添加到一个集合的简单思考。\n\n\n### navigation \n\n说完了 init 下面看看 navigation。在 ARouter 里用 navigation 其实可以做许多事情，这里简答看一下，他是如何实现 Activity 跳转和 Fragment 获取的。\n\n#### Activity 跳转的实现\n\n简单起见，就以以下代码为例\n\n```java\n ARouter.getInstance()\n        .build(\"/test/activity2\")\n        .navigation();\n```\n\ngetInstance 就是获取 ARouter 的单例。\n\n##### build \n\n<img src=\"ARouter-API-分析/build.png\" width=40%>\n\n通过 build 方法返回了一个 PostCard 实例。PostCard 的可以理解为是包含整个路由信息的一个包装类。\n\n#### navigation \n\nnavigation 总的流程如下\n\n<img src=\"ARouter-API-分析/navigation.png\" >\n\n这里核心逻辑有两处 LogisticsCenter.completion(postcard) 和 _navigation(context, postcard, requestCode, callback)\n\n\n##### LogisticsCenter.completion(postcard)\n\n<details>\n\n<summary>completion</summary>\n\n```java\npublic synchronized static void completion(Postcard postcard) {\n        if (null == postcard) {\n            throw new NoRouteFoundException(TAG + \"No postcard!\");\n        }\n\n        RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());\n        if (null == routeMeta) {    // Maybe its does't exist, or didn't load.\n            Class<? extends IRouteGroup> groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  // Load route meta.\n            if (null == groupMeta) {\n                throw new NoRouteFoundException(TAG + \"There is no route match the path [\" + postcard.getPath() + \"], in group [\" + postcard.getGroup() + \"]\");\n            } else {\n                // Load route and cache it into memory, then delete from metas.\n                try {\n                    if (ARouter.debuggable()) {\n                        logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] starts loading, trigger by [%s]\", postcard.getGroup(), postcard.getPath()));\n                    }\n\n                    IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();\n                    iGroupInstance.loadInto(Warehouse.routes);\n                    Warehouse.groupsIndex.remove(postcard.getGroup());\n\n                    if (ARouter.debuggable()) {\n                        logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] has already been loaded, trigger by [%s]\", postcard.getGroup(), postcard.getPath()));\n                    }\n                } catch (Exception e) {\n                    throw new HandlerException(TAG + \"Fatal exception when loading group meta. [\" + e.getMessage() + \"]\");\n                }\n\n                completion(postcard);   // Reload\n            }\n        } else {\n            postcard.setDestination(routeMeta.getDestination());\n            postcard.setType(routeMeta.getType());\n            postcard.setPriority(routeMeta.getPriority());\n            postcard.setExtra(routeMeta.getExtra());\n\n            Uri rawUri = postcard.getUri();\n            if (null != rawUri) {   // Try to set params into bundle.\n                Map<String, String> resultMap = TextUtils.splitQueryParameters(rawUri);\n                Map<String, Integer> paramsType = routeMeta.getParamsType();\n\n                if (MapUtils.isNotEmpty(paramsType)) {\n                    // Set value by its type, just for params which annotation by @Param\n                    for (Map.Entry<String, Integer> params : paramsType.entrySet()) {\n                        setValue(postcard,\n                                params.getValue(),\n                                params.getKey(),\n                                resultMap.get(params.getKey()));\n                    }\n\n                    // Save params name which need auto inject.\n                    postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(new String[]{}));\n                }\n\n                // Save raw uri\n                postcard.withString(ARouter.RAW_URI, rawUri.toString());\n            }\n\n            switch (routeMeta.getType()) {\n                case PROVIDER:  // if the route is provider, should find its instance\n                    // Its provider, so it must implement IProvider\n                    Class<? extends IProvider> providerMeta = (Class<? extends IProvider>) routeMeta.getDestination();\n                    IProvider instance = Warehouse.providers.get(providerMeta);\n                    if (null == instance) { // There's no instance of this provider\n                        IProvider provider;\n                        try {\n                            provider = providerMeta.getConstructor().newInstance();\n                            provider.init(mContext);\n                            Warehouse.providers.put(providerMeta, provider);\n                            instance = provider;\n                        } catch (Exception e) {\n                            throw new HandlerException(\"Init provider failed! \" + e.getMessage());\n                        }\n                    }\n                    postcard.setProvider(instance);\n                    postcard.greenChannel();    // Provider should skip all of interceptors\n                    break;\n                case FRAGMENT:\n                    postcard.greenChannel();    // Fragment needn't interceptors\n                default:\n                    break;\n            }\n        }\n    }\n```\n\n</details>\n\n\n前面强调过，在 init 方法里，只是初始化了所有组的 class 信息，但组所在 class 中每一个元素是没有被初始化的。因此这里如果直接通过 path 去查找目标类是找不到的，因此可以理解为，每个组中第一次被使用的路由，肩负着整个组所有路由信息被加载到 WareHouse 仓库的重任，这个组的信息所有信息会被加载到 WareHouse.routes 这个集合中（准确来说是一个 map,path 为 key，RouteMate 为值的一个 HashMap)。同时会从 WareHouse.groupsIndex 中移除当前组，毕竟这一项已经没用了。然后再次递归调用一下自己，这一次就可以直接从 WareHouse.routes 这个集合中直接找到 path 对应的 RouteMate 了。如果再找不到，那就是什么地方出问题了，就报错了。\n\n**在初始化时只加载组信息的做法，可以说是非常巧妙，算的上是一种分治的思想。将所有路由 RouteMate 分组，减少初始化的压力，然后用到某个组的时候，才去初始化整个组内所有的 RouteMate 。这样，虽然可能会影响组内第一个使用的路由，但是总体来说还是值得的，毕竟减少了初始化的压力。甚至大部分情况下，用户使用时，常规的跳转可能也就那么几个，完全没有必要在初始化是加载所有的信息。当然，这种问题见仁见智，也许全部初始化也是一个不错的策略。**\n\n\n\n如果正确找到了目标 RouteMeta，在 else 分支里就会将目标类的所有信息传递到当前的 postcard 实例中。这里传递的信息包括目标类类名，路由优先级，路由类型，以及一些额外的参数信息，这些信息就包括我们在使用路由时执行 putInt,putString,putObject 传递的参数。ARouter 这里对对象的传递并没有直接传递对象，而是把对象反序列化为 Json ,当做普通的 String 进行传递和通信。\n\n**总的来说，成功调用 completion 方法之后，postcard 从编译期生成的类中获得了完整的信息，并且补充了额外的信息。可以说，此时 postcard 已经完整了，\b该有的信息都有了**，就可以为所欲为了 😏😏😏。\n\n \n在进行下一步之前，我们可以简单思考一下。这些目前为止，我们可以做什么 ？\n\n```java\n ARouter.getInstance()\n        .build(\"/test/activity2\")\n        .navigation();\n```\n\n其实到这里，我们通过一个简单的字符串 \"/test/activity2\" 就已经知道了很多信息\n\n- 他对应的类是 'com.alibaba.android.arouter.demo.testactivity.Test2Activity'\n- 对应类的类型是 Activity \n\n当然，如果注解里配置的信息再多一点，我们还可以获得更多的信息，包括这个路由的优先级以及他的 group 等等。\n\n**可以看到，实现页面跳转只是冰山一角，因为整个目标类的信息都完全获取到了，难道做一下跳转页面就完事了吗?(当然对于一个 Activity 来说，这样也不错，但如果目标类不单单是个 Activity 呢？是不是可以做的别的事情呢？👻👻👻👻👻👻👻👻)**\n\n\n##### _navigation(context, postcard, requestCode, callback)\n\npostcard 已经完全包含所有信息了，那么后续的逻辑展开就很简单了\n\n```java\nprivate Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n        final Context currentContext = null == context ? mContext : context;\n\n        switch (postcard.getType()) {\n            case ACTIVITY:\n                // Build intent\n                final Intent intent = new Intent(currentContext, postcard.getDestination());\n                intent.putExtras(postcard.getExtras());\n\n                // Set flags.\n                int flags = postcard.getFlags();\n                if (-1 != flags) {\n                    intent.setFlags(flags);\n                } else if (!(currentContext instanceof Activity)) {    // Non activity, need less one flag.\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                }\n\n                // Set Actions\n                String action = postcard.getAction();\n                if (!TextUtils.isEmpty(action)) {\n                    intent.setAction(action);\n                }\n\n                // Navigation in main looper.\n                runInMainThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        startActivity(requestCode, currentContext, intent, postcard, callback);\n                    }\n                });\n\n                break;\n            case PROVIDER:\n                return postcard.getProvider();\n            case BOARDCAST:\n            case CONTENT_PROVIDER:\n            case FRAGMENT:\n                Class fragmentMeta = postcard.getDestination();\n                try {\n                    Object instance = fragmentMeta.getConstructor().newInstance();\n                    if (instance instanceof Fragment) {\n                        ((Fragment) instance).setArguments(postcard.getExtras());\n                    } else if (instance instanceof android.support.v4.app.Fragment) {\n                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());\n                    }\n\n                    return instance;\n                } catch (Exception ex) {\n                    logger.error(Consts.TAG, \"Fetch fragment instance error, \" + TextUtils.formatStackTrace(ex.getStackTrace()));\n                }\n            case METHOD:\n            case SERVICE:\n            default:\n                return null;\n        }\n\n        return null;\n    }\n```\n\n可以看到，这里通过 postcard.getType() 可以获取到我们的路由是打在了什么**东西**上，对于 Activity 类型来说，就是我们最最熟悉的 startActivity 操作了，对于其类型，比如 Fragment，可以直接获取他的实例。\n\n可以看到，使用 ARouter 不仅仅可以实现页面跳转这么简单，本身也可以作为一个解决组件间依赖关系耦合的利器。\n\n```java\n Fragment fragment = (Fragment) ARouter.getInstance().build(\"/test/fragment\").navigation();\n                Toast.makeText(this, \"找到Fragment:\" + fragment.toString(), Toast.LENGTH_SHORT).show();\n```\n\n用 ARouter 实现页面跳转时还可以添加跳转动画，传参。这些其实都是对实现页面跳转的基础功能之上的装饰器写法，就不展开叙述了。\n\n拦截器的实现，在上述逻辑中已有分析，其实就是使用接口对对代码流程进行逻辑分发的一种实现。这种思想和 okhttp3 中拦截器的思路是一致的，在这里就是通过中间层把 postcard 暴露出来，给你一次机会，让你做一些 hack 的事情，让业务的实现更自由而已。 \n\n## 总结\n\n以上简单分析了一下 ARouter 中，路由 init 和 navigation 的实现。并就实现过程做了简单的思考。\n当然，ARouter 的定位远不止如此，正如其 [GitHub 描述](https://github.com/alibaba/ARouter/blob/master/README_CN.md)所讲，作为一个依赖注入的框架使用也是可以的。这里通过一个类图，在总结一下本节所讲到的所有类，加深一下映象。\n\n\n<img src=\"ARouter-API-分析/contruct.png\" width=60%>\n","tags":["ARouter"]},{"title":"简单实现 GIF 图的倒序播放","url":"%2F2019%2F07%2F07%2F%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-GIF-%E5%80%92%E5%BA%8F%E6%92%AD%E6%94%BE%2F","content":"\n\n\n## 前言\n\n经常在网上看到一些有意思的 GIF 图，有些 GIF 图倒放之后，甚至变得更有意思，简直是每日的快乐源泉;\n\n比如下面这个\n\n<img src=\"简单实现-GIF-倒序播放/haha.gif\" width=250 height=200 ><img src=\"简单实现-GIF-倒序播放/haha_revert.gif\" width=250 height=200>\n\n正放的时候很搞笑，很悲催；倒放的时候居然很炫酷，简直比段誉的凌波微步还牛逼，有没有一种盖世神功已练成的感觉 😎😎😎😎😎，是不是可以和绿巨人一战 😀😀。\n\n<!--more-->\n\n再来一个\n\n<img src=\"简单实现-GIF-倒序播放/haha1.gif\" width=200 height=300><img src=\"简单实现-GIF-倒序播放/haha1_revert.gif\" width=200 height=300>\n\n小男生的快乐与悲伤居然如此简单，嘤嘤婴 😊😊😊😊\n\n🤣🤣🤣🤣🤣🤣🤣🤣，真是能让人笑上三天三夜。下面就来看看如何实现 GIF 图的倒放。\n\n**以下所有实现细节源码已同步至 GitHub 仓库，可参考最后[源码](#源码)**\n\n<!-- TOC -->\n\n- [前言](#前言)\n- [GIF 是怎么播放的，如何把GIF倒序？](#gif-是怎么播放的如何把gif倒序)\n- [GIF 倒放的实现](#gif-倒放的实现)\n  - [从 GIF 图里把每一帧抠出来](#从-gif-图里把每一帧抠出来)\n    - [GifFrameLoader.loadNextFrame](#gifframeloaderloadnextframe)\n    - [获取每一帧图片并保存在集合中](#获取每一帧图片并保存在集合中)\n  - [用帧序列再次生成图片](#用帧序列再次生成图片)\n  - [GIF 倒放](#gif-倒放)\n    - [demo](#demo)\n- [总结](#总结)\n- [源码](#源码)\n- [参考文档](#参考文档)\n\n<!-- /TOC -->\n\n\n## GIF 是怎么播放的，如何把GIF倒序？\n\n想要倒放 GIF 图，首先了解一下 GIF 的原理；这里建议看看这篇来自腾讯手Q团队的文章[浓缩的才是精华：浅析GIF格式图片的存储和压缩](https://www.cnblogs.com/qcloud1001/p/6647080.html)。总的来说，GIF 和图通图片最大的不同点就是它是由许多帧组成的。既然如此我们很容易想到，从 GIF 里把所有帧拿出来，然后倒序组合这些帧，然后在合成一张 GIF 不就可以了吗？\n\n是的，道理就是就么简单。如果你现在去 Google GIF 倒序的实现，会看到很多 Python 的实现版本，类似如下：\n\n```python\nimport os\nimport sys\nfrom PIL import Image, ImageSequence\n\npath = sys.path[0]                          # 设置路径 -- 系统当前路径\ndirs = os.listdir(path)                     # 获取该路径下的文件\nfor i in dirs:                              # 循环读取所有文件\n    if os.path.splitext(i)[1] == \".gif\":    # 筛选gif文件\n        print(i)                            # 输出所有的gif文件名\n        #将gif倒放保存\n        with Image.open(i) as im:\n            if im.is_animated:\n                frames = [f.copy() for f in ImageSequence.Iterator(im)]\n                frames.reverse()  # 内置列表倒序\n                frames[0].save('./save/reverse_'+i+'.gif',save_all=True, append_images=frames[1:])# 保存\n```\n 不得不说，Python 的各种三方库的确很强大，几行代码就实现了 GIF 倒序的功能。但是作为一个稍微有点追求的人，难道就到此为止了吗？下次如果有个好玩的 GIF 图片，如果想看倒序图，难道还要打开电脑用用上述脚本转一次吗？\n\n\n <img src=\"简单实现-GIF-倒序播放/no_way.jpeg\" width=200>\n\n 尤其是作为一个 Android 开发者，这种事情用手机不也能做吗？为了每日的快乐源泉，就算天崩地裂，海枯石烂也要做出来（其实好像也不是很难o(╯□╰)o）\n\n\n <img src=\"简单实现-GIF-倒序播放/go.gif\" width=200>\n\n好了，不吹牛逼了，下面来看看怎么实现。\n\n## GIF 倒放的实现\n\n上面已经说过了，要实现 GIF 的倒序需要做三件事\n- 从 GIF 图里把每一帧摘出来，组成序列\n- 把序列逆序\n- 用逆序后的每一帧再重新生成一张新的 GIF 图\n\n上面两步，对集合逆序不是什么难事，主要看看如何实现第一步和第三步。\n\n### 从 GIF 图里把每一帧抠出来\n\n这个听起来很复杂，做起来好像也挺难，Android 没有提供类似的 API 可以做这件事，平时加载图片用的三方库 Glide，Fresco 等貌似也没有提供可以做类似事情的接口。但其实我们稍微深入看一下三方库是实现 GIF 播放的代码，就会找到突破口，这里以 Glide 为例,假设你研究过 Glide 的源码（如果没有看过，也不要紧，可以[略过这段，直接看实现](#get-frame-code)）\n\n\n#### GifFrameLoader.loadNextFrame\n\n在 GifFrameLoader 的 loadNextFrame 实现中（我们可以猜测到这就是 Glide 加载每一帧图片的实现）\n```java\nprivate void loadNextFrame() {\n    if (!isRunning || isLoadPending) {\n      return;\n    }\n    if (startFromFirstFrame) {\n      Preconditions.checkArgument(\n          pendingTarget == null, \"Pending target must be null when starting from the first frame\");\n      gifDecoder.resetFrameIndex();\n      startFromFirstFrame = false;\n    }\n    if (pendingTarget != null) {\n      DelayTarget temp = pendingTarget;\n      pendingTarget = null;\n      onFrameReady(temp);\n      return;\n    }\n    isLoadPending = true;\n    // Get the delay before incrementing the pointer because the delay indicates the amount of time\n    // we want to spend on the current frame.\n    int delay = gifDecoder.getNextDelay();\n    long targetTime = SystemClock.uptimeMillis() + delay;\n\n    gifDecoder.advance();\n    next = new DelayTarget(handler, gifDecoder.getCurrentFrameIndex(), targetTime);\n    requestBuilder.apply(signatureOf(getFrameSignature())).load(gifDecoder).into(next);\n  }\n```\n\n可以看到具体的实现是由 gifDecoder 这个对象实现的。这里最关键的一句就是 \n\n```java\ngifDecoder.advance();\n```\n我们可以看看这个方法的定义 \n\n```java\n  /**\n   * Move the animation frame counter forward.\n   */\n  void advance();\n```\n\n就是跳转到下一帧的意思。\n\n好了，至此我们知道如果可以获取到 GifDeCoder 和 GifFrameLoader 的实例，那么就可以手动控制和获取 GIF 图里每一帧了。但是，我们回过去看 Glide 提供的 API 发现，我们没有办法直接获取 GifFrameLoader 和 GifDeCoder，因为在源码里这些变量都是 private 的。🤦‍🤦‍🤦‍ ，难道这就走到了死胡同吗？不然，前人曾说过，编程领域的任何问题都可以通过添加一个中间层实现。我们这里的中间层就是 **反射**。使用反射可以获取就可以访问 GifFrameLoader 和 GifDeCoder 了；那么后续的实现就变得简单了。\n\n<span id=\"get-frame-code\">\n\n#### 获取每一帧图片并保存在集合中\n\n```kotlin\nGlide.with(mContext).asGif().listener(object :RequestListener<GifDrawable>{\n            \n            ...fail stuff...\n\n            override fun onResourceReady(resource: GifDrawable, model: Any?, target: Target<GifDrawable>?, dataSource: DataSource?, isFirstResource: Boolean): Boolean {\n                val frames = ArrayList<ResFrame>()\n                val decoder = getGifDecoder(resource)\n                if (decoder != null) {\n\n                    for (i in 0..resource.frameCount) {\n                        val bitmap = decoder.nextFrame\n                        val path = IOTool.saveBitmap2Box(context, bitmap, \"pic_$i\")\n                        val frame = ResFrame(decoder.getDelay(i), path)\n                        frames.add(frame)\n                        decoder.advance()\n                    }\n                }\n                return false\n            }\n\n        }).load(originalUrl).into(original)\n```\n\n这里的实现很简单，监听 GIF 的加载过程，加载成功后得到一个 GifDrawable 的实例 resource ,通过这个实例用反射的方式(具体实现可参考源码，非常简单)获取到了 GifDecode 的实例，有了这个实例就可以获取每一帧了，这里还需要记录一下每一帧播放时间间隔，返回的每一个帧就是一个 Bitmap ，我们把这些 Bitmap 保存在应用的安装目录下，然后用一个列表记录下所有帧的信息，包含当前帧的延迟时间和当前帧对应的 Bitmap 的存储路径。\n\n每一帧的集合序列有了，序列反转一行代码的事情，剩下的就是用这个序列生成新的 GIF 图片了。\n\n### 用帧序列再次生成图片\n\n用已有的图片组成和一个新的图片，这个并不是什么难事，网上已经有很多实现了。甚至包括 GIF 的再次生成，也可以借助 [GifMaker](https://github.com/LineChen/GifMaker) 这样的三方库完成。\n\n\n```kotlin\nprivate fun genGifByFrames(context: Context, frames: List<ResFrame>): String {\n        \n        val os = ByteArrayOutputStream()\n        val encoder = AnimatedGifEncoder()\n        encoder.start(os)\n        encoder.setRepeat(0)\n        for (value in frames) {\n            val bitmap = BitmapFactory.decodeFile(value.path)\n            encoder.setDelay(value.delay)\n            encoder.addFrame(bitmap)\n        }\n        encoder.finish()\n\n        val path = IOTool.saveStreamToSDCard(\"test\", os)\n        IOTool.notifySystemGallay(context, path)\n    \n        return path\n    }\n```\n借助 AnimatedGifEncoder 非常简单把之前保存的序列再次拼接成了一张新的 GIF 图。\n\n### GIF 倒放\n\n把上述三个步骤简单整理一下 \n\n```kotlin\n    private fun reverseRes(context: Context, resource: GifDrawable?): String {\n        if (resource == null) {\n            return \"\"\n        }\n        // 获取所有帧信息集合\n        val frames = getResourceFrames(resource, context)\n\n        // 逆序集合\n        reverse(frames)\n\n        // 生成新的 GIF 图片\n        return genGifByFrames(context, frames)\n    }\n```\n\n需要注意的是，这三步操作都是涉及到 UI 的耗时操作，因此这里简单用 RxJava 做了一次封装。然后就可以愉快的使用了。\n\n#### demo \n\n```kotlin\n        GifFactory.getReverseRes(mContext,source)\n                .subscribe { \n                    Glide.with(mContext).load(it).into(reversed)\n                }\n```\n\n<img src=\"简单实现-GIF-倒序播放/demo.gif\" width=320 height=564 >\n\n是的，就是这么简单，提供原始 GIF 资源的路径，即可返回实现倒序的 GIF 图。\n\n\n\n## 总结\n\n不得不说，Glide 的内部实现非常强大，对移动端图片加载的各种场景做了非常复杂的考虑和设计，因此也导致它的源码非常的难于阅读。但是，如果仅仅从某个的出发，比如缓存、网络、图片解码和编码的角度出发，脱离整个流程，去看局部还是有收获的。\n\n回到上述 GIF 倒序的步骤，总的来说有以下几个关键步骤\n\n  1. Glide 根据 URL 加载 GIF 图片，同时监听加载过程\n  2. 通过 GifDrawable 反射获取到 GifDecoder\n  3. 通过 GifDecoder 获取所有帧（包含保存这些帧 Bitmap）\n  4. 反转帧序列 frames\n  5. 通过 frame 再次生成 GIF 图片\n\n上述步骤中 1 和 4 的执行速度是基本上是线性的，也是无法再过多干预的。而步骤 2，3，5 也是 GIF 反转实现的核心，因此对方法耗时简单做了下记录。\n\n```shell\n\nGIF 图 size = 8.9M\n\nE/GifFactory: 方法: getGifDecoder        耗时 0.001000 second\nE/GifFactory: 方法: getResourceFrames    耗时 1.489000 second\nE/GifFactory: 方法: genGifByFrames       耗时 9.397000 second\n\nGIF 图 size = 11.9M\n\nE/GifFactory: 方法: getGifDecoder        耗时 0.000000 second\nE/GifFactory: 方法: getResourceFrames    耗时 1.074000 second\nE/GifFactory: 方法: genGifByFrames       耗时 9.559000 second\n\nGIF 图 size = 3.3M\n\nE/GifFactory: 方法: getGifDecoder        耗时 0.001000 second\nE/GifFactory: 方法: getResourceFrames    耗时 0.437000 second\nE/GifFactory: 方法: genGifByFrames       耗时 2.907000 second\n\nGIF 图 size = 8.1M\n\nE/GifFactory: 方法: getGifDecoder        耗时 0.000000 second\nE/GifFactory: 方法: getResourceFrames    耗时 0.854000 second\nE/GifFactory: 方法: genGifByFrames       耗时 6.416000 second\n```\n\n可以看到，虽然我们获取 GifDecoder 的过程使用了反射，但其实这比不是性能瓶颈；获取所有帧信息的方法 getResourceFrames 耗时，也是和 GIF 图的大小有关，基本上是一个可接受的值。但是通过帧序列再次生成 GIF 图的方法执行时间就有点恐怖了，即便我的测试机是 kirin（麒麟）960 ，运行内存有 6G 😳😳。\n\n但是同样的图片在 PC 上用 Python 脚本基本上是毫秒级完成。所以纯粹用 java 实现（AnimatedGifEncoder 是 java 写的，不算 kotlin 👀）图片二次编码还是有些性能差距的。\n\n\n虽然，此次的实现转换较慢，但也算是一次不错的尝试吧。\n\n\n## 源码\n\n本文所有实现细节源码已同步至 GitHub 仓库 [AndroidAnimationExercise](https://github.com/REBOOTERS/AndroidAnimationExercise), 可以参考 [ReverseGifActivity](https://github.com/REBOOTERS/AndroidAnimationExercise/blob/master/imitate/src/main/java/com/engineer/imitate/ui/activity/ReverseGifActivity.kt)\n\n## 参考文档\n\n[浓缩的才是精华：浅析GIF格式图片的存储和压缩](https://www.cnblogs.com/qcloud1001/p/6647080.html)","tags":["Glide"]},{"title":"一个简单的路由","url":"%2F2019%2F06%2F22%2F%E4%B8%80%E4%B8%AA%E8%B7%AF%E7%94%B1%E7%9A%84%E8%AF%9E%E7%94%9F%2F","content":"\n## 前言\n\n在页面跳转的过程中，使用路由已不是什么新鞋事，市面上已经有很多库可以做这件事，比如 [ARouter](https://github.com/alibaba/ARouter), [WMRouter](https://github.com/meituan/WMRouter),[Router](https://github.com/chenenyu/Router)[等等](https://github.com/search?l=Java&q=Router&type=Repositories)。\n这些路由框架，都是使用 APT 的原理来实现的。通过之前的 [注解处理器APT初探](https://rebooters.github.io/2019/06/03/注解处理器APT初探)、[SugarAdapter 注解处理器分析](https://rebooters.github.io/2019/06/04/SugarAdapter-%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E5%88%86%E6%9E%90/) ，我们对 APT 的使用有了一些认识。\n\n因此，这里我们简单尝试一下，实现一个**史上最最简单**的路由。通过这个过程我们可以了解一下，实现一个真正好用的路由，需要考虑哪些问题，又有哪些难点需要去处理。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [前言](#前言)\n- [史上最简单路由的诞生](#史上最简单路由的诞生)\n  - [目标](#目标)\n  - [路由表生成](#路由表生成)\n    - [注解定义](#注解定义)\n    - [注解处理](#注解处理)\n    - [生成代码](#生成代码)\n    - [小结](#小结)\n  - [路由 API](#路由-api)\n    - [槽点](#槽点)\n- [一个高效的路由应该是什么样子的](#一个高效的路由应该是什么样子的)\n  - [需求推动技术](#需求推动技术)\n- [总结](#总结)\n\n<!-- /TOC -->\n\n\n\n## 史上最简单路由的诞生\n\n### 目标\n\n作为史上最简单的路由，我们的目标很简单，**用路由的方式实现 Activity 的跳转**\n\n```java\n          mJump.setOnClickListener(v ->\n                QRouterApi.go(this, \"/activity/second\")\n        );\n```\n```java\n@QRouter(\"/activity/second\")\npublic class SecondActivity extends AppCompatActivity {\n  ....onCreate .... stuff ...\n}\n```\n上述点击事件，可以正确跳转到 **\"/activity/second\"** 注解所在的 SecondActivity(假设我们现在无法直接依赖 SecondActivity.class,😎😎)\n\n下面就一步一步走，看看如何实现这个简单的小目标。\n\n### 路由表生成\n\n#### 注解定义\n\n```java\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface QRouter {\n    String value();\n}\n```\n首先，为路由定义一个注解 QRouter，只接受一个参数，也就是路由地址。\n\n#### 注解处理\n\n关于注解处理器的使用细节这里就不再赘述，[注解处理器APT初探](https://rebooters.github.io/2019/06/03/注解处理器APT初探) 已经有过深入分析了。这里直接分析看看 process 如何实现。\n\n```java\n  @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        mMessager.printMessage(Diagnostic.Kind.NOTE, \"processing....\");\n\n\n        Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(QRouter.class);\n        for (Element element : elements) {\n            if (element instanceof TypeElement) {\n                \n\n                if (mQRouterCreatorProxy == null) {\n                    mQRouterCreatorProxy = new QRouterCreatorProxy(mElementUtils, (TypeElement) element);\n                }\n\n                QRouter routerAnnotation = element.getAnnotation(QRouter.class);\n                String router = routerAnnotation.value();\n                String target = ((TypeElement) element).getQualifiedName().toString();\n\n                mQRouterCreatorProxy.putElement(router, target);\n\n            } else {\n                mMessager.printMessage(Diagnostic.Kind.ERROR, \"annotation on mistake type, the type should be class\");\n            }\n        }\n\n        generateRouterTable();\n\n        return true;\n    }\n```\n\n这里还是沿袭之前 BingView 的思路，用代理类 QRouterCreatorProxy 处理所有的关键信息，processor 将我们需要的信息，即\n\n```java\n String router = routerAnnotation.value();\n String target = ((TypeElement) element).getQualifiedName().toString();\nmQRouterCreatorProxy.putElement(router, target);\n```\n注解的路由地址和路由所在的目标类，通过 mQRouterCreatorProxy 做一次聚合。这样代理类包含了所有的路由信息，接下来就是通过这些信息，生成一些代码。\n\n那么要生成什么样的代码呢？想想我们的目标，**通过路由打开 Activity** 。那么我们很容易想到的一种做法，就是建立一个 路由和 Activity 的对应关系，然后通过这个关系找到对应的 Activity 。下面就按照这个思路来生成代码。\n\n#### 生成代码\n\n```java\nprivate void generateRouterTable() {\n        TypeSpec typeSpec = mQRouterCreatorProxy.genCode();\n        String packageName = mQRouterCreatorProxy.getPackageName();\n        JavaFile javaFile = JavaFile.builder(packageName, typeSpec).build();\n        try {\n            javaFile.writeTo(mFiler);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n```\n - gencode 的实现\n\n```java\npublic class QRouterCreatorProxy {\n    private static final String Q_ROUTER_CLASS_NAME = \"QRouterTable\";\n\n    public TypeSpec genCode() {\n        TypeSpec typeSpec = TypeSpec.classBuilder(Q_ROUTER_CLASS_NAME)\n                .addModifiers(Modifier.FINAL, Modifier.PUBLIC)\n                .addMethod(genRouterTable())\n                .build();\n        return typeSpec;\n    }\n}\n```\n\n这里首先会生成一个名为 QRouterTable 的类，是 final 且 public 类型的，并且还包括一个方法，继续看\n\n\n- genRouterTable 实现\n\n```java\npublic class QRouterCreatorProxy {\n  \n    private HashMap<String, String> elements = new HashMap<>();\n    \n    public void putElement(String router, String targetClass) {\n        elements.put(router, targetClass);\n    }\n\n    /**\n     * @return HashMap<String, String>\n     */\n    private MethodSpec genRouterTable() {\n         /*\n         ```Map<String, String>```\n         */\n        ParameterizedTypeName inputMapTypeOfGroup = ParameterizedTypeName.get(\n                ClassName.get(Map.class),\n                ClassName.get(String.class),\n                ClassName.get(String.class)\n        );\n        \n        MethodSpec.Builder builder = MethodSpec.methodBuilder(\"map\")\n                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n                .returns(inputMapTypeOfGroup);\n\n        builder.addCode(\"\\n\");\n        builder.addStatement(\"$T<$T,$T> tables=new $T()\", HashMap.class, String.class, String.class, HashMap.class);\n        builder.addCode(\"\\n\");\n\n        for (String key : elements.keySet()) {\n            String target = elements.get(key);\n            String code = \"tables.put(\\\"\" + key + \"\\\",\\\"\" + target + \"\\\");\\n\";\n            builder.addCode(code);\n        }\n        builder.addCode(\"return tables;\\n\");\n        return builder.build();\n    }\n}\n```\n\nelements 这个散列表里存储的就是路由关系信息。\n\n- 首先会创建方法声明，是一个 名为 map 返回值为 HashMap<String, String>，final 且 public 类型的方法。\n- 然后，在方法体里通过 addStatement 初始化一个 HashMap<String, String> ，接下来就开始遍历 elements 这个 hashmap ，把之前存储的路由信息，转换成代码的方式进行存储。\n- 最后，返回第二步创建的 HashMap<String, String> 实例即可。\n\n最终我们要生成的代码如下 ：\n\n\n```java\npublic final class QRouterTable {\n  public final Map<String, String> map() {\n\n    HashMap<String,String> tables=new HashMap();\n\n    tables.put(\"/activity/simple\",\"com.engineer.aptlite.SimpleActivity\");\n    tables.put(\"/activity/second\",\"com.engineer.aptlite.SecondActivity\");\n    return tables;\n  }\n}\n```\n\n#### 小结\n\n至此，我们已经生成了路由表（这里就是一个包含路由和目标 Class 关系的 HashMap)。可以看到，使用 javapoet 生成代码和我们手动写代码的思路是一样的，只不过手写的时候每一个子母都是我们敲出来的(ide 辅助生成，其实也可以理解为手动敲出来的代码吧 🤔🤔)，javapoet 通过某些特定的 api 可以帮助我们生成这些代码。本质上都是写文件的过程。javapoet 之于java 程序员，就如同 输入法之于铅笔、钢笔或毛笔吧。\n\n### 路由 API \n\n路由表已经生成了，那么我们改如何使用这张路由表呢？ 想想我们的目标，**通过路由打开 Activity**，路由表里存着路由和目标 Class 的对应关系，那么事情就很简单了。\n\n```java\npublic class QRouterApi {\n\n    public static void go(Activity activity, String route) {\n        try {\n            long begin = System.currentTimeMillis();\n            String log;\n            \n            Class tableClass = Class.forName(\"com.engineer.aptlite.QRouterTable\");\n            Method methodMap = tableClass.getMethod(\"map\", null);\n            HashMap<String, String> tables = (HashMap<String, String>) methodMap.invoke(tableClass.newInstance(), null);\n\n            System.err.println(\"tables===\" + tables);\n\n            String target = tables.get(route);\n\n            log = String.format(Locale.CHINA, \"use %f to find the target\", 1000f * (System.currentTimeMillis() - begin));\n            System.err.println(log);\n\n            if (!TextUtils.isEmpty(target)) {\n                Class targetClass = Class.forName(target);\n                Intent intent = new Intent(activity, targetClass);\n                activity.startActivity(intent);\n\n                log = String.format(Locale.CHINA, \"use %f to finish\", 1000f * (System.currentTimeMillis() - begin));\n                System.err.println(log);\n            }\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } \n        .... other execption stuff...\n    }\n}\n```\n这个静态方法 go(activity,route) 的核心\n\n- Class tableClass = Class.forName(\"com.engineer.aptlite.QRouterTable\"); 加载路由表\n- 反射获取 hashmap 的实例\n- String target = tables.get(route); 从 hashmap 中找到路由地址对应的 Class \n- Class targetClass = Class.forName(target); 加载这个 Class\n- 创建 Intent 实例，然后 startActivity(intent) 实现 Activity 的跳转。\n\n**以上实现，为史上最简单、最丑陋且最低效路由跳转 Activity 的方法，看完之后，请立刻遗忘 😳😳**\n\n这样，我们通过调用 \n\n```java\nQRouterApi.go(this, \"/activity/second\")\n```\n就可以打开 @QRouter(\"/activity/second\") 这个注解所在的 Activity 了。有兴趣的同学可以[参考源码](https://github.com/REBOOTERS/APT-Lite)，简单体验一下效果。\n\n#### 槽点\n\n在我们思考什么是高效路由之前，首先简单总结一下这个史上最简单路由有哪些问题（以目标为导向来对比）\n\n- go 方法多次使用发射，效率堪忧。目标 Class 其实是可以直接获取到，在编译期在 HashMap 中存储的时候，可以直接保存 Class，而不是 Class 路径的字符串。\n- 无法支持 startActivityForResult 的情景\n- 没有很好的容错机制\n\n## 一个高效的路由应该是什么样子的\n\n看完上面的实现，我们可以看到，如果只是为了简单纯粹的解耦，解决类依赖的问题，那么路由的实现其实是比较简单的。但实际情况中，并不是这样。一个高效的路由框架需要考虑的点其实很多。\n\n- **支持数据通信**\n\n支持数据通信，其实是一件即可以很简单，又会很复杂的事情。路由地址本质上是一个字符串，对于基本的数据类型 int,float,char 以及 String ，我们可以把需要传递的参数直接写在路由地址上，或 path 或 query中。最终通过解析 URL 都是可以解析到的。但是对于对象来说，就比较难了。Android 中传递对象采用的 Intent 携带 bundle 的机制。路由地址仅仅是一个字符串，是无法直接完成对象传递的。那么是否有其他的方法呢？再有对于基础数据类型，如果区分参数和实际地址呢？\n\n- **高效准确，不能比原生的跳转机制差**\n\n这个是必须的，使用路由，少不了路由匹配的过程，但并不能因此，导致页面跳转时间变长，让用户体验变得糟糕。\n\n- 有很好的容错机制，或者说是降级策略\n\n路由地址写错了，或着是目标路由因为某些原因不存在了，是否可以有很好的降级策略，而不是简单的报错或无响应。\n\n- 路由跳转有拦截机制或优先级机制\n\n在多人协作的开发中，路由地址同名是不太好避免的（一种可行的方案是把所有路由地址定义在一个公共的地方），对于已然无法改动的代码，是否可以通过添加 Interceptor(类似 OKHTTP 的思路) 或定义优先级的方式，解决有冲突的路由；或者因某些特殊业务的需求，可以更改路由原始的跳转行为。\n\n- 支持组件化（即多 module 的情形）\n\n组件化开发已经成为大型项目的标准，路由的 APT 实现是否可以完美应对多 module 情形下路由表的正确创建及查找解析。\n\n- 编译期生成代码，不要太耗时\n\n随着使用 APT 的库越来越多，在编译期要做的事情也越多越多，那么是否可以保证在编译期生成代码的过程，可以高效快速的完成（比如增量编译），保证开发人员的效率不受影响。\n\n更多。。。\n\n以上这些点，应该是一个合格的路由应该支持的基础功能（纯属个人观点，😎😎😎😎）。[ARouter](https://github.com/alibaba/ARouter) 在 GitHub 已经有 1 万+ 的 star，说明他还是很受开发者认可的。它的实现是否满足了上述要求，以及它又有哪些独有的特点，我们可以带着这些疑问去学习一下他的实现。\n\n### 需求推动技术\n\n很多时候，都是需求推动技术进步，没有完美的框架，很多时候都是需要基于特定的业务实施特定的方案，因此。路由也是这样。\n\n\n## 总结\n\n回归到本质，在注解处理器的 process 方法中，我们通过\n\n```java\nSet<? extends Element> elements = roundEnv.getElementsAnnotatedWith(QRouter.class);\n```\n\n这里的 Element 包含着这个注解所在类的全部信息，包括他所在类以及他的父类等各种信息，有了这些信息我们可以做很多事情。\n\n就比如这里的 QRouter 注解，把这个注解打在 Activity 上，并在编译期生成路由表，而在运行时通过路由表里的信息，在特定的 API 里封装的 startActivity 这种类似模板的代码，对外暴露了更轻量级的 API，使得页面的跳转实现变得似乎简单了许多。\nAPI.go 一行简单的代码简化了原本的复杂实现，对开发者来说更加友好了。\n\n路由的实现，在某些方面还是非常依赖具体业务规范的。没有完美的路由，只有合适的路由。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Router"]},{"title":" 安装 go2shell 到 Finder 工具栏的方法","url":"%2F2019%2F06%2F21%2F%E5%AE%89%E8%A3%85-go2shell-%E5%88%B0-Finder-%E5%B7%A5%E5%85%B7%E6%A0%8F%E7%9A%84%E6%96%B9%E6%B3%95%2F","content":"\nMac 上使用 go2shell 的正确方式\n\n1. [go2shell 官网](https://zipzapmac.com/go2shell) 或 App Store 下载 go2shell 安装\n2. 从 Finder Application 目录下,按住 Command 键，拖动 go2shell 应用程序到 Finder 工具栏\n\n<!--more-->\n\n<img src=\"安装-go2shell-到-Finder-工具栏的方法/install.webp\">\n\n3. 在需要打开的目录，点击图标即可\n\n<img src=\"安装-go2shell-到-Finder-工具栏的方法/result.png\">","tags":["高效工作"]},{"title":"用 SugarAdapter 简化复杂列表的实现","url":"%2F2019%2F06%2F16%2F%E7%94%A8-SugarAdapter-%E7%AE%80%E5%8C%96%E5%A4%8D%E6%9D%82%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F","content":"\n<img src=\"用-SugarAdapter-简化复杂列表的实现\\SugarAdapter.png\" width=500>\n\n## 前言\n\n在一个 App 中 Feed 流类型的页面非常依赖 RecyclerView 的使用，有大量的列表。而列表中卡片(即列表中的 Item，以下统称卡片)有很多种样式，并且不同的样式对应的不同的业务需求，使得 Adapter 的实现非常的爆炸，因此需要一种合适的方式去实现 Adapter。\n\n本文结合日常开发的场景，简单分析一下，使用常规手法如何最大的程度的优化 RecyclerView 的 Adapter 的实现。最后分析一下 SugarAdapter，看看使用它是如何解决常规实现痛点的。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [前言](#%e5%89%8d%e8%a8%80)\n- [SugarAdapter 是什么 ？](#sugaradapter-%e6%98%af%e4%bb%80%e4%b9%88)\n- [常规的 Adapter 有什么痛点](#%e5%b8%b8%e8%a7%84%e7%9a%84-adapter-%e6%9c%89%e4%bb%80%e4%b9%88%e7%97%9b%e7%82%b9)\n  - [ViewHolder 的本质](#viewholder-%e7%9a%84%e6%9c%ac%e8%b4%a8)\n- [SugarAdapter 如何解决了这些痛点](#sugaradapter-%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e4%ba%86%e8%bf%99%e4%ba%9b%e7%97%9b%e7%82%b9)\n  - [Layout &amp; ViewHolder](#layout-amp-viewholder)\n  - [SugarAdapter](#sugaradapter)\n    - [Build 模式](#build-%e6%a8%a1%e5%bc%8f)\n      - [Container](#container)\n    - [add() 的具体实现](#add-%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0)\n    - [Sugar](#sugar)\n  - [痛点如何被消除](#%e7%97%9b%e7%82%b9%e5%a6%82%e4%bd%95%e8%a2%ab%e6%b6%88%e9%99%a4)\n    - [getItemViewType](#getitemviewtype)\n    - [onCreateViewHolder](#oncreateviewholder)\n    - [onBindViewHolder](#onbindviewholder)\n    - [小结](#%e5%b0%8f%e7%bb%93)\n- [SugarAdapter 还能做什么](#sugaradapter-%e8%bf%98%e8%83%bd%e5%81%9a%e4%bb%80%e4%b9%88)\n  - [“一种” 数据对应不同的样式](#%e4%b8%80%e7%a7%8d-%e6%95%b0%e6%8d%ae%e5%af%b9%e5%ba%94%e4%b8%8d%e5%90%8c%e7%9a%84%e6%a0%b7%e5%bc%8f)\n    - [规则](#%e8%a7%84%e5%88%99)\n  - [生命周期回调 和 Lifecycleowner 的支持。](#%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%9b%9e%e8%b0%83-%e5%92%8c-lifecycleowner-%e7%9a%84%e6%94%af%e6%8c%81)\n- [总结](#%e6%80%bb%e7%bb%93)\n\n<!-- /TOC -->\n\n\n\n## SugarAdapter 是什么 ？\n\n>[SugarAdapter](https://github.com/zhihu/SugarAdapter),        Make RecyclerView.Adapter Great Again!\n\n## 常规的 Adapter 有什么痛点\n\n面对一个有上百种卡片样式的 RecyclerView ，简单粗暴的做法可能就是把所有可能需要显示的 UI 元素怼在一个 xml 布局文件里，然后在 Adapter 里根据数据对 view 做 visible/invisible/gone 及 setXXX 的操作，这无疑是最糟糕的做法，代码会爆炸，性能更是堪忧，基本上就无法维护了。\n\n换个思路，本质上每一种卡片样式其实就是一种 ViewHolder（onCreateViewHolder 返回值是 Holder,至于为啥是 Holder，而不是直接返回 View，用过上古神器 ListView 的同学一定知道原因的） ，那么面对这么多的卡片样式，写一大堆 ViewHolder 就可以了，事实上在大部分时候，我们确实是这么做的，新的需求来了，添加一个新的 ViewHolder 或者是继承一个已有的 ViewHolder 做一下扩展就可以了。\n\n下面用最简单的代码，描述以下上述实现。\n\n```java\npublic class NormalAdapter extends RecyclerView.Adapter<NormalAdapter.MyHolder> {\n\n    private List<String> datas = new ArrayList<>();\n    private static final int VIEW_TYPE_A = 0;\n    private static final int VIEW_TYPE_B = 1;\n\n    public NormalAdapter(List<String> datas) {\n        this.datas = datas;\n    }\n\n    @NonNull\n    @Override\n    public MyHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        if (viewType == VIEW_TYPE_A) {\n            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.layout_type_a, parent, false);\n            return new HolderA(view);\n        } else if (viewType == VIEW_TYPE_B) {\n            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.layout_type_b, parent, false);\n            return new HolderB(view);\n        } else {\n            // more view_type stuff\n            return null;\n        }\n    }\n\n    @Override\n    public void onBindViewHolder(@NonNull MyHolder holder, int position) {\n        int viewType = getItemViewType(position);\n        if (viewType == VIEW_TYPE_A) {\n            // data-to-ui  stuff\n        } else {\n            // data-to-ui  stuff\n        }\n    }\n\n    @Override\n    public int getItemViewType(int position) {\n        if (position % 2 == 0) {\n            return VIEW_TYPE_A;\n        } else {\n            return VIEW_TYPE_B;\n        }\n    }\n\n    @Override\n    public int getItemCount() {\n        return datas.size();\n    }\n\n    public class MyHolder extends RecyclerView.ViewHolder {\n\n        public MyHolder(@NonNull View itemView) {\n            super(itemView);\n        }\n    }\n\n    public class HolderA extends MyHolder {\n        public HolderA(@NonNull View itemView) {\n            super(itemView);\n        }\n    }\n\n    public class HolderB extends MyHolder {\n        public HolderB(@NonNull View itemView) {\n            super(itemView);\n        }\n    }\n```\n\n}\n\n如上，是 RecyclerView.Adapter 实现的常规操作。ViewHolderA 和 ViewHolderB 对应不同的卡片样式。如果有新的样式，继续添加即可。但是每添加一个新的 ViewHolder ,就需要改三个方法(getItemViewType,onCreateViewHolder,onBindViewHolder).当然，可以通过工厂方法等设计模式，修改具体创建 ViewHolder 的方法，但本质上要修改的地方不会变少。\n\n### ViewHolder 的本质\n\n```java\n    @Override\n    public int getItemViewType(int position) {\n        Object object = datas.get(position);\n        if (object instanceof ModelA) {\n            return VIEW_TYPE_A;\n        } else if (object instanceof ModelB) {\n            return VIEW_TYPE_B;\n        }else {\n            return -1;\n        }\n    }\n```\n\n> 由于 RecyclerView 没有提供原生的方法用来为列表添加 Header 和 Footer ，因此有在 position 为 0 和列表末尾时，返回特定的 viewtype 来添加 Header 和 Footer 也是一种常规用法。\n\n假设，我们现在需要添加 ViewHolderC，我们需要以下几个步骤：\n\n- 从 getItemViewType 开始，确定 ViewType 的值。一般来说，会根据数据类型确定这个值。当然，这里不一定通过 instanceof 实现，也可以通过数据中特定字段实现，但本质是相同的，数据决定 viewType 类型。\n- 然后**根据这个 ViewType** 在 onCreateViewHolder 方法中确定其对应的 ViewHolder 的类型，更进一步来说是**确定了要 inflate 的 xml 资源文件**，通过这个 xml 对应的 view 创建 ViewHolder。\n- 最后，在 onBindViewHolder ，我们确定了最终需要使用的 ViewHolder 和 Model（数据类型），这里可能需要强转以下，但是只要以上两步没有错，那么这个强转是没有任何问题。\n\n但是，还是回到一开始要面对的问题，面对上百种的卡片样式，这种方式又变得不太友好，每次添加一个新的 ViewHolder，需要修改已有代码，无疑会带来不可预料的 bug。\n\n那么我们改如何面对这种情况呢？ 一种可行的解决方式 [彻底解耦 RecyclerView.Adapter](https://puke3615.github.io/2018/08/26/Android-RecyclerView-Architecture-Design/),这篇文章中提到的解决方式其实和接下来要分析的 SugarAdapter 的思路大致相同，只不过 SugarAdapter 采用注解的方式，免去了自建工厂类的麻烦，实现更加的优雅，因此使用起来也更加的方便。\n\n## SugarAdapter 如何解决了这些痛点\n\n关于如何使用 SugarAdapter 及它可以覆盖哪些场景，这里就不再展开了，参考其 [README 文档](https://github.com/zhihu/SugarAdapter)，就可以非常简单而又快速的上手了,非常好用，墙裂推荐 ！！！\n\n### Layout & ViewHolder\n\n首先看一下如何创建一个 ViewHolder\n\n```java\n@Layout(R.layout.layout_bar)\npublic final class BarHolder extends SugarHolder<Bar> {\n\n    @Id(R.id.text)\n    public AppCompatTextView mTextView;\n\n\n    public BarHolder(@NonNull View view) {\n        super(view);\n    }\n\n    @Override\n    protected void onBindData(@NonNull Bar bar) {\n        mTextView.setText(bar.getText());\n    }\n}\n```\n\n看以看到，创建一个 ViewHolder 只需要做 4 件事情\n\n- Layout 注解提供 ViewHolder 对应的 xml 布局文件\n- 继承 SugarHolder 并指定泛型的具体类型\n- 为用到的 View 加上 @ID 的注解，框架会自动帮你 fvb(当然，你也可以自己在构造函数里写 fvb；如果你在用 kotlin,忽略这条)\n- 实现 onBindData 方法，完成数据和 UI 的绑定。\n\n上面的注解在编译期，会生成如下的文件（关于 SugarAdapter 注解处理器如何解析注解及生成文件,可以参考[SugarAdapter 注解处理器分析](https://rebooters.github.io/2019/06/04/SugarAdapter-%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E5%88%86%E6%9E%90/)）\n\n**ContainerDelegateImpl.java**\n\n在 build/generated/source/apt/debug/com/zhihu/android/sugaradapter/ 目录下 （生成的代码是 ViewHolder 类名相关，不一定和这里完全相同，但方法体及实现是雷同的）\n\n```java\npublic final class ContainerDelegateImpl implements ContainerDelegate {\n    private Map<Class<? extends SugarHolder>, Integer> mLayoutResMap;\n    private Map<Class<? extends SugarHolder>, Class> mDataClassMap;\n\n    public ContainerDelegateImpl() {\n        mLayoutResMap = new HashMap<>();\n        mDataClassMap = new HashMap<>();\n\n        mLayoutResMap.put(com.zhihu.android.sugaradapterdemo.holder.BarHolder.class, com.zhihu.android.sugaradapterdemo.R.layout.layout_bar);\n        mDataClassMap.put(com.zhihu.android.sugaradapterdemo.holder.BarHolder.class, com.zhihu.android.sugaradapterdemo.item.Bar.class);\n    }\n\n    @NonNull\n    public Map<Class<? extends SugarHolder>, Integer> getLayoutResMap() {\n        return mLayoutResMap;\n    }\n\n    @NonNull\n    public Map<Class<? extends SugarHolder>, Class> getDataClassMap() {\n        return mDataClassMap;\n    }\n\n    @Override\n    @LayoutRes\n    public int getLayoutRes(@NonNull Class<? extends SugarHolder> holderClass) {\n        return mLayoutResMap.get(holderClass);\n    }\n\n    @Override\n    @NonNull\n    public Class getDataClass(@NonNull Class<? extends SugarHolder> holderClass) {\n        return mDataClassMap.get(holderClass);\n    }\n}\n```\n\n这个文件通过 HashMap 建立了两个映射关系\n\n- ViewHolder 和其对应的 xml 布局文件的 id\n- ViewHolder 和其对应的 Model 类\n\n**BarHolder\\$InjectDelegateImpl.java**\n\n在 build/generated/source/apt/debug/ 目录下\n\n```java\npublic final class BarHolder$InjectDelegateImpl implements InjectDelegate {\n    @Override\n    @SuppressLint(\"ResourceType\")\n    public <SH extends SugarHolder> void injectView(@NonNull SH sh, @NonNull View view) {\n        if (sh instanceof com.zhihu.android.sugaradapterdemo.holder.BarHolder) {\n            com.zhihu.android.sugaradapterdemo.holder.BarHolder th = (com.zhihu.android.sugaradapterdemo.holder.BarHolder) sh;\n            th.mTextView = (androidx.appcompat.widget.AppCompatTextView) view.findViewById(com.zhihu.android.sugaradapterdemo.R.id.text);\n        }\n    }\n}\n```\n\n这个文件，也是做了两件事\n\n- ViewHolder 的强制类型转换\n- ViewHolder 对应控件的 findViewById 操作\n\n下面就从 SugarAdapter 最基础的用法看看他的具体实现\n\n### SugarAdapter\n\n```java\nList<Object> list = new ArrayList<>();\n        SugarAdapter adapter = SugarAdapter.Builder.with(list)\n                .add(FooHolder.class)\n                .add(BarHolder.class)\n                .build();\n                \n                \n        recyclerView.setAdapter(adapter);\n        for (int i = 0; i < 100; i++) {\n            String text = String.valueOf(i);\n            list.add(i % 2 == 0 ? new Foo(text) : new Bar(text));\n        }\n        adapter.notifyDataSetChanged();\n```\n\n以上就是 SugarAdapter 最基础的用法，可以看到创建 adapter 的操作非常简单。这里添加了两个 ViewHolder，数据类型也有两种，实际显示的 RecyclerView 会根据数据类型，分别显示这两种卡片。那么他是怎么做到呢，下面就从他的实现开始看看。\n\n<img src=\"用-SugarAdapter-简化复杂列表的实现\\sugar.png\" height=300>\n\n#### Build 模式\n\n```java\npublic final class SugarAdapter extends RecyclerView.Adapter<SugarHolder> {\n    private static final String TAG = \"SugarAdapter\";\n\n    public static final class Builder {\n        private List<?> mList;\n        private SparseArray<Container> mArray;\n\n        @NonNull\n        public static Builder with(@NonNull List<?> list) {\n            return new Builder(list);\n        }\n\n        private Builder(@NonNull List<?> list) {\n            mList = list;\n            mArray = new SparseArray<>();\n        }\n\n        @NonNull\n        public <SH extends SugarHolder> Builder add(@NonNull Class<SH> holderClass) {\n            return add(holderClass, null);\n        }\n\n        ....\n\n        @NonNull\n        public SugarAdapter build() {\n            if (mArray.size() <= 0) {\n                throw new IllegalStateException(\"must add at least one Class<? extends SugarHolder>\");\n            }\n\n            return new SugarAdapter(mList, mArray);\n        }\n    }\n}\n\n```\n\n本质上来说，SugarAdapter 是继承自 RecyclerView.Adapter，泛型里的 ViewHolder 用的是 SugarHolder。首先这里通过一个 Builder 模式构建了所有需的数据的集合。\n\n##### Container\n\n```java\nclass Container {\n    private Class<? extends SugarHolder> mHolderClass;\n    private Class<?> mDataClass;\n    private int mLayoutRes;\n    private SugarHolder.OnCreatedCallback mCallback;\n    private Object mData;\n\n    Container(@NonNull Class<? extends SugarHolder> holderClass,\n              @NonNull Class<?> dataClass, @LayoutRes int layoutRes,\n              @Nullable SugarHolder.OnCreatedCallback callback) {\n        mHolderClass = holderClass;\n        mDataClass = dataClass;\n        mLayoutRes = layoutRes;\n        mCallback = callback;\n    }\n\n    .....\n}\n```\n\nContainer 是对所有需要用到的对象类型的包装.\n\n<span id=sugar-add>\n\n#### add() 的具体实现\n\n```java\n@NonNull\n        public <SH extends SugarHolder> Builder add(\n                @NonNull Class<SH> holderClass, @Nullable SugarHolder.OnCreatedCallback<SH> callback) {\n            ContainerDelegate delegate = Sugar.INSTANCE.getContainerDelegate();\n            Class dataClass = delegate.getDataClass(holderClass);\n            int layoutRes = delegate.getLayoutRes(holderClass);\n\n            if (layoutRes == 0) {\n                throw new IllegalStateException(holderClass.getCanonicalName()\n                        + \" must have an annotation @Layout(R.layout.*)\");\n            }\n\n            mArray.put(holderClass.hashCode(), new Container(holderClass, dataClass, layoutRes, callback));\n            return this;\n        }\n```\n\nadd 的实现很简单，就是通过 Sugar 这个单例类通过反射的方式获取到 ContainerDelegateImpl 的实例，[前面]()已经说过了，**这个实现其实就是一个 ViewHolder 和其对应的 数据类型及布局文件的一个映射集合。因此，这一步要做的就是通过 holder 从映射集合中获取到当前 ViewHolder 对应的数据类型和布局文件 xml 文件的 id**\n\n**关键的步骤**\n\n```java\n Class dataClass = delegate.getDataClass(holderClass);\n int layoutRes = delegate.getLayoutRes(holderClass);\n```\n\n#### Sugar\n\n```java\nenum Sugar {\n    INSTANCE;\n\n    private ContainerDelegate mContainerDelegate;\n    private Map<Class<? extends SugarHolder>, InjectDelegate> mInjectMap;\n\n    @NonNull\n    ContainerDelegate getContainerDelegate() {\n        if (mContainerDelegate == null) {\n            try {\n                Class delegateClass = Class.forName(\"com.zhihu.android.sugaradapter.ContainerDelegateImpl\");\n                mContainerDelegate = (ContainerDelegate) delegateClass.newInstance();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return mContainerDelegate;\n    }\n}\n```\n\n至此，在 build 方法调用的瞬间，就如何解决了之前的痛点做好了铺垫。ViewHolder,Model.class,R.layout.xxx 之间的对应关系已经被梳理好，并保存在 mArray 这个集合中了。\n\n<img src=\"用-SugarAdapter-简化复杂列表的实现\\SugarAdapter.png\">\n\n通过上图可以清晰看到各个之间的关系了，Sugar 可以理解为 SugarAdapter 和 SugarHolder 的代理类，方便其获取生成类的实例。最终在 SugarAdapter 的 mArray 集合中存储着所有关键信息，下面就看看这些关键信息是如何被使用的。\n\n### 痛点如何被消除\n\n按照之前的常规的逻辑，痛点无非就是新增样式（ViewHolder）需要 getItemViewType,onCreateViewHolder,onBindViewHolder 这三个方法轮流改一遍。那么有了之前的铺垫，SugarAdapter 又是如解决这些痛点的呢？\n我们还是回到 SugarAdapter 中。\n\n#### getItemViewType\n\n```java\npublic int getItemViewType(@IntRange(from = 0) int position) {\n        Object data = mList.get(position);\n\n        ....\n\n        for (int i = 0; i < mArray.size(); i++) {\n            int key = mArray.keyAt(i);\n            Container container = mArray.get(key);\n            if (container.getDataClass() == data.getClass()) {\n                container.setData(data);\n                return key;\n            }\n        }\n\n        throw new RuntimeException(\"getItemViewType failed, data: \" + data.getClass().getCanonicalName()\n                + \", please make sure you have associated it with a Class<? extends SugarHolder>\");\n    }\n```\n\n没错，就是这么简单。第一步，获取数据集合中，当前位置的数据类型，然后遍历之前保存好的 mArray 集合，找的那个与当前数据类型匹配的 key (也就是 viewtype) 返回即可。本质来说，确定 viewType 类型的方式还是没变，即数据决定类型，但是由于之前的一系列铺垫准备，现在这里就可以通过数据直接**自动**查找了。\n\n**回到之前 [add 方法](#sugar-add) 的实现，可以看到，在进行 put 操作时，使用的 key 是 viewholder 实例的 hashcode(),因此 这里返回的其实就是 viewholder 的 hashcode**，因此，可以理解为 SugarAdapter 是用 ViewHolder hashcode 作为 viewtype 的取值。\n\n#### onCreateViewHolder\n\nviewtype 确定了，那么就可以创建这个 type 对应的 ViewHolder 了\n\n```java\npublic SugarHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        Container container = mContainerArray.get(viewType);\n\n        try {\n            View view = null;\n            int layoutRes = container.getLayoutRes();\n\n            ... preInflate view stuff ...\n\n            if (view == null) {\n                view = inflateView(layoutRes, parent);\n            }\n\n            SugarHolder holder = container.getHolderClass().getDeclaredConstructor(View.class).newInstance(view);\n            holder.setAdapter(this);\n            holder.setData(container.getData()); // makes SugarHolder#getData non-null\n\n            ... lifecycle and callback stuff ..\n\n            return holder;\n        } catch (@NonNull Exception e) {\n            Log.e(TAG, \"onCreateViewHolder failed, holder: \" + container.getHolderClass().getCanonicalName());\n            throw new RuntimeException(e);\n        }\n    }\n```\n\n这里的 mContainerArray 其实就是之前一直在说的 mArray。**是以 viewholder 的 hashcode (viewtype) 为 key ,Container(包含这个 viewholder 数据类型，自身，R.layout.xxx 等内容的包装类) 为值的一个 SparseArray。**\n\n因此，到了这里就很简单了，根据 viewtype 从 Container 的 map 集合中取出对应的 Container ，使用 _R.layout.xxx_ inflate view, 然后创建 viewholder 的实例返回。当然为了性能提升，inflate view 之前，还会有 preInflate 的逻辑，具体细节可以参考源码，这里不做重点讨论。\n\n#### onBindViewHolder\n\n```java\nprivate void onBindViewHolderInternal(@NonNull SugarHolder holder, int position, @Nullable List<Object> payloads) {\n        Object data = mList.get(position);\n        holder.setData(data); // double check\n\n        if (payloads == null || payloads.isEmpty()) {\n            holder.onBindData(data, Collections.emptyList());\n        } else {\n            holder.onBindData(data, payloads);\n        }\n\n        holder.getLifecycleRegistry().handleLifecycleEvent(Lifecycle.Event.ON_START);\n\n        for (SugarHolderListener listener : mSugarHolderListenerList) {\n            if (listener.isInstance(holder)) {\n                listener.onSugarHolderBindData(holder);\n            }\n        }\n    }\n```\n\n到这里就很简单了，获取 position 对应的数据，调用 holder.onBindData 方法即可，还记得这个方法吗，就是在继承 SugarHolder 时需要实现 UI 和数据绑定的那个方法。\n\n可以看到，SugarAdapter 还帮我们添加了 lifecycle 相关的回调，包括在 onCreateViewHolder 时也会有 。因此使用 SugarAdapter 还可以方便的感知到更多的生命周期回调，获取到更多的方法执行结点。\n\n#### 小结\n\n至此，我们了解到 **SugarAdapter 解决痛点最关键，最核心的逻辑，就是在 add(SugarHolder holder) 的时候，根据编译期生成的文件，建立好了最终需要的对应关系集合（包含 Container 的 mArray）**，从而在后续方法执行的时候，可以根据已有的对应关系，非常方便的自动实现 viewtype-->view-->viewholder-->Data-->UI 最终对应关系。\n\n## SugarAdapter 还能做什么\n\n### **“一种”** 数据对应不同的样式\n\n通过之前的分析，我们可以看到使用 SugarAdapter ，在其 getItemViewType 方法，会根据当前 position 从数据列表中获取当前位置的 Model，然后由这个 model 决定 viewType ，也就是说数据决定了在 RecyclerView 中当前这个 position 用哪种 ViewHolder。\n\n然而，有时候 ViewHolder (即卡片样式) 并不一定由完全数据类型决定，而是由 Model 中的某个字段的类型决定，甚至面临着相同的数据，在不同的位置需要不同的 ViewHolder,甚至极端情况下，相同位置需要使用的 ViewHolder 是需要动态变化的。\n\n<img src=\"用-SugarAdapter-简化复杂列表的实现\\news.jpg\" height=300>\n\n比如图中常见的 feed 流式新闻，卡片 1 和 3 基本上是相同的，卡片 2 却是完全一种不同的样式。一般情况下，服务端下发的数据一定是同类型的，顶多加几个字段，区分一下这些内容。如上所说，SugarAdapter 是根据数据类型决定 ViewHolder，那么数据类型如果相同，那么该如何处理呢？这就要靠 Dispatcher 了。这里看一下官方的例子就明白了。\n\n```java\n adapter.addDispatcher(Foo.class,new SugarAdapter.Dispatcher<Foo>() {\n            @SuppressWarnings(\"ConstantConditions\")\n            @Override\n            @Nullable\n            public Class<? extends SugarHolder> dispatch(@NonNull Foo foo) {\n                return Integer.parseInt(foo.getText()) % 2 == 0 ? FooHolder.class : FooHolder2.class;\n            }\n        });\n```\n\n同样的数据类型 Foo，但**我们可以根据这个数据的细节，自己决定使用哪种类型的 ViewHolder** (但前提是需要把用到 ViewHolder add 进去，否则是找不到的)\n\n#### 规则\n\n那么这个 Dispatcher 是如何的原理又是什么呢？\n\n```java\n    public static abstract class Dispatcher<T> {\n\n        @Nullable\n        public abstract Class<? extends SugarHolder> dispatch(@NonNull T data);\n    }\n```\n\n- 首先可以看到，他就是一个抽象类。SugarAdapter 内部维护着一个 Dispatcher 的集合。\n\n```java\nprivate Map<Class<?>, Dispatcher<?>> mDispatcherMap;\n```\n\n当我们进行 addDispatcher 的操作时，就会把一个实际的 Dispatcher 实现添加到这个集合中。而在 onCreateViewHolder 方法执行时，会优先从这个 map 里获取对应的 ViewHolder，然后通过 viewholder 反向确定 viewtype 。这里这样做虽然有点绕，但是这样 dispatcher 就可以屏蔽数据决定 viewtype 的流程，从而巧妙地解决了**同类型数据，需要不同样式**的难题。\n\n如果找到了就直接返回 viewtype; 如果没找到就会从 mArray （所有对应关系的集合中）查找,不影响其余的类型。\n\n```java\npublic int getItemViewType(@IntRange(from = 0) int position) {\n        Object data = mList.get(position);\n\n        Class<? extends SugarHolder> holderClass = null;\n        if (mDispatcherMap.containsKey(data.getClass())) {\n            Dispatcher dispatcher = mDispatcherMap.get(data.getClass());\n            holderClass = dispatcher.dispatch(data);\n        }\n\n        if (holderClass != null) {\n            int key = holderClass.hashCode();\n            if (mContainerArray.indexOfKey(key) < 0) {\n                throw new RuntimeException(\"getItemViewType() failed, holder: \" + holderClass.getCanonicalName()\n                        + \", please make sure you have added it when build SugarAdapter.\");\n            }\n\n            mContainerArray.get(key).setData(data);\n            return key;\n        }\n\n        ... search key from mArray stuff...\n    }\n```\n\n这就是 Dispatcher ，Dispatcher 就是用来动态分发 ViewHolder 的，具体如何动态分发，就看实际的场景了。\n\n### 生命周期回调 和 Lifecycleowner 的支持。\n\nSugarAdapter 内部有很多回调，可以监听 SugarAdapter 执行的各个生命周期，这些生命周期和 RecyclerView 自身也是相关的。甚至如果你要使用 lifecycle-aware(生命周期可感知的)组件，也很非常方便的。更多细节可以参考 [具体实现](https://github.com/zhihu/SugarAdapter/blob/master/app/src/main/java/com/zhihu/android/sugaradapterdemo/MainActivity.java#L41)。\n\n## 总结\n\n总的来说，对于包含多种样式的 RecyclerView 来说，SugarAdapter 是比较合适的。更重要的是，SugarAdapter 为我们解决问题，提供了一种思路。对于一些需要重复执行，但又很有规律的代码逻辑；找到问题的本质，从最痛的地方出发，往往就能解决问题。\n\n","tags":["RecyclerView"]},{"title":"SugarAdapter 注解处理器分析","url":"%2F2019%2F06%2F04%2FSugarAdapter-%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E5%88%86%E6%9E%90%2F","content":"\n主要分析一下 sugaradapter—processor 是如何处理 Layout 这个注解的。ID 注解平时不太用（主要感觉不太稳定），同时现在在 kotlin 中，findviewbyId 已然不是什么问题，所以 ID 注解就不分析了，有兴趣的同学可以自己看看。\n\n关于注解处理器 APT 的使用及基础使用在[注解处理器APT初探](https://rebooters.github.io/2019/06/03/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8APT%E5%88%9D%E6%8E%A2)已有过分析，在这里不再展开叙述，只重点描述\nprocess 方法的实现。\n\n<!--more-->\n\n# SugarAdapter 注解处理器实现分析\n\n\n\n<!-- TOC -->\n\n- [SugarAdapter 注解处理器实现分析](#sugaradapter-%e6%b3%a8%e8%a7%a3%e5%a4%84%e7%90%86%e5%99%a8%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90)\n  - [注解](#%e6%b3%a8%e8%a7%a3)\n  - [思考](#%e6%80%9d%e8%80%83)\n  - [process 的实现](#process-%e7%9a%84%e5%ae%9e%e7%8e%b0)\n    - [DataClass 的解析](#dataclass-%e7%9a%84%e8%a7%a3%e6%9e%90)\n    - [LayoutRes 的解析](#layoutres-%e7%9a%84%e8%a7%a3%e6%9e%90)\n    - [生成编译期文件](#%e7%94%9f%e6%88%90%e7%bc%96%e8%af%91%e6%9c%9f%e6%96%87%e4%bb%b6)\n      - [generateContainerDelegateImpl](#generatecontainerdelegateimpl)\n      - [ContainerDelegateImpl.java](#containerdelegateimpljava)\n  - [总结](#%e6%80%bb%e7%bb%93)\n\n<!-- /TOC -->\n\n\n\n\n\n## 注解\n\nLayout\n\n```java\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\n@Inherited\npublic @interface Layout {\n    @LayoutRes\n    int value() default 0;\n}\n```\n\n可以看到 **Layout 是支持继承的**\n\n## 思考\n\n```java\n@Layout(R.layout.layout_bar)\npublic final class BarHolder extends SugarHolder<Bar> {\n\n    .... init and bindData stuff...\n}\n```\n\n假设你对注解处理器 APT 使用已有一定的了解，那么从上面这个 BarHolder 类中，\n如何获取 R.layout.layout_bar 这个资源的完整路径呢？又该如何获取 Bar 这个类的完整路径呢？\n可以简单思考一下 🤔🤔🤔🤔🤔🤔🤔🤔🤔\n\n## process 的实现\n\n### DataClass 的解析\n\n数据类的解析\n\n```java\n\nprivate static final Pattern TYPE_PARAM_PATTERN = Pattern.compile(\"(.*?)<(.*?)>\");\n\nprivate Map<String, Set<String>> processLayout(@NonNull RoundEnvironment roundEnv) {\n        mMessager.printMessage(Diagnostic.Kind.NOTE, \"processLayout begin\");\n\n        for (Element element : roundEnv.getElementsAnnotatedWith(Layout.class)) {\n            if (element instanceof TypeElement) {\n                String holderClass = ((TypeElement) element).getQualifiedName().toString();\n\n                String dataClass = null;\n                TypeMirror mirror = ((TypeElement) element).getSuperclass();\n                while (mirror != null && !(mirror instanceof NoType)) {\n                    Matcher matcher = TYPE_PARAM_PATTERN.matcher(mirror.toString());\n                    if (matcher.matches()) {\n                        // remove generic type from dataClass\n                        dataClass = matcher.group(2).trim().replaceAll(\"<[^>]*>\", \"\");\n                        break;\n                    } else {\n                        mirror = ((TypeElement) processingEnv.getTypeUtils().asElement(mirror)).getSuperclass();\n                    }\n                }\n\n                mMessager.printMessage(Diagnostic.Kind.NOTE, \"dataClass==\" + dataClass);\n            }\n        }\n    }\n```\n\n为了获取到 SugarHolder 泛型中 Model 类的实际类型\n\n1. 通过 TypeMirror 获取到了当前 ViewHolder 的父类\n\n以上面的 BarHolder 为例\n\n```java\ncom.zhihu.android.sugaradapter.SugarHolder<com.zhihu.android.sugaradapterdemo.item.Bar>\n```\n\n2. 用正则匹配的方式，对上述内容按字符串进行查找匹配和匹配，获取到\n\n```java\ncom.zhihu.android.sugaradapterdemo.item.Bar\n```\n\n如果这个类还有泛型，比如 Bar<\\*> ，则会直接擦除掉（用空字符串替代）\n\n当然，由于 Layout 支持继承，所以这里直接获取当前 ViewHolder 的父类，可能会存在找不泛型的情况，因此需要不断回溯查找父类。\n\n> 第 2 步，理论上也可以通过 **((Type.ClassType) mirror).getTypeArguments().head** 的方式拿到，但这是具体实现细节，用正则匹配也是可以的。\n\n### LayoutRes 的解析\n\n资源文件的解析\n\n```java\nprivate Map<String, Set<String>> processLayout(@NonNull RoundEnvironment roundEnv) {\n        mMessager.printMessage(Diagnostic.Kind.NOTE, \"processLayout begin\");\n\n        RParser parser = RParser.builder(processingEnv)\n                .setSupportedAnnotations(Collections.singleton(Layout.class))\n                .setSupportedTypes(\"layout\")\n                .build();\n\n        parser.scan(roundEnv);\n\n        for (Element element : roundEnv.getElementsAnnotatedWith(Layout.class)) {\n            if (element instanceof TypeElement) {\n                String holderClass = ((TypeElement) element).getQualifiedName().toString();\n                int layoutRes = element.getAnnotation(Layout.class).value();\n\n                if (layoutRes == 0 || dataClass == null) {\n                    throw new IllegalStateException(\"process \" + holderClass + \" failed!\");\n                }\n\n                String layoutResStr = null;\n                String packageName = null;\n                for (String path : holderClass.split(\"\\\\.\")) {\n                    if (packageName == null) {\n                        packageName = path;\n                    } else {\n                        packageName = packageName + \".\" + path;\n                    }\n\n                    layoutResStr = parser.parse(packageName, layoutRes);\n                    if (!layoutResStr.equals(String.valueOf(layoutRes))) {\n                        break;\n                    }\n                }\n                mMessager.printMessage(Diagnostic.Kind.NOTE, \"layoutResStr==\" + layoutResStr);\n            }\n        }\n    }\n```\n\n关于资源文件的解析，你可能觉得很简单，但其实不简单\n\n```java\nint layoutRes = element.getAnnotation(Layout.class).value();\n```\n\n通过注解直接获取的资源文件 value 是一段类似 34343438943 的数字，这个是系统自动在 R 文件中生成的。因此这里获取的 layoutRes 是一个 int 值，并不能直接拿来使用。然而我们最终需要的是 packagename.R.layout.xxx 这样的文件(在组件化开发或依赖第三方库时，你无法避免别人和你定义了一个同名的资源文件，所以这里需要带包名的资源路径，以做区分)。\n\n因此这里借助[HendraAnggrian/r-parser](https://github.com/HendraAnggrian/r-parser \"HendraAnggrian/r-parser\") 实现了这个功能。\n\n```java\n                    layoutResStr = parser.parse(packageName, layoutRes);\n                    if (!layoutResStr.equals(String.valueOf(layoutRes))) {\n                        break;\n                    }\n```\n\nparser.parse 会根据包名和资源 id 去查找具体的资源路径名。这里通过拼接包名的方式，不断查找这个资源。\n\n通过上述过程，就完成了 DataClass 和 Reslayot 完整路径的获取。以 BarViewHolder 为例\n\n```java\n@Layout(R.layout.layout_bar)\npublic final class BarHolder extends SugarHolder<Bar> {\n\n    .... init and bindData stuff...\n}\n```\n\n正常情况下，可以得到如下结果\n\n```java\ndataClass = com.zhihu.android.sugaradapterdemo.item.Bar.class\n\nlayoutResStr = com.zhihu.android.sugaradapterdemo.R.layout.layout_bar\n\n```\n\n### 生成编译期文件\n\n有了这两个最总要的内容，就可以用来生成编译期的文件了。\n\n```java\nprivate Map<String, Set<String>> processLayout(@NonNull RoundEnvironment roundEnv) {\n\n\n        Map<String, Pair> containerMap = new HashMap<>();\n\n        for (Element element : roundEnv.getElementsAnnotatedWith(Layout.class)) {\n            if (element instanceof TypeElement) {\n                String holderClass = ((TypeElement) element).getQualifiedName().toString();\n                int layoutRes = element.getAnnotation(Layout.class).value();\n\n                String dataClass = null;\n\n                ... detail stuff...\n\n\n                if (layoutResStr == null || layoutResStr.equals(String.valueOf(layoutRes))) {\n                    throw new IllegalStateException(\"process \" + holderClass + \" failed!\");\n                }\n\n                containerMap.put(holderClass, new Pair(layoutResStr, dataClass));\n            }\n        }\n\n        generateContainerDelegateImpl(containerMap)\n\n        .....\n    }\n```\n\n#### generateContainerDelegateImpl\n\n关于编译期文件的生成，可以用 javapoet ，当然也可以直接按最终需要的格式，进行字符串拼接，都是可以的。这里假设我们只有 BarViewHolder 这一个类，那么最终生成的文件，就是如下[ContainerDelegateImpl.java](#container-delegate)\n\n```java\n private void generateContainerDelegateImpl(@NonNull Map<String, Pair> map) throws IOException {\n        StringBuilder builder = new StringBuilder();\n        String packageName = \"com.zhihu.android.sugaradapter\";\n        builder.append(\"package \").append(packageName).append(\";\\n\\n\");\n\n\n        ...import...\n\n        // for module project\n\n        ... 变量声明...\n\n        for (String key : map.keySet()) {\n            String layoutResStr = map.get(key).getFirst();\n            String dataClass = map.get(key).getSecond();\n            builder.append(\"        mLayoutResMap.put(\").append(key).append(\".class, \")\n                    .append(layoutResStr).append(\");\\n\");\n            builder.append(\"        mDataClassMap.put(\").append(key).append(\".class, \")\n                    .append(dataClass).append(\".class);\\n\");\n        }\n\n        ... getxxx method stuff...\n\n\n\n        JavaFileObject object = processingEnv.getFiler().createSourceFile(packageName + \".\" + className);\n        Writer writer = object.openWriter();\n        writer.write(builder.toString());\n        writer.flush();\n        writer.close();\n    }\n```\n\n<span id=container-delegate>\n\n#### ContainerDelegateImpl.java\n\n```java\npublic final class ContainerDelegateImpl implements ContainerDelegate {\n    private Map<Class<? extends SugarHolder>, Integer> mLayoutResMap;\n    private Map<Class<? extends SugarHolder>, Class> mDataClassMap;\n\n    public ContainerDelegateImpl() {\n        mLayoutResMap = new HashMap<>();\n        mDataClassMap = new HashMap<>();\n\n\n        mLayoutResMap.put(com.zhihu.android.sugaradapterdemo.holder.BarHolder.class, com.zhihu.android.sugaradapterdemo.R.layout.layout_bar);\n        mDataClassMap.put(com.zhihu.android.sugaradapterdemo.holder.BarHolder.class, com.zhihu.android.sugaradapterdemo.item.Bar.class);\n    }\n\n    @NonNull\n    public Map<Class<? extends SugarHolder>, Integer> getLayoutResMap() {\n        return mLayoutResMap;\n    }\n\n    @NonNull\n    public Map<Class<? extends SugarHolder>, Class> getDataClassMap() {\n        return mDataClassMap;\n    }\n\n    @Override\n    @LayoutRes\n    public int getLayoutRes(@NonNull Class<? extends SugarHolder> holderClass) {\n        return mLayoutResMap.get(holderClass);\n    }\n\n    @Override\n    @NonNull\n    public Class getDataClass(@NonNull Class<? extends SugarHolder> holderClass) {\n        return mDataClassMap.get(holderClass);\n    }\n}\n```\n\n## 总结\n\n以上就是 sugaradapter-processor 的分析，可以看到关于注解处理器的使用是非常灵活的，在编译期根据 RoundEnvironment 接口，Element 接口及其子类提供的 API 非常灵活的获取各种你所需要的信息，利用这些进行二次的组合，或分解就可以在编译期生成非常有价值的文件，使一些看似无法解决的重复工作变得简单有条理。\n\n","tags":["RecyclerView"]},{"title":"注解处理器APT初探","url":"%2F2019%2F06%2F03%2F%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8APT%E5%88%9D%E6%8E%A2%2F","content":"\n<img src=\"注解处理器APT初探/BindView_Proxy.png\" width=500>\n\n# 前言\n\n从早期的 ButterKnife，Dagger2，EventBus 到如今的 [ARouter](https://github.com/alibaba/ARouter), [WMRouter](https://github.com/meituan/WMRouter) ,[SugarAdapter](https://github.com/zhihu/SugarAdapter)（也许还有其他的，平时关注较多的就是这些），借助注解处理器 APT,各路神仙开发了许多有用的工具、框架，解放了 Android 开发者的双手，让我们少写了很多冗余的代码，也使得组件化这样的开发思路可以大行其道。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [前言](#前言)\n- [注解处理器 APT 是什么，能做什么 ？](#注解处理器-apt-是什么能做什么-)\n  - [APT 处理哪种类型的注解](#apt-处理哪种类型的注解)\n  - [APT 的作用](#apt-的作用)\n- [注解处理器小试牛刀](#注解处理器小试牛刀)\n  - [注解处理器工程的创建](#注解处理器工程的创建)\n  - [小目标（BindView & BindString)](#小目标bindview--bindstring)\n    - [apt-annotaion](#apt-annotaion)\n    - [apt-processor](#apt-processor)\n      - [BindViewProcessor](#bindviewprocessor)\n        - [代码生成](#代码生成)\n        - [生成的目标代码](#生成的目标代码)\n- [总结](#总结)\n- [注解处理器在 Kotlin 中的使用注意事项](#注解处理器在-kotlin-中的使用注意事项)\n- [参考文档](#参考文档)\n\n<!-- /TOC -->\n\n\n\n试想，如果没有 ButterKnife 这样的神器，那么现在每一个 Android 开发者估计下辈子都会记得 findViewById 这个方法，真是能让人写的吐血的一个方法。（当然，现在上了 Kotlin 的车，这都不是问题了）。\n\n你能想象在 EventBus 尚未诞生的时候，我曾经为了把一个方法的值从某个  RecyclerView 的 Adapter 传递到另一个 Activity 的 Fragment 里写了多少层的回调吗？你能想象一个 Activity(Fragment) 的 onActivityResult 有 100 多行的条件判断(仅仅是返回值按 requestCode 取值，不包括任何业务逻辑)，去获取其他页面的各种返回值是多么的让人绝望吗？甚至有些时候还要考虑被启动的 Activity 在特定的启动模式下，onActivityResult 方法回调异常的情况，更是出现了无法实现业务需求的窘境 😢\n\n在组件化开发的早期，类依赖是最最痛苦的问题，两个从业务上已经剥离的组件，却因为要实现页面跳转（简单来说就是依赖 Activity 或 Fragment 类）而不得不产生依赖。路由框架在 Android 中的应用，完美的解决了这个问题。\n\n而这些框架，都用到了注解处理器这项技术，因此这里就来学些一下什么是注解处理器，以及注解处理器可以做什么。\n\n# 注解处理器 APT 是什么，能做什么 ？\n\n## APT 处理哪种类型的注解\n\n注解处理器，顾名思义就是用于处理**注解**的工具。\n\n在[理解 Android 中的注解与反射](https://www.jianshu.com/p/d4978bbce12a) 一文中我们已知，Java 代码在运行时会通过反射的方式处理 注解作用范围@Retention 为 RetentionPolicy.RUNTIME 的注解。而今天的主角 APT 则负责处理注解作用范围 @Retention 为 RetentionPolicy.CLASS 的注解。\n\n## APT 的作用\n\n> APT(Annotation Processing Tool)即注解处理器，是一种处理注解的工具，确切的说它是 javac 的一个工具，它用来在编译时扫描和处理注解。注解处理器以 Java 代码(或者编译过的字节码)作为输入，生成.java 文件作为输出。简单来说就是在编译期，通过注解生成.java 文件。\n\n# 注解处理器小试牛刀\n\n<span id=\"init-project\">\n\n## 注解处理器工程的创建\n\n注解处理器的使用很简单，网上已经有很多的例子和实现，可以参考[Android 如何编写基于编译时注解的项目](https://blog.csdn.net/lmj623565791/article/details/51931859) ，[轻松打造一个自己的注解框架](https://mp.weixin.qq.com/s/ljJ1uBCinBLhCU6MtOApYA) 这两篇文章搭建一个合适的注解处理器框架。为了后续描述方便，这里也简单写了一个 [Demo](https://github.com/REBOOTERS/APT-Lite) ,代码已同步到Github [APT-Lite](https://github.com/REBOOTERS/APT-Lite) 仓库，可以参考。\n\n<img src=\"注解处理器APT初探/code-structure.jpg\">\n\n一般来说按照上图\n\n- apt-annotation (java module) 定义所有需要用到的注解（require）\n- apt-processor (java module) 解析注解并生成 java 代码 (require)\n- apt-libray （android module) 定义对外暴露的 API 接口 (option)\n- example (android module) demo (option)\n\n这样定义就足够了。就注解处理器实际要实现的业务功能，apt-library 可能需要定义在其他组件中，甚至某些注解处理要实现的功能，如果和业务有强绑定，这个 api 甚至都可能不存在，example(或 app) 作为验证（演示）注解功能的 module 是可以忽略的，因此注解处理器框架实际上就是一个纯 Java 项目。\n\n**关于在工程中这些模块的 build.gradle 中相互依赖关系及依赖哪些库，这里就不展开了，毕竟很简单，具体结合[上面的两篇文章](#init-project)可以很轻松的完成配置**。\n\n## 小目标（BindView & BindString)\n\n简单起见，我们也从模仿 ButterKnife 开始，简单定义两个注解，BindView 和 BindString ，代码运行后可以实现 变量和 View 的自动绑定。\n\n<span id=main-actvity-code>\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @BindView(R.id.content)\n    @BindString(\"Hello APT\")\n    TextView mContent;\n\n    @BindView(R.id.name)\n    @BindString(\"APT Success\")\n    TextView mName;\n\n    ...else...\n}\n```\n\n上述代码，在运行期可以正确的找的 id 为 content 和 name 的 TextView 并分别赋值为 \"Hello APT\" 和 \"APT Success\"\n\n### apt-annotaion\n\n定义我们需要用到两个注解\n\n- BindView\n\n```java\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.FIELD)\npublic @interface BindView {\n    int value();\n}\n```\n\n- BindString\n\n```java\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.FIELD)\npublic @interface BindString {\n    String value() default \"\";\n}\n```\n\n### apt-processor\n\napt processor 的实现，是 APT 最核心的内容。但是要做的事情也很简单。就是继承 AbstractProcessor 类，并实现它的四个方法\n\n- init\n- getSupportedSourceVersion （可以用注解代替）\n- getSupportedAnnotationTypes （可以用注解代替）\n- process\n\n这四个方法的定义及功能，就不展开说了，通过[参考资料](#refercen-doc)中的内容，甚至其命名我们就可以知道这几个方法的作用是啥了。\n为了方便，我们可以先简单的抽取一层 BaseProcessor。对于一些常用的初始化一些常用的成员变量。\n\n```java\npublic abstract class BaseProcessor extends AbstractProcessor {\n    // 进行日志打印的接口\n    Messager mMessager;\n    // Element 元素处理的接口\n    Elements mElementUtils;\n    // 帮助文件生成的接口\n    Filer mFiler;\n\n    @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return SourceVersion.latestSupported();\n    }\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {\n        super.init(processingEnvironment);\n\n        mFiler = processingEnvironment.getFiler();\n        mMessager = processingEnvironment.getMessager();\n        mElementUtils = processingEnvironment.getElementUtils();\n\n        mMessager.printMessage(Diagnostic.Kind.NOTE, \"init\");\n    }\n}\n```\n\n#### BindViewProcessor\n\n下面就通过 BindViewProcessor 看看如何实现我们的目标。\n\n- 首先定义要支持的注解类型\n\n```java\n    @Override\n    public Set<String> getSupportedAnnotationTypes() {\n        HashSet<String> supportTypes = new HashSet<>();\n        supportTypes.add(BindView.class.getCanonicalName());\n        supportTypes.add(BindString.class.getCanonicalName());\n        return supportTypes;\n    }\n```\n\n- process 核心逻辑的处理\n\n```java\n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {\n        mMessager.printMessage(Diagnostic.Kind.NOTE, \"processing....\");\n\n        // 代理方法清空\n        mProxyProMap.clear();\n        // 处理注解，完成需要生成代码的前期准备\n        assembleAnnotations(roundEnvironment);\n        // 生成代码\n        genCodeAuto();\n\n        mMessager.printMessage(Diagnostic.Kind.NOTE, \"process finish ...\");\n        return true;\n    }\n```\n\n*ps: 可能是受到[鸿洋老师](https://github.com/hongyangAndroid)这篇 [Android 如何编写基于编译时注解的项目](https://blog.csdn.net/lmj623565791/article/details/51931859)的影响，现在看到网上注解处理器的文章，都会新建 Proxy 通过代理模式来处理生成代码的核心逻辑，o(╥﹏╥)o。* 这里为了方便也是用代理类处理。\n\n- assembleAnnotations() 对注解进行完全的处理\n\n```java\n    /**\n     *\n     * @param roundEnvironment 集中收集所有需要处理的 注解\n     */\n    private void assembleAnnotations(RoundEnvironment roundEnvironment) {\n        processAnnotations(roundEnvironment, BindView.class);\n        processAnnotations(roundEnvironment, BindString.class);\n    }\n\n\n    private void processAnnotations(RoundEnvironment roundEnvironment, Class<? extends Annotation> className) {\n\n        RParser parser = RParser.builder(processingEnv)\n                .setSupportedAnnotations(BindView.class)\n                .setSupportedTypes(\"id\")\n                .build();\n\n        parser.scan(roundEnvironment);\n\n        // 获取所有打上 className 类型注解的元素\n        Set<? extends Element> elements = roundEnvironment.getElementsAnnotatedWith(className);\n        // 遍历元素\n        for (Element element : elements) {\n            // 因为 BindView 和 BindString 的 target 是 ElementType.FIELD，因此这里强转理论上是安全的，\n            // 除非故意把注解打在了错误的位置\n            VariableElement variableElement = (VariableElement) element;\n            TypeElement classElement = (TypeElement) variableElement.getEnclosingElement();\n            String fullClassName = classElement.getQualifiedName().toString();\n\n            BindCreatorProxy proxy = mProxyProMap.get(fullClassName);\n            if (proxy == null) {\n                proxy = new BindCreatorProxy(mElementUtils, classElement);\n                mProxyProMap.put(fullClassName, proxy);\n            }\n\n            if (className.getCanonicalName().equals(BindView.class.getCanonicalName())) {\n                // BindView 注解处理\n                BindView bindAnnotation = variableElement.getAnnotation(BindView.class);\n                int id = bindAnnotation.value();\n                // 返回当前的 id 的 human 值，类似 R.id.xxx\n                String idRes = getBindViewResId(parser, fullClassName, id);\n                ResModel model = new ResModel(idRes, id, BindView.class);\n                proxy.putElement(model, variableElement);\n\n            } else if (className.getCanonicalName().equals(BindString.class.getCanonicalName())) {\n                // BindString 注解处理\n                BindString bindAnnotation = variableElement.getAnnotation(BindString.class);\n                String str = bindAnnotation.value();\n                proxy.putElement(str, variableElement);\n            }\n        }\n    }\n\n```\n\n为了便于理解上面的代码，可以看一下整个 apt-processor 的 UML 类图\n\n<img src=\"注解处理器APT初探/BindView_Proxy.png\">\n\n总的来说，mProxyProMap 是以注解所在的类名为 key ，BindCreatorProxy 为值的一个 map。这样做为了方便以 @BindView,@BindString\n注解所在的类为维度，解析注解生成代码。BindCreatorProxy 中的 putElements() 方法会保存注解对应的 value 和 element 的映射表（即一个 HaspMap）。\n\n- getBindViewResId（）\n\n  这里再来简单说一下 getBindViewResId 这个方法，这里其实是借用 [RParser](https://github.com/HendraAnggrian/r-parser)为了便于生成更加友好的代码。因为我们通过 R 文件直接获取到的 View 的 id 一般是无意义的一个数字，因此生成的文件一般会是类似\n\n  ```java\n    target.mName = target.findViewById(2131165246);\n  ```\n\n  这样的代码，理论上来说，这里的 id 是以什么样的形态存在，其实无所谓，但为了更加友好的阅读体验，我们可以再优化一下注解生成器把生成的代码变成这个样子\n\n  ```java\n    target.mName=target.findViewById(com.engineer.aptlite.R.id.name);\n  ```\n\n  这样的代码更接近我们最终想要看到的样子。\n\n##### 代码生成 \n\nmProxyProMap 已经包含所有我们需要信息，接下来就可以根据这个集合生成代码了。在 APT 处理过程中，一般会选择使用 javapoet 来生成代码，这个库提供了很多 api 方法开发者按照面向对象的方式**输出**一个包含导包，类声明，变量声明，方法定义等各种信息的类文件。当然，你也可以选择使用字符串拼接的方法，按照你希望的格式进行拼接即可。\n\n  - genCodeAuto() \n\n```java\nprivate void genCodeAuto() {\n        for (String key : mProxyProMap.keySet()) {\n            BindCreatorProxy proxyPro = mProxyProMap.get(key);\n            try {\n                JavaFile javaFile = JavaFile.builder(proxyPro.getPackageName(), proxyPro.generatorJavaCode()).build();\n                javaFile.writeTo(mFiler);\n            } catch (Exception e) {}\n        }\n    }\n\n```\n这里遍历所有需要生成的类，分别为他们生成文件，proxyPro.generatorJavaCode() 的具体实现 \n\n```java\npublic TypeSpec generatorJavaCode() {\n        TypeSpec typeSpec = TypeSpec.classBuilder(mBindingClassName)\n                .addModifiers(Modifier.PUBLIC)\n                .addModifiers(Modifier.FINAL)\n                .addMethod(generateViewBindMethod())\n                .addMethod(generateStringBindMethod())\n                .build();\n        return typeSpec;\n    }\n```\n这里使用 javapoet 实现,可以看到他的 API 设计命名还是很清晰的，基本上根据方法命名就可以知道需要做什么事情了，这里的实现就很简单了，具体细节就不展开了，可以参考[源码](https://github.com/REBOOTERS/APT-Lite/blob/master/apt-processor/src/main/java/com/engineer/apt_processor/creator/BindCreatorProxy.java#L53)\n\n\n##### 生成的目标代码\n\n以[上面我们制定的目标 MainActivity](#main-actvity-code)为例，那么最终在编译期生成的代码就是这个样子：\n\n```java\npackage com.engineer.aptlite;\n\npublic final class MainActivity_Binding {\n  public void bindView(MainActivity target) {\n    target.mContent=target.findViewById(com.engineer.aptlite.R.id.content);\n    target.mJump1=target.findViewById(com.engineer.aptlite.R.id.jump_1);\n    target.mGenCode=target.findViewById(com.engineer.aptlite.R.id.genCode);\n    target.mJump=target.findViewById(com.engineer.aptlite.R.id.jump);\n    target.mName=target.findViewById(com.engineer.aptlite.R.id.name);\n  }\n\n  public void bindString(MainActivity target) {\n    target.mName.setText(\"APT Success\");\n\n    target.mContent.setText(\"Hello APT\");\n\n  }\n}\n```\n\n**这个文件在一般会在 */app/build/generated/source/apt/debug/packagename/* 目录下。但其实也不用按照目录找，Android Studio 切换到 Android 目录视图下，在 generatedJava 包下即可非常方便的找到**\n\n可以看到和我们手写的基本差不多。代码可以正常运行，说明一切都正常，说明编译期生成的代码是有效的。\n\n<img src=\"注解处理器APT初探/apt.png\" width=30%>\n\n# 总结\n\n使用 APT 可以帮助我们在编译期预先完成一些重复性较强，且很有规律的事情，生成一些辅助性的代码，最终在我们编码的时候，可以借助这些辅助类更高效和准确的完成工作。例如 SugarAdapter 通过在编译期生成的文件，解决了 RecyclerView 需要多种类型的 Item 时，Adapter 实现爆炸的问题。有兴趣的同学可以看看[用 SugarAdapter 简化复杂列表的实现](https://rebooters.github.io/2019/06/16/%E7%94%A8-SugarAdapter-%E7%AE%80%E5%8C%96%E5%A4%8D%E6%9D%82%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/)\n\n# 注解处理器在 Kotlin 中的使用注意事项\n\n在常规的 java 版本的 Android 项目中，为了引入带有注解处理器的库，一般会最 build.gradle 的 dependencies 闭包中会使用annotationProcessor 来使用注解处理器，比如 glide 的依赖 \n\n```groovy\ndependencies {\n  implementation 'com.github.bumptech.glide:glide:4.9.0'\n  annotationProcessor 'com.github.bumptech.glide:compiler:4.9.0'\n}\n```\n在 Kotlin 中需要替换为 kapt 了。具体来说，首先需要添加 kapt 的插件\n\n```groovy\napply plugin: 'kotlin-kapt'\n```\n\n然后将所有需要使用 annotationProcessor 的地方替换为 kapt 即可。\n\n<span id=\"refercen-doc\">\n\n# 参考文档\n\n- [Android 如何编写基于编译时注解的项目](https://blog.csdn.net/lmj623565791/article/details/51931859)\n- [APT 注解处理器，让你的代码变得更简单](https://mp.weixin.qq.com/s/cZf87Du11cqWD0GF2PmPyw)\n- [轻松打造一个自己的注解框架](https://mp.weixin.qq.com/s/ljJ1uBCinBLhCU6MtOApYA)\n- [教你实现一个轻量级的注解处理器（APT）](https://mp.weixin.qq.com/s/3zrAzOUGpovRRbuYnce3uw)\n- [在 Android 中优雅地使用注解](https://mp.weixin.qq.com/s/fJKAwpqn_hXRXRS4oh1dEw)\n- [自定义注解之编译时注解(RetentionPolicy.CLASS)（三）—— 常用接口介绍](https://www.2cto.com/kf/201608/536317.html)\n","tags":["反射"]},{"title":"Debug技巧","url":"%2F2019%2F06%2F02%2FDebug%E6%8A%80%E5%B7%A7%2F","content":"\nDebug 技巧\n\n使用 IDE 进行 Debug 时的一些技巧操作，其实可以节省大量的时间\n\n<!--more-->\n\n### Code\n\n```java\npublic class Client {\n    private static final String[] NAMES = {\"美队\", \"浩克\", \"黑寡妇\"};\n    private static final List<User> USERS = Arrays.stream(NAMES)\n            .map(name -> new User(name, \"男\"))\n            .collect(Collectors.toList());\n\n    public static void main(String[] args) {\n        for (User user : USERS) {\n            System.out.println(user);\n        }\n    }\n}\n```\n\n#### 条件断点 + 代码植入\n\n**改变变量状态能够动态地设置变量值，条件断点可以控制断点是能在此处挂起，那将两者结合就能达到在程序不挂起的情况下进行动态代码植入的效果**\n\n<img src=\"Debug技巧/insert_code.gif\">\n\n#### Android\n\n动态修改值，避免多次运行代码\n\n<img src=\"Debug技巧/insert_Image_url.gif\">\n\n#### 变量解析器\n\n变量属性过多 debug 时无法完全展现时\n\n<img src=\"Debug技巧/CustomGoodsRenderers.gif\">\n\n甚至可以通过反射的方式，获取任意类的是所有属性，然后直接[通过变量解析器进行设置](https://puke3615.github.io/2018/06/05/Android-Studio-Debug-2/)\n\n### 参考文档\n\n[Android Studio 之 Debug（一）：运行期代码植入](https://puke3615.github.io/2018/06/05/Android-Studio-Debug-1/)\n[Android Studio 之 Debug（二）：运行期代码植入](https://puke3615.github.io/2018/06/05/Android-Studio-Debug-2/)\n","tags":["Debug"]},{"title":"Java 修饰符 VS Kotlin 修饰符","url":"%2F2019%2F05%2F25%2FJava-%E4%BF%AE%E9%A5%B0%E7%AC%A6-VS-Kotlin-%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F","content":"\nJava 和 Kotlin 中权限修饰符小结(长期更新)\n\n<!--more-->\n\n## Java 中\n\n**以下所说的情况排除内部类的情况。**\n\n- 类中的数据成员和成员函数据具有的访问权限包括：public、private、protected、default（包访问权限）\n\n\n\n\n总结一下如图\n\n| 作用域    | 当前类 | 同一 package | 子孙类 | 其他 package |\n| --------- | :----: | :----------: | :----: | :----------: |\n| public    |   ✅    |      ✅       |   ✅    |      ✅       |\n| protected |   ✅    |      ✅       |   ✅    |      ❌       |\n| default   |   ✅    |      ✅       |   ❌    |      ❌       |\n| private   |   ✅    |      ❌       |   ❌    |      ❌       |\n\n默认不写时，为 default .\n\n1. public： 所修饰的类、变量、方法，在内外包均具有访问权限；\n2. protected： 这种权限是为继承而设计的，protected所修饰的成员，对所有子类是可访问的，但只对同包的类是可访问的，对外包的非子类是不可以访问；\n3. 包访问权限（default）： 只对同包的类具有访问的权限，外包的所有类都不能访问；\n4. private： 私有的权限，只对本类的方法可以使用；\n\n- 类的访问权限包括： 包访问权限和 public\n\n## Kotlin\n\nKotlin 中的修饰符为 public、internal、protected、private. 其中 public 为默认修饰符，internal 和 Java 中 default 的语义是类似的，都表示对同包的类可见，外部不可见。\n\n## 参考文档\n\n[java基础(七) java四种访问权限](https://www.cnblogs.com/jinggod/p/8425423.html)\n","tags":["Java 基础"]},{"title":"UML 类图基础","url":"%2F2019%2F05%2F22%2FUML-%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%2F","content":"\n<img src=\"UML-基础结构/Aggregation_1.png\" width=60% height=40%/>\n\n## 前言\n\n> UML（Unified Modeling Language 统一建模语言）是用来对软件密集系统进行可视化建模的一种语言。\n\n**简单来说，UML 类图就是用来表示一个软件系统中各个类的特征及相互关系的图**。这里说的软件系统可能很庞大，是一个实实在在的复杂软件架构（如 Android 系统），也可能只是某种抽象表示（比如设计模式）。\n\n下面就以 Java 语言为例，看看如何用 UML 类图表示 Java 中类、接口及其复杂的关系。\n\n<!--more-->\n\n## 类\n\n类使用包含其 **类名**，**属性**，**方法名及其参数**并且用**分割线分隔的长方形**表示。在长方形中属性及方法名又有如下规则。\n\n### 类中成员变量表示\n\n> 可见性 名称:类型 [ = 默认值 ]\n\n其中可见性用+，-，\\* 三种符合表示，意义如下。\n\n| 可见性 |      含义       |\n| ------ | :-------------: |\n| +      |     public      |\n| -      |     private     |\n| \\*     |    protected    |\n| ~      | package private |\n\n### 类中方法表示\n\n> 可见性 名称(参数列表) [ : 返回类型]\n\n方法中可见性的含义和成员变量一致，只是名称由属性名变成了方法名。\n\n假设现有类 Student.java\n\n```java\npublic class Student {\n    public String name=\"mike\";\n    private int score;\n    protected int number=89757;\n    String address;\n\n    public String getName(){\n        return name;\n    }\n\n    private void setScore(int score) {\n        this.score=score;\n    }\n\n    protected void setNumber(int number) {\n        this.number=number;\n        setScore(number * 2);\n    }\n}\n```\n\n那么他所对应的 UML 类图如下：\n\n<img src=\"UML-基础结构/Student.png\" width=300 />\n\n[Student 类 UML 实现](https://github.com/REBOOTERS/My-MVP/blob/master/uml/Student.puml)\n\n## 接口 & 抽象类\n\n通过上述信息，已经阐述了 UML 表示 **Java Class** 所需要的所有基础知识，剩下的接口、抽象类包括抽象方法、静态类、抽象方法和枚举类只是在其基础上扩展，对类的定义有一些稍微的差异而已。\n\n<img src=\"UML-基础结构/base.png\" width=300 />\n\n[抽象类，接口，枚举的 UML 实现](https://github.com/REBOOTERS/My-MVP/blob/master/uml/base.puml)\n\n上图简单展示了 Java 集合类之间的关系，下面详细的梳理一下如何用 UML 图描述类之间的关系。\n\n## 类之间的关系\n\n在 UML 中，类(这里泛指 Java 中的类和接口)之间的关系可以用以下 6 种形态表达。\n\n- 继承（泛化）： 子类和父类用**带空心三角的直线**表示，箭头指向父类；\n- 实现： 就是接口的实现类和接口之间的关系，用**带空心三角的虚线**表示，箭头指向接口；\n- 依赖：就是一个类中包含另一个类的对象，用**带箭头的虚线**表示，箭头指向另一个对象对应的类；\n- 关联：一个类和另一个类有联系，用**带箭头的直线**表示，箭头指向被包含类；\n- 聚合：整体和部分的关系，部分可以脱离整体存在；用**带空心菱形的直线**表示，箭头指向代表部分的那个类；\n- 组合：整体和部分的关系，部分受整体的影响，整体不存在时部分也将消失，用**带实心菱形的直线**表示，箭头指向代表部分的那个类；\n\n为了加深印象，下面通过图示再来详细阐述一下以上的内容。\n\n### 继承（泛化）\n\n这个最好理解了，比如 Android 中的 View 树。 **这里需要注意的是，接口之间也是可以有继承关系的**\n\n用**带空心三角的直线**表示，箭头指向基类\n\n<img src=\"UML-基础结构/Generalization.png\" width=300 height=auto />\n\n[Generalization](https://github.com/REBOOTERS/My-MVP/blob/master/uml/Generalization.puml)\n\n### 实现\n\n同样以 Android 中 View 和 RecyclerView 为例，他们各自实现了不同的接口 。\n\n用**带空心三角的虚线**表示，箭头指向接口\n\n<img src=\"UML-基础结构/Realization.png\" height=auto />\n\n[Realization](https://github.com/REBOOTERS/My-MVP/blob/master/uml/Realization.puml)\n\n### 依赖\n\n依赖关系是类与类之间最弱的关系，依赖可以简单的理解一个类使用了另一个类。同时被依赖的类，如果发生了变化会影响依赖他的类。\n\n这个最好的解释就是 View 的 draw 方法了, 在整个 View 类中，只是需要在 draw 方法中依赖 Canvas 进行绘制操作。onTouchEvent() 的参数 MotionEvent 也是类似。对 View 来说只是依赖这两个类完成一些关键操作，同时 MotiveEvent 有不同的 event 时，View 也需要发生相应的变化。\n\n用**带箭头的虚线**表示，箭头指向当前类依赖的类\n\n<img src=\"UML-基础结构/Dependence.png\" height=300 />\n\n[Dependence](https://github.com/REBOOTERS/My-MVP/blob/master/uml/Dependence.puml)\n\n**总的来说，依赖关系就是在某个类的方法中需要另一个类**，但这种依赖关系不一定表现为形参，具体细节可参考[设计模式之 UML 类图](https://zhuanlan.zhihu.com/p/24576502)。当然，这里遵循设计模式中『依赖注入』的理念，使用形参去注入另外一个类（这里的类泛指类和接口）来实现依赖应该是更好的选择。\n\n### 关联\n\nAssociation\n\n关联关系的定义为：对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。关联关系表示一个类和另一类有联系，是一种包含关系。\n\n> 关联关系分为单向关联和双向关联：在 Java 中，\n>\n> - 单向关联表现为: 类 A 当中使用了 类 B，其中类 B 是作为类 A 的> 成员变量。\n> - 双向关联表现为: 类 A 当中使用类 B 作为成员变量，同时类 B 中也使用了类 A 作为成员变量。\n\n这里就需要了解一下，关联和依赖的区别了。**在依赖关系中，被依赖的类只是临时被拿来用一下，和当前类只是一种偶然的关系，而在关联关系中，所有被关联的类，和当前类都是有必然联系的类。**\n\n**这种关系通常使用类的属性表达**,比如 Android 中的 ViewGroup 的 LayoutParams 类。\n\n关联关系用**带箭头的直线**表示，箭头指向当前类关联的类\n\n<img src=\"UML-基础结构/Association.png\" height=200 />\n\n[Association](https://github.com/REBOOTERS/My-MVP/blob/master/uml/Association.puml)\n\n每个 ViewGroup 必然会有他的 LayoutParams 类，来补充 ViewGroup 的具体信息。\n\n### 聚合（Aggregation）\n\n聚合关系是关联关系的一种，耦合度强于关联。表示 has-a 的关系，是一种不稳定的包含关系。\n\n这种场景也是比较常见的。比如在为了方便实现 RecyclerView 中的点击事件，一般会在其 Adapter 类中注入一个接口，通过回调的方式来实现点击事件的监听。\n\n```java\npublic class MyAdapter extends RecyclerView.Adapter {\n20    .....\n24\n25     private OnRecyclerViewListener onRecyclerViewListener;\n26\n27     public void setOnRecyclerViewListener(OnRecyclerViewListener onRecyclerViewListener) {\n28         this.onRecyclerViewListener = onRecyclerViewListener;\n29     }\n\n       ....\n}\n```\n\n这是一种典型的 has-a 关系。\n\n用**带空心菱形的直线**表示，菱形从局部指向整体\n\n\n<img src=\"UML-基础结构/Aggregation.png\" height=200 />\n\n[Aggregation](https://github.com/REBOOTERS/My-MVP/blob/master/uml/Aggregation.puml)\n\n### 组合\n\n组合关系也是一种部分和整体的关系，但是部分存活周期受到整体的影响，若整体不存在则部分也将不存在。\n\n这个就很好理解，我们平时写的 Activity 或 Fragment 和其内部成员的关系就是这样，Acitivity 或 Fragment 内的各种 View,Presenter,ViewModel 对象，一旦这个 Activity 或 Fragment 销毁了，那么这些内容基本也就没有存在的意义了。\n\n用**用带实心菱形的直线**表示，菱形从局部指向整体\n\n\n\n<img src=\"UML-基础结构/Composition.png\" height=200 />\n\n[Composition](https://github.com/REBOOTERS/My-MVP/blob/master/uml/Composition.puml)\n\n组合关系的另一个例子就是自定义 View 的实现。\n\n比如下面一个自定义闹钟的实现 ClockView(节选部分，完整源码可参考[ClockView](https://github.com/REBOOTERS/AndroidAnimationExercise/blob/master/app/src/main/java/home/smart/fly/animations/customview/ClockView.java)) 中;用 Paint,TextPaint,RectF,ValueAnimator 组合起来，完成了这个自定义 View ，但是同时当这个自定义不存在时，这些类就没什么存在的意义了。\n\n```java\npublic class ClockView extends View {\n\n    private Paint mCirclePaint;\n    private Paint mArcPaint;\n    private TextPaint mTextPaint;\n\n    private RectF mRectF;\n    private ValueAnimator mAnimator;\n}\n\n```\n\n<img src=\"UML-基础结构/Composition1.png\" height=200 />\n\n[Composition](https://github.com/REBOOTERS/My-MVP/blob/master/uml/Composition1.puml)\n\n## 总结\n\n- 上述六种类的关系，按照 **依赖>关联>聚合>组合>继承>实现 的顺序，他们的耦合度依次增强**。这就是为什么设计模式中，提倡我们依赖注入的原因，同时我们也可以看到组合的耦合度是低于继承的，所以在继承一个父类之前，我们可以优先考虑一下组合的可能性。\n- 结合上调耦合度关系，及组合、聚合和关联的定义，我们可以知道，在代码层面这三种关系其实是非常相似的，我们很难直接从代码分析出类之间的 关联、聚合、组合这三种关系来，需要结合其具体的语义才能分辨。\n- 关于关联，聚合、组合更友好的解释。\n\n> 聚合和组合的关系,表示一个类对象持有另外的类对象作为自己的一个属性.\n>\n> 关联仅仅表示一个对象跟另外的对象发生了通信, 没有持有它作为对象.\n>\n> 所以人们说: 关联描述的是方法层次上的交互, 而聚合和组合是描述属性层次上的交互!\n>\n> For Example: 邮递员和你的交互, 属于关联, 因为他只是拜访你, 给你送一封信.\n> 邮递员和邮局的关系,属于聚合或者组合{暂且只区分关联关系}.\n> 原因是: 你打电话给邮递员送信,邮递员不一定听你的, 而邮局就不同了, 它要自己的\n> 邮递员送信, 邮递员敢不听话吗?\n> 这就是关联跟其它两种方法的区别, 你没有持有对方做为自己的属性, 用一次,算别人给你\n> 的恩赐, 但你不可能肆意指挥它\n\n> 聚合和组合的关系:\n> 他们都将对象持有为属性. 但这是不同的.\n> 比如你买的书, 和你借的书. 现在都放在家里. 但概念是不同的, 你买的书,可以随便处理,\n> 鬼划糊涂,但图书馆的借来的书,你能这么干吗? 聚合:大家都可持有,但不可完全占有,组合:\n> 私有财产.\n\n## 参考文档\n\n[设计模式之 UML 类图](https://zhuanlan.zhihu.com/p/24576502)\n\n[五分钟看懂 UML 类图与类的关系详解](https://juejin.im/post/5b42d4396fb9a04fbc21d7dd)\n\n[UML 的关联(Association), 聚合(Aggregation), 组合(Composition)区别](https://ostrichmyself.iteye.com/blog/733720)","tags":["UML"]},{"title":"关于《绿皮书》的一些感想","url":"%2F2019%2F03%2F10%2F%E5%85%B3%E4%BA%8E%E3%80%8A%E7%BB%BF%E7%9A%AE%E4%B9%A6%E3%80%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3%2F","content":"\n\n<img src=\"关于《绿皮书》的一些感想/p2549177902.webp\" />\n\n很久没有看到这样的电影了，看完的时候，内心真的很舒服。好久没有这样的感受了，太多的台词太经典了，尤其是那句 **世界上有太多孤独的人害怕先踏出第一步（the world's full of lonely people afraid to make the first move ）** ,心真的颤了一下。\n\n\n\n<!--more-->\n\n想写的东西太多，却又不知从何写起，就用这些剧照(图源自豆瓣电影)表达我的心情吧。\n\n- 让我看的时候停下来沉思了十分钟的电影台词\n\n<img src=\"关于《绿皮书》的一些感想/p2548973932.webp\" />\n\n- 也许这应该是我们做事时最该有的态度\n\n<img src=\"关于《绿皮书》的一些感想/p2545880063.webp\" />\n\n- 有多少类似这样的话，却从来没有听人说起过\n\n<img src=\"关于《绿皮书》的一些感想/p2549106335.webp\" />\n\n- 我们应该怎样活着\n\n<img src=\"关于《绿皮书》的一些感想/p2548991669.webp\" />\n\n- 最后，两张好看的电影剧照\n\n<img src=\"关于《绿皮书》的一些感想/p2548719163.webp\" />\n\n<img src=\"关于《绿皮书》的一些感想/p2548719157.webp\" />\n\n\n\n[更多剧照](https://movie.douban.com/subject/27060077/photos?type=S)\n\n\n","tags":["电影观后感"]},{"title":"读《曾国藩 又笨又慢平天下》的一些感想","url":"%2F2019%2F03%2F03%2F%E3%80%8A%E6%9B%BE%E5%9B%BD%E8%97%A9-%E5%8F%88%E7%AC%A8%E5%8F%88%E6%85%A2%E5%B9%B3%E5%A4%A9%E4%B8%8B%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F","content":"\n对曾国藩一直不是很了解，只是在近代历史故事里，总能听到他的名字。尤其这两年曾国藩似乎成为励志人物，曾国藩家书，曾国藩各种事迹被翻出，各种名家大师都会推荐我们去读曾国藩，了解他这一生的故事。因此，就从这本从国家图书馆借来的书，了解一下这位历史名人的一些故事。\n\n<!--more-->\n\n<img src=\"《曾国藩-又笨又慢平天下》读后感/s28787066.jpg\" width=30% height=20%/>\n\n\n### 关于作者\n\n首先简单说下这本书的作者吧，**度阴山**，百科上有关于他的介绍，就不多说了。读完这本书感觉作者的文风还是比较风趣，人物对话和内心活动的语言描述都比较**平民化**，有种和好友聊天的感觉。\n\n全书中关于曾国藩出生和去世时的描述挺有意思。\n\n*说曾国藩出生的前一天，几只蚰蜒(youyan)爬上了房梁，俯瞰下面昏昏欲睡的他的曾祖父曾竟希。\n曾竟希也老眼昏花的看着它们，当确信没有看错时，他用尽全身的力气喊道：“龙，龙，有龙！”*\n\n*曾国藩晚年（61岁）去世的时候，房间里一片死寂，有忍耐不住这死一般的沉寂，似乎受到了神灵的启示，偷偷望向房梁。几只蚰蜒正在房梁上快乐的玩耍，突然“砰”的一声，蚰蜒如爆竹似的爆开，刺鼻的烟气袅袅绕梁。*\n\n这一前一后的呼应，不知真假，但在整部书读完的一瞬间，还是感觉这作者挺有意思。\n\n### 曾国藩是一个怎样的人\n\n按照现在的条件，曾国藩完全是一屌丝，而且是那种智商特别低的屌丝，简直就是一个反向爱因斯坦。说是有一日一小偷进到曾国藩房里想偷东西，结果临要走了，曾国藩突然回来，小偷无奈只得藏在曾国藩床底，曾国藩一进屋便开始在屋里背一篇文章，结果过去好几个时辰，还没背会；小偷在床底下偷听都背会了，最后小偷实在受不了了，就从床底下爬出来，狠狠吐槽了一顿曾国藩有多么笨之后扬长而去，曾国藩很无奈，接着继续背文章，直到第二天凌晨才背会。\n\n读书考取功名，考了 N 多次才考上，而且也考得不是很好。\n\n后来在京城做官，虽然做到了很高的品级，算是给曾家光宗耀祖了，但最终还是离开了北京。\n\n后来，在湖南任职期间创建了大名鼎鼎的湘军，并一举消灭了太平天国的叛乱。\n\n曾国藩秉承的自己的做人的原则，深知自身的缺点与毛病，坚守着自己内心的”忠“与”诚“，竭尽全力的为国效力。感觉有点生不逢时，遇到了清末洋人入侵，慈禧夺权等一系列悲剧的事情。全篇通读下来，感觉曾国藩的一生非常的不容易。**”打脱牙和血吞“**的就像是笼罩在他头顶的阴影，在他人生的弯弯角角里不断的锤炼着他。\n\n### 感想\n\n如今，在我们身边还是有想曾国藩这般的人，天赋一般，但就是非常努力的人。但不得不说很多时候机遇很重要，遇见对的人，在那个正确的时间做了正确的事，真的非常重要。有句话说，机会是留给有准备的人，所以如果普通人想要打破阶级到达另一个阶层，一定要练好自己的内功，时刻准备好不期而遇的机会，有些机会转瞬即逝，莫要留下终生遗憾。\n\n","tags":["读书"]},{"title":"2019-Book&Movie List","url":"%2F2019%2F01%2F06%2F2019-Book%26Movie%20List%2F","content":"\n\n## Book\n\n - book read once \n\n    - [x] **人类简史 ❤️❤️❤️❤️❤️**\n    - [x] 曾国藩 又笨又慢平天下 ❤️❤️❤️❤️\n    - [x] 基督山伯爵 - 大仲马 ❤️❤️❤️❤️❤️\n    - [x] **美国简史** ❤️❤️❤️❤️\n    - [x] 士兵突击\n    - [x] 长脖子女人\n    - [x] 白鹿原\n    - [x] Google 方法 ❤️❤️❤️❤️\n\n\n- book on bed\n\n    - [ ] **原则(pending)**\n    - [ ] **软技能(reading)**\n    - [ ] 并发编程之美 （reading)\n    - [ ] Kotlin 实战 （reading）\n    - [x] Android 设计模式\n    - [ ] Java8 实战 \n    - [ ] **算法（第 4 版）**\n    - [ ] Think in Java\n    - [ ] Head First 设计模式 （reading)\n\n## Movie\n\n- [x] **无名之辈 ❤️❤️❤️❤️❤️**\n- [x] 狗十三 ❤️❤️❤️\n- [x] **流浪地球 ❤️❤️❤️❤️**\n- [x] 来电狂响 ❤️❤️\n- [x] 绿皮书 ❤️❤️❤️❤️❤️\n- [x] 白蛇缘起 ❤️❤️❤️❤️❤️\n- [x] 掠食城市 ❤️\n- [x] 新喜剧之王 ❤️❤️\n- [x] 疯狂外星人 ❤️❤️❤️❤️\n- [x] **飞驰人生** ❤️❤️❤️❤️❤️\n- [x] **复仇者联盟 4** ❤️❤️❤️❤️❤️\n- [x] **X战警 火凤凰** ❤️❤️❤️❤️\n- [x] **辛德勒的名单** ❤️❤️❤️❤️❤️\n- [x] 调音师 ❤️\n- [x] 三傻大闹宝莱坞 ❤️❤️❤️❤️❤️\n- [x] 蜘蛛侠：英雄远征 ❤️❤️❤️❤️\n- [x] 惊奇队长 ❤️❤️❤️\n- [x] 绝杀慕尼黑 ❤️❤️❤️\n- [x] 冠军 ❤\n- [x] 黑客帝国 (一) ❤️❤️❤️❤️\n- [x] 黑客帝国 (二) ❤️❤️❤️❤️❤️\n- [x] 黑客帝国 (三) ❤️❤️❤️❤️\n- [x] 无间道 (一)  ❤️❤️❤️❤️❤️\n- [x] 无间道 (二)  ❤️❤️❤️❤\n- [x] 无间道 (三)  ❤️❤️❤️❤️❤\n- [x] 一个母亲的复仇 ❤️❤️❤️\n- [x] 楚门的世界 ❤️❤️❤️❤️❤\n- [x] 肖申克的救赎 ❤️❤️❤️❤️❤️\n- [x] 战斗天使阿丽塔 ❤️❤️\n- [x] 寄生虫 ❤️❤️❤️❤️\n- [x] 飞屋环游记 ❤️❤️❤️❤️\n- [x] 疾速备战 ❤\n- [x] 全民追女王 ❤️❤️\n- [x] 血观音 ❤️❤️\n- [x] 作家的谎言 ❤️❤️\n- [x] 无所不能 ❤️❤️❤️\n- [x] 过春天 ❤️❤️❤️\n- [x] **速度与激情-特别行动** ❤️❤️❤️\n- [x] Hello 树先生 ❤️❤️❤️❤\n- [x] 安娜 ❤️❤️❤❤️\n- [x] 英雄 ❤️❤️❤️❤️❤️\n- [x] **哪吒** ❤️❤\n- [ ] **江湖儿女**\n- [x] **我和我的祖国** ❤️❤️\n- [x] **中国机长** ❤️❤️❤️❤️\n- [x] **攀登者** ❤️❤️❤️\n- [x] **叶问 4** ❤️❤️❤️❤️❤️\n- [x] **勇敢者游戏2** ❤️❤️❤️\n- [ ] 沉睡魔咒 2 （abandon）\n- [x] 海市蜃楼 ❤️❤️❤️❤️\n- [ ] 嗝嗝老师 （abandon）\n- [ ] 印度暴徒 （abandon）\n- [x] 飞龙再生 ❤️❤️❤️\n- [x] 周末同床 ❤️❤️❤️\n- [x] 新龙门客栈 ❤️❤️❤️❤️❤️\n- [x] 罗小黑战记 ❤️❤️❤️\n- [x] 鬼影特攻：以暴制暴 6  ❤️❤️❤️❤️\n\n> time ≈ 2.2h * 38 = 83.6h \n\n\n## Tv\n\n- [x] 铁齿铜牙纪晓岚 第三部 （43 * 45 min = 1935 ≈ 32.2h)\n- [x] 铁齿铜牙纪晓岚 第四部 （43 * 45 min = 1935 ≈ 32.2h)\n- [x] 每周英超精华 （ 30 * 50 = 1500 = 25h)\n- [x] 王牌对王牌 （10 * 1.6h = 16h)\n- [x] 士兵突击 (10 * 45 = 450 = 9h)\n- [x] **王朝** ❤️❤️❤️❤️❤️❤️❤️❤️ 5h\n- [x] **一个星球，七个世界** ❤️❤️❤️❤️❤️❤️❤️❤️\n- [ ] **越南战争** (watching)\n- [x] **计算机科学的奥秘 B站** ❤️❤️❤️❤️\n- [x] **第三帝国最后的秘密**\n- [x] **触及真心** （16 * 70 = 1120 ≈ 18.6h) ❤️❤️❤️\n- [x] 我们与恶的距离  10h \n- [x] 长安十二时辰 (48 * 42 min ≈ 33.6h)\n- [ ] 每周天下足球 (52 * 2h = 104h)\n- [ ] 真探\n- [x] 生活大爆炸最终季 (24 * 22 = 528 ≈ 8.8h)\n- [x] 小谢尔顿第二季 (22 * 22 = 484 ≈ 8h)\n- [x] 摩登家庭第九季 (22 * 22 = 484 ≈ 8h)\n- [x] 神盾局特工第六季 (13 h) \n- [x] **无耻之徒第九季** (14 * 55 = 770 ≈ 12.8h) \n- [x] 超感警探第一季（22 * 43 = 946 ≈ 15.7h）\n- [x] 超感警探第二季（22 * 43 = 946 ≈ 15.7h）\n- [x] 超感警探第三季 (22 * 43 = 946 ≈ 15.7h)\n- [x] 超感警探第四季 (24 * 43 = 1032 ≈ 17.2h)\n- [x] 超感警探第五季 (22 * 43 = 1032 ≈ 15.7h)\n- [x] 超感警探第六季 (watching)\n- [x] 摩登家庭最终季 (截至 第9集)\n- [x] 无耻之徒第十季 (截至 第6集)\n\n> time ≈ 215h + 104h \n> \n\n**（截止 2019 年 9 月 15 日）**\n\n\n## 时间都去哪儿了\n\n- 每天 = 24h \n\n- 每周 = 7 * 24h = 168h \n\n- 每年 = 52 * 168h = 8736h \n\n- 每月 ≈ 8736 / 12 = 728 h \n\nsleep_every_day = 8h\nyear_sleep = 8h * 7 * 52 = 2912h \n\nwork_every_day = 10h\nyear_work = 10h * 5 * 52 = 2600h \n\n\nevery_year_real_free_time = 8736 - 2912 - 2600 = 3224h\n\n\n\n\n\n\n","tags":["诗与远方"]},{"title":"Some One Like You","url":"%2F2019%2F01%2F01%2FSome-One-Like-You%2F","content":"\n记录一下每一个月干了些啥吧。\n\n\n## 七月 Result\n\n\n|study|entertainment |else| \n|-----|--------------|----|\n|简单实现 GIF 图的倒序播放|无间道电影三部|kotlin 实战阅读|\n|ARouter API 简单分析|长安十二时辰1~26集|软技能阅读|\n|ASM 代码插桩简单尝试|一个复仇的母亲|基督山伯爵 1~21 章\n|react 入门||原则阅读 36%|\n|JavaScript 入门||《白鹿原》听书1~38章|\n\n\n## 八月 todo \n\n\n- study\n    - [ ] **TimeFly** \n    - [ ] asm 插桩 blog \n    - [ ] arouter 插桩分析 blog\n    - [ ] fragment + viewpager 分析 blog\n    - [ ] react + JavaScript 熟练\n- entertainment\n    - [ ] 看海\n    - [x] 骑车去二环\n    - [x] 长安十二时辰完结\n- else\n    - [x] effective java 阅读\n    - [x] 《白鹿原》听书 39~60 章\n    - [ ] 基督山伯爵读完，并写读后感\n    - [ ] **我们与恶的距离 blog**\n    - [ ]  kotlin 实战 blog \n\n> 综上： 需要写 6 篇 blog ,本月以读书为主，多看一点书，好久没看书了。\n\n## 八月 Result\n\n|study|entertainment |read|else|\n|-----|----------------|----|----|\n|javac vs kotlinc|楚门的世界|基督山伯爵 22-99|🚴二环骑行 |\n|javascript |肖申克的救赎|《白鹿原》听书39~99章 | |\n|css |战斗天使阿丽塔| | |\n|TimeFly Structure|寄生虫| | |\n|ASM demo |飞屋环游记| | |\n|SPI |长安十二时辰 27-48（完结）| | |\n| |神盾局特工 6-13（第六季完结)| | |\n\n\n\n\n## 九月 todo \n\n- study\n    - [ ] **TimeFly Release And Publish** \n    - [ ] asm 插桩 blog \n    - [ ] arouter 插桩分析 blog\n    - [ ] c \n- entertainment\n    - [ ] 越南战争纪录片\n- read\n    - [x] 《白鹿原》听书 100-118 章（完结）\n    - [ ]  基督山伯爵（100-118） 并写读后感\n    - [ ]  Java 虚拟机\n- else\n    - [ ] **我们与恶的距离 blog**\n    - [ ] 基督山伯爵读后感\n    - [ ] StreetView 数据统计和视频合成 Feature\n \n## 九月 Result\n\n|study|entertainment |read|else|\n|-----|----------------|----|----|\n|TimeFly 1.0.1 上线|速度与激情-特别行动|基督山伯爵 完结|自动化抓取下载地址|\n|网站备案完成 |血观音|《白鹿原》完结 | |\n|云服务器部署完成|过春天|Android 设计模式 Done | |\n|计算机科学的奥秘 1-20 集|无所不能| Head First Java Done| |\n|Java & Android 图片合成视频技术|作家的谎言| 软技能| |\n|ffmpeg||晓说第一季听书| |\n\n\n10 月 todo \n\n本月由于回家，时间已过半，优先将之前未完成的 TODO 酌情补充完成，估计就差不多了。\n\n## 十月 Result\n\n|study|entertainment |read|else|\n|-----|----------------|----|----|\n|VideModel 源码解读|Hello 树先生|Google 方法 80%|国庆回家 10 天|\n|Android 开发高手课（极客时间）学习 1-10 |安娜|C 程序设计语言 30%|bash-bot 脚本，薅羊毛|\n||哪吒||StreetView 发布两个版本，集成 push功能，日活提升|\n||计算机科学速成课（B 站视频）done|||\n||超感警探第四季 done|||\n\n\n## 十一月 Result\n\n|study|entertainment |read|else|\n|-----|----------------|----|----|\n|Gradle Transform 插桩学习|英雄|Google 方法读完||\n|Android 开发高手课（极客时间）学习 11-30 |攀登者|C 程序设计语言读完|bash-bot 脚本，薅羊毛|\n||罗小黑战记|Head First 设计模式 20%|StreetView 发布一个版本，更新 SDK,减小包体积|\n||奇葩说第六季 ing|Android 进阶解密阅读 20%||\n||超感警探第五季 done|||\n||超感警探第六季 ing|||\n||电影《飞龙再生》|||\n||电影《周末同床》|||\n\n\n## 十二月 TODO\n\n- study\n    - jar 生成 blog\n    - asm blog \n    - gradle transform blog \n\n- read\n    - kotlin 实战 notes \n    - java 8 实战\n\n- else\n    - 年终 review \n\n\n\n## 十二月 Result\n\n|study|entertainment |read|else|\n|-----|----------------|----|----|\n|Java字节码处理 asm 学习|我和我的祖国||年终 review 公众号章发布|\n|jar 文件生成学习 |中国机长||年终相册盘点 公众号发布|\n| |鬼影特攻：以暴制暴6||知乎写回答，创作者等级达到 V3|\n||叶问4|Head First 设计模式 40%|StreetView 发布2个版本,对界面做了一些调整|\n||奇葩说第六季 ing|||\n||吐槽大会第五季 ing|||\n||灵书妙探第一季 ing|||\n\n\n这一年，看剧和看视频的时间花费的太多了，多看点书吧。\n\n","tags":["OKR"]},{"title":"RxJava2 是如何实现线程切换的（下）","url":"%2F2018%2F05%2F08%2FRxJava2%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%EF%BC%88%E4%B8%8B%EF%BC%89%2F","content":"\n\n## 前言\n\n通过前一篇的[RxJava2 是如何实现线程切换的 (上)](https://juejin.im/post/5a6751af6fb9a01cb2571794)我们已经知道了在RxJava中，subscribeOn 将上游线程切换到**指定的子线程**是如何实现的。这里就接着来看，observeOn 是如何将下游线程切换到指定线程的。\n\n<!--more-->\n\n## RxJava - subscribeOn\n\n这里可以通过UML图简单回顾一下subscribeOn的原理。\n\n\n![](https://user-gold-cdn.xitu.io/2018/1/23/16123a868c390ac1?w=1127&h=525&f=png&s=51911)\n\n通过 subscribeOn 我们完成了以下操作：\n\n - 创建了一个 ObservableSubscribeOn 对象，本质上来说他就是一个Observable，他同时实现了 AbstractObservableWithUpstream（HasUpstreamObservableSource ）这样一个接口，是他变了一个**拥有上游**的Observeable。\n - 在 ObservableSubscribeOn 的 subscribeActual 方法中\n\n```java\nparent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));\n```\n将真正的 subscribe 操作安置在了SubscribeTask这样个一个Runnable当中，这个 Runnable 将由scheduler 这个调度器负责启动，因此就把上游操作放到了 scheduler 所在的线程中。\n\n- Schedulers.newThread()或者Schedulers.io() 都是通过工厂方法的模式创建了某种**指定类型**的线程， 当这个特定的线程执行是，就是执行真实的 subscribe 方法，这样就把上游操作放到了一个特定的线程中去执行。\n\n## RxJava - observeOn\n\n简单回顾完 subscribeOn 之后，我们就来看看 observeOn 是如何工作的。\n\n**其实，了解 subscribeOn 的原理之后，再来看 observeOn 就简单多了，类的命名及实现思路都有很多相似之处，可以对照着理解**。\n\n![ObserveOn](https://user-gold-cdn.xitu.io/2018/6/4/163cb392e2328470?w=1280&h=616&f=png&s=215509)\n\nRxJava的代码写的非常巧妙，可以说是百读不厌，可以学习的地方特别多。为了避免陷入只见树木不见森林的噩梦，我们就带着以下问题去探索 observeOn 的奥秘。\n\n1. 在 Android 中线程间传递消息会使用 Handler，这里是否使用？又是如何使用的？\n2. AndroidSchedulers.mainThread() 做了什么 ？ \n3. 下游任务是如何保证被分配到指定线程的。\n\n#### 示例 \n\n```java\n\n    private void multiThread() {\n        Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"This msg from work thread :\" + Thread.currentThread().getName());\n                sb.append(\"\\nsubscribe: currentThreadName==\" + Thread.currentThread().getName());\n            }\n        })\n                .subscribeOn(Schedulers.newThread())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Consumer<String>() {\n                    @Override\n                    public void accept(String s) throws Exception {\n                        Log.e(TAG, \"accept: s= \" + s);\n                    }\n                });\n    }\n\n```\n\n我们还是以这段代码为例，来看看 observeOn 的工作原理。这里通过observeOn(AndroidSchedulers.mainThread())将下游线程切换到了我们非常熟悉的 Android UI 线程。这样就可以确保我们在下游所有的操作都是在 UI 线程中完成。这里和讨论 subscribeOn 一样，我们就从这句代码出发，看看这背后到底发生了什么。\n\n有了上一篇的经验，我们知道 AndroidSchedulers.mainThread() 一定去创建了某种类型的调度器，为了方便后面的叙述，这一次我们先从调度器的创建说起，后面再看 observeOn() 的具体实现。\n\n\n**需要注意的是 AndroidSchedulers 并不是 RxJava 的一部分，是为了在 Android 中方便的使用 RxJava 而专门设计的一个调度器实现，源码[RxAndroid](https://github.com/ReactiveX/RxAndroid) 设计非常巧妙；使用前记得在gradle文件中配置依赖。**\n\n\n### AndroidSchedulers.mainThread()\n\n下面就来看看 AndroidSchedulers.mainThread() 这个我们非常熟悉的 Scheduler 是如何创建的。\n\n```java\npublic final class AndroidSchedulers {\n\n    private static final class MainHolder {\n\n        static final Scheduler DEFAULT = new HandlerScheduler(new Handler(Looper.getMainLooper()));\n    }\n\n    private static final Scheduler MAIN_THREAD = RxAndroidPlugins.initMainThreadScheduler(\n            new Callable<Scheduler>() {\n                @Override public Scheduler call() throws Exception {\n                    return MainHolder.DEFAULT;\n                }\n            });\n\n    public static Scheduler mainThread() {\n        return RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);\n    }\n}\n```\n\n这里我们可以认为，当调用AndroidSchedulers.mainThread() 时，返回了一个HandlerScheduler 的实例，而这个实例使用到了我们非常熟悉的 Handler。那么重点就来到HandlerScheduler 了。\n\n\n```java\nfinal class HandlerScheduler extends Scheduler {\n    private final Handler handler;\n\n    HandlerScheduler(Handler handler) {\n        this.handler = handler;\n    }\n\n    @Override\n    public Disposable scheduleDirect(Runnable run, long delay, TimeUnit unit) {\n        if (run == null) throw new NullPointerException(\"run == null\");\n        if (unit == null) throw new NullPointerException(\"unit == null\");\n\n        run = RxJavaPlugins.onSchedule(run);\n        ScheduledRunnable scheduled = new ScheduledRunnable(handler, run);\n        handler.postDelayed(scheduled, Math.max(0L, unit.toMillis(delay)));\n        return scheduled;\n    }\n\n    @Override\n    public Worker createWorker() {\n        return new HandlerWorker(handler);\n    }\n\n    private static final class HandlerWorker extends Worker {\n        private final Handler handler;\n\n        private volatile boolean disposed;\n\n        HandlerWorker(Handler handler) {\n            this.handler = handler;\n        }\n\n        @Override\n        public Disposable schedule(Runnable run, long delay, TimeUnit unit) {\n            if (run == null) throw new NullPointerException(\"run == null\");\n            if (unit == null) throw new NullPointerException(\"unit == null\");\n\n            if (disposed) {\n                return Disposables.disposed();\n            }\n\n            run = RxJavaPlugins.onSchedule(run);\n\n            ScheduledRunnable scheduled = new ScheduledRunnable(handler, run);\n\n            Message message = Message.obtain(handler, scheduled);\n            message.obj = this; // Used as token for batch disposal of this worker's runnables.\n\n            handler.sendMessageDelayed(message, Math.max(0L, unit.toMillis(delay)));\n\n            // Re-check disposed state for removing in case we were racing a call to dispose().\n            if (disposed) {\n                handler.removeCallbacks(scheduled);\n                return Disposables.disposed();\n            }\n\n            return scheduled;\n        }\n\n        @Override\n        public void dispose() {\n            disposed = true;\n            handler.removeCallbacksAndMessages(this /* token */);\n        }\n\n        @Override\n        public boolean isDisposed() {\n            return disposed;\n        }\n    }\n\n    private static final class ScheduledRunnable implements Runnable, Disposable {\n        private final Handler handler;\n        private final Runnable delegate;\n\n        private volatile boolean disposed;\n\n        ScheduledRunnable(Handler handler, Runnable delegate) {\n            this.handler = handler;\n            this.delegate = delegate;\n        }\n\n        @Override\n        public void run() {\n            try {\n                delegate.run();\n            } catch (Throwable t) {\n                IllegalStateException ie =\n                    new IllegalStateException(\"Fatal Exception thrown on Scheduler.\", t);\n                RxJavaPlugins.onError(ie);\n                Thread thread = Thread.currentThread();\n                thread.getUncaughtExceptionHandler().uncaughtException(thread, ie);\n            }\n        }\n\n        @Override\n        public void dispose() {\n            disposed = true;\n            handler.removeCallbacks(this);\n        }\n\n        @Override\n        public boolean isDisposed() {\n            return disposed;\n        }\n    }\n}\n```\n这个类虽然很简单，但是设计非常巧妙。\n\n- **首先 HandlerScheduler 是一个 Scheduler ，通过构造函数他获取到了主线程所在的 Handler实例。而在他的 createWorker() 方法中，他又通过这个 Handler 实例创建了一个HandlerWorker 的实例，这个HandlerWorker 本质上就是一个 Worker。在他的 schedule 方法中，创建了一个 ScheduleRunnable 对象，并会把这个Runnable对象通过 handler 的 sendMessageDelayed 方法发送出去，而我们知道这个 Handler 是主线程，这样在下游中，就把任务从某个子线程转移到了UI线程。**\n\n\n- ScheduleRunnable 不但实现了 Runnable ，而且实现了我们看到过无数次的 Disposable 。\n\n```java\n        @Override\n        public void run() {\n            try {\n                delegate.run();\n            } catch (Throwable t) {\n\n            }\n        }\n\n        @Override\n        public void dispose() {\n            disposed = true;\n            handler.removeCallbacks(this);\n        }\n```\n这样，正确情况下 run 方法会正常执行线程中的任务，而一旦 disposable  对象执行了dispose()方法，那么 handler.removeCallbacks(this),就可确保在 handler 的 dispatchMessage 方法中，不会在执行任何操作，从而达到了 dispose 的效果。\n\n\n\n### observeOn\n \n下面就来看看 Observable 中的 observeOn 方法\n\n**Observable.java --- observeOn**\n\n```java\n\n    public final Observable<T> observeOn(Scheduler scheduler) {\n        return observeOn(scheduler, false, bufferSize());\n    }\n\n    public final Observable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaPlugins.onAssembly(new ObservableObserveOn<T>(this, scheduler, delayError, bufferSize));\n    }\n```\n\n这个方法的实现和 subscribeOn 的实现非常相似，多了两个参数 delayError 和 buffersize 。 buffersize 可以认为是RxJava内部的一个静态变量，默认情况下他的值是128。通过我们之前的经验，这里可以把 observeOn 的过程简化如下：\n\n```java\nnew ObservableObserveOn<T>(this, scheduler, delayError, bufferSize)\n```\n也就是说 observeOn 这个操作符给我们返回了一个 ObservableObserveOn 对象。很容易想到他也是一个 Observeable。那么我们就去看看这个 ObservableObserveOn 到底是什么？我们最关心的 subscribeActual 方法他又是怎样实现的。\n\n\n\n#### ObservableObserveOn\n\n```java\npublic final class ObservableObserveOn<T> extends AbstractObservableWithUpstream<T, T> {\n    final Scheduler scheduler;\n    final boolean delayError;\n    final int bufferSize;\n    public ObservableObserveOn(ObservableSource<T> source, Scheduler scheduler, boolean delayError, int bufferSize) {\n        super(source);\n        this.scheduler = scheduler;\n        this.delayError = delayError;\n        this.bufferSize = bufferSize;\n    }\n\n    @Override\n    protected void subscribeActual(Observer<? super T> observer) {\n        if (scheduler instanceof TrampolineScheduler) {\n            source.subscribe(observer);\n        } else {\n            Scheduler.Worker w = scheduler.createWorker();\n\n            source.subscribe(new ObserveOnObserver<T>(observer, w, delayError, bufferSize));\n        }\n    }\n}\n\n```\n\n和 ObservableSubscribeOn 一样，他也继承了 AbstractObservableWithUpstream ，这样他也是一个拥有上游的 Observeable，他的构造函数很简单，没什么可以说。这里我们重点关注一下 subscribeActual 方法的实现。这里我们的使用的**Scheduler 实例是 AndroidSchedulers.mainThread()**，因此就按 else的逻辑分析。\n\n```java\n\n            Scheduler.Worker w = scheduler.createWorker();\n\n            source.subscribe(new ObserveOnObserver<T>(observer, w, delayError, bufferSize));\n```\n\n通过 scheduler.createWorker() 创建了 Worker 这个对象。这里结合之前对 AndroidSchedulers.mainThread() 的分析，此处的 worker 对象是就是一个持有主线程 handler 引用的 Worker。\n\n\n接着用这个worker又创建了一个ObserveOnObserver对象。看看这个类的实现。\n\n\n```java\n    static final class ObserveOnObserver<T> extends BasicIntQueueDisposable<T>\n    implements Observer<T>, Runnable { ....}\n```\n\n这个类功能非常强大，首先是一个 Observer ，同时也是一个Runnable，并且还继承了 BasicIntQueueDisposable(保证原子性、拥有操作队列功能和 Disposable功能)。\n\n```java\nsource.subscribe(new ObserveOnObserver<T>(observer, w, delayError, bufferSize));\n```\n\n我们关注一下这行代码，根据之前的说法这里的 source 是其父类(AbstractObservableWithUpstream)中的成员变量，也就是说是上游，那么当前ObservableObserveOn 的上游是谁呢？ 就是我们上一篇所说的 ObservableSubscribeOn 。\n\n因此，当这里开始执行订阅方法 subscribe() 后，将以如下顺序响应：\n\n\n>**Observable.subscribe--->Observable.subscribeActual---> ObservableObserveOn.subscribeActual---> ObservableSubscribeOn.subscribeActual--->ObservableCreate.subscribeActual**\n\n这些方法的参数均为 observer,通过层层回调，最后的 subscribeActual(Observer<? super T> observer) 执行时，这个 observer 持有之前几个 observer 的引用。\n\n我们再看一下 **ObservableCreate.subscribeActual**\n\n```java\n    @Override\n    protected void subscribeActual(Observer<? super T> observer) {\n        CreateEmitter<T> parent = new CreateEmitter<T>(observer);\n        observer.onSubscribe(parent);\n\n        try {\n            source.subscribe(parent);\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            parent.onError(ex);\n        }\n    }\n```\n\n可以看到，这里首先会触发 observer.onSubscribe ，我们再看一下 **ObservableSubscribeOn.subscribeActual**\n\n```java\n    @Override\n    public void subscribeActual(final Observer<? super T> s) {\n        final SubscribeOnObserver<T> parent = new SubscribeOnObserver<T>(s);\n\n        s.onSubscribe(parent);\n\n        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));\n    }\n```\n\n好了，这样我们又回到了原点：\n\n```java\nsource.subscribe(new ObserveOnObserver<T>(observer, w, delayError, bufferSize));\n```\n\n回到了最初的 Observer：**ObserveOnObserver**\n\n\n这个 ObserveOnObserver 持有我们一开始创建的observer，也就是一个Consumer对象。\n\n下面就来看看这个 ObserveOnObserver\n\n- 构造函数\n\n```java\n        ObserveOnObserver(Observer<? super T> actual, Scheduler.Worker worker, boolean delayError, int bufferSize) {\n            this.actual = actual;\n            this.worker = worker;\n            this.delayError = delayError;\n            this.bufferSize = bufferSize;\n        }\n```\n\n这里指的注意的一点 ，actual 其实就是observer\n\n- onSubscribe\n\n```java\n@Override\n        public void onSubscribe(Disposable s) {\n            if (DisposableHelper.validate(this.s, s)) {\n                this.s = s;\n\t\t\t\t// 现阶段，我们用到的Disposable 都是单个的，暂时不讨论其\n\t\t\t\t//为QueueDisposable的情况\n\n                queue = new SpscLinkedArrayQueue<T>(bufferSize);\n\n                actual.onSubscribe(this);\n            }\n        }\n```\n\n在**ObservableCreate.subscribeActual** 中我们知道，当执行subscribe 方法后，首先会执行 observer的 onSubscribe 方法。这里的实现非常简单，就是创建了一个queue,并触发了这个 observer 自己的 onSubscribe 方法。\n\n- onNext\n\n```java\n        @Override\n        public void onNext(T t) {\n            if (done) {\n                return;\n            }\n\n            if (sourceMode != QueueDisposable.ASYNC) {\n                queue.offer(t);\n            }\n            schedule();\n        }\n```\n\n在 onNext 中会执行 scheule() 方法。\n\n```java\n        void schedule() {\n            if (getAndIncrement() == 0) {\n                worker.schedule(this);\n            }\n        }\n```\n\n**这个地方就有意思了，前面说过这里的 worker 是一个持有主线程handler 的Worker对象，当他的 schedule 执行时，就会把特定的线程任务通过Handler.postDelay 方法转移到主线中去执行** 。\n\n那么这里的this 又是什么呢？前面我们说过，ObserveOnObserver 这个类功能非常强大，他是一个Runnable，那么这里就是执行他自己的run方法喽，我们赶紧看看。\n\n```java\n        @Override\n        public void run() {\n            if (outputFused) {\n                drainFused();\n            } else {\n                drainNormal();\n            }\n        }\n```\n\n这里有一个参数 outputFused 他默认是false，至于他什么时候为true，不作为这里讨论的重点。\n\n```java\nvoid drainNormal() {\n            int missed = 1;\n\n            final SimpleQueue<T> q = queue;\n            final Observer<? super T> a = actual;\n\n            for (;;) {\n                if (checkTerminated(done, q.isEmpty(), a)) {\n                    return;\n                }\n\n                for (;;) {\n                    boolean d = done;\n                    T v;\n\n                    try {\n                        v = q.poll();\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        s.dispose();\n                        q.clear();\n                        a.onError(ex);\n                        worker.dispose();\n                        return;\n                    }\n                    boolean empty = v == null;\n\n                    if (checkTerminated(d, empty, a)) {\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    a.onNext(v);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n```\n\n这里大概就是通过一个死循环，不断从 onSubscribe 方法中创建的队列中取出事件，执行observer 的 onNext方法。而当为例为空时，就会执行worker.dispose 取消整个事件流，同时从Handler中移除所有消息。\n\n最后在看一眼 onComplete ,onError 和整个类似\n\n```java\n        @Override\n        public void onComplete() {\n            if (done) {\n                return;\n            }\n            done = true;\n            schedule();\n        }\n```\n可以看到这里的处理也很简单，done 设置为 true .这样最后便完成了下游事件的执行。\n\n## 最后\n\n好了，由于一些无以诉说的原因，经历了很久终于把 RxJava 线程切换的下篇给完成了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["RxJava2"],"categories":["Android 进阶"]},{"title":"2018-Book&Movie List","url":"%2F2018%2F03%2F01%2F2018-Book%26Movie%20List%2F","content":"\n## Book\n\n- [x] 大数据时代[维克托.迈尔]\n- [x] 半小时漫画世界史[二混子]\n- [x] 我长得丑，你们都得让着我[唐梓严]\n- [x] 枪炮细菌与钢铁\n- [x] 三体 [刘慈欣]\n- [x] 爵迹 [郭敬明]\n- [x] 时间简史 （霍金）\n- [x] 人间失格 \n\n\n- [x] Java 8 实战\n- [x] Android Gradle 实战\n- [x] Clean Code\n\n## Movie\n\n- [x] 三块广告牌\n- [x] 西游记-女儿国\n- [x] 复仇者联盟3\n- [x] 红海行动\n- [x] 宫崎骏-起风了\n- [x] 至暗时刻\n- [x] 魔女宅急便\n- [x] 老男孩（美版）\n- [x] 黑豹\n- [x] 瞒天过海：美人计\n- [x] 无问西东\n- [x] 红高粱\n- [x] 蚁人2\n- [x] 詹妮弗的肉体\n- [x] 爵迹\n- [x] 我不是药神\n- [x] 一出好戏\n- [x] 边境杀手2\n- [x] 蜘蛛侠：平行宇宙\n- [x] 闪光少女\n- [x] 名侦探柯南剧场版- 零的执行人\n- [x] 无双\n\n## Tv\n\n- [x] 白夜追凶\n- [x] 足球小将 100 集\n- [x] 生活大爆炸 season-11\n- [x] 摩登家庭 season-01\n- [x] 中国好声音 2018\n- [x] 铁齿铜牙纪晓岚 第一部 + 第二部\n\n","tags":["诗与远方"]},{"title":"RxJava2 是如何实现线程切换的 (上)","url":"%2F2018%2F01%2F23%2FRxJava2%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%EF%BC%88%E4%B8%8A%EF%BC%89%2F","content":"\n\n## 前言\n\n\n\n通过前一篇的[从观察者模式出发，聊聊RxJava](https://juejin.im/post/5a521d68f265da3e4e25750e),我们大致理解了RxJava的实现原理，在RxJava中可以非常方便的实现不同线程间的切换。subscribeOn 用于指定上游线程，observeOn 用于指定下游线程，多次用 subscribeOn 指定上游线程只有第一次有效，多次用 observeOn 指定下次线程，每次都有效；简直太方便了，比直接使用Handler省了不少力气，同时也不用去关注内存泄漏的问题了。本篇就来看看在RxJava中上游是如何实现线程切换。\n\n\n<!--more-->\n\n## RxJava 基础原理\n\n为了方便后面的叙述，这里通过下面的UML图简单回顾一下上一篇的内容。\n\n\n![](https://user-gold-cdn.xitu.io/2018/1/23/161239920cc6b9d9?w=910&h=525&f=png&s=42043)\n\n*此图并没有完整的展现图中各个接口和类之间的各种关系，因为那样会导致整个图错综复杂，不便于查看，这里只绘制出了RxJava各个类之间核心关系网络*\n\n\n\n从上面的UML图中可以看出，具体的实现类只有ObservableCreate和CreateEmitter。CreateEmitter是ObservableCreate的内部类（PlantUML 怎么绘制内部类，没搞懂，玩的转的同学请赐教呀(*^▽^*)）。\n\n上篇说过Observable创建的过程，可以简化如下：\n\n```java\n  Observable mObservable=new ObservableCreate(new ObservableOnSubscribe())\n```\n结合图可以更直观的体现出这一点。ObservableCreate 内部持有ObservableOnSubscribe的引用。\n\n当观察者订阅主题后：\n\n```java\nmObservable.subscribe(mObserver);\n```\nObservableCreate 中的subscribeActual()方法就会执行，\n\n\n```java\n    protected void subscribeActual(Observer<? super T> observer) {\n        CreateEmitter<T> parent = new CreateEmitter<T>(observer);\n        observer.onSubscribe(parent);\n\n        try {\n            source.subscribe(parent);\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            parent.onError(ex);\n        }\n    }\n\n```\n\n在这个过程中会创建CreateEmitter 的实例，而这个CreateEmitter实现了Emitter和Disposable接口，同时又持有Observer的引用（当然这个引用是ObservableCreate传递给他的）。**接着就会执行ObservableOnSubscribe的subscribe 方法**，方法的参数即为刚刚创建的CreateEmitter 的实例，接着一系列连锁反应，Emitter 接口中的方法（onNext,onComplete等）开始执行，在CreateEmitter内部，Observer接口中对应的方法依次执行，这样就实现了一次从主题（上游）到观察者（下游）的事件传递。\n\n\n**source.subscribe(parent)** \n\n这里的 source 是ObservableOnSubscribe的实例，parent是CreateEmitter的实例。上面加粗文本叙述的内容，就是这行代码，可以说这是整个订阅过程最核心的实现。\n\n好了，回顾完基础知识后，马上进入正题，看看RxJava是如何实现线程切换的。\n\n\n\n\n\n## RxJava 之 subscribeOn\n我们知道正常情况下，所有的内容都是在主线程执行，既然这里提到了线程切换，那么必然是切换到了子线程，因此，这里需要关注线程的问题，我们就带着下面这几个问题去阅读代码。\n\n- 1.**是哪个对象在什么时候创建了子线程，是一种怎样的方式创建的？**\n- 2.**子线程又是如何启动的？**\n- 3.**上游事件是怎么跑到子线程里执行的？**\n- 4.**多次用 subscribeOn 指定上游线程为什么只有第一次有效 ?**\n\n\n### 示例 \n\n首先看一下，日常开发中实现线程切换的具体实现\n\n```java\n\n    private void multiThread() {\n        Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"This msg from work thread :\" + Thread.currentThread().getName());\n                sb.append(\"\\nsubscribe: currentThreadName==\" + Thread.currentThread().getName());\n            }\n        })\n                .subscribeOn(Schedulers.newThread())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Consumer<String>() {\n                    @Override\n                    public void accept(String s) throws Exception {\n                        Log.e(TAG, \"accept: s= \" + s);\n                    }\n                });\n    }\n\n```\n这段代码，使用过RxJava的同学再熟悉不过了，上游事件会在一个名为 RxNewThreadScheduler-1 的线程执行，下游线程会切换回我们熟悉的Android UI线程。\n\n我们就从subscribeOn(Schedulers.newThread()) 出发，看看这个代码的背后，到底发生了什么。\n\n![](https://user-gold-cdn.xitu.io/2018/1/23/161239e8d8af610b?w=1280&h=610&f=png&s=218709)\n### subscribeOn\n\n这里我们先不管Schedulers.newThread() 是什么鬼，首先看看这个subscribeOn()方法。\n\n\n**Observable.java---  subscribeOn(Scheduler scheduler)**\n\n```java\n    public final Observable<T> subscribeOn(Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaPlugins.onAssembly(new ObservableSubscribeOn<T>(this, scheduler));\n    }\n```\n\n可以看到，这个方法需要一个Scheduler 类型的参数。\n\n**RxJavaPlugins.java--- onAssembly(@NonNull Observable<T> source)**\n\n```java\n    public static <T> Observable<T> onAssembly(@NonNull Observable<T> source) {\n        Function<? super Observable, ? extends Observable> f = onObservableAssembly;\n        if (f != null) {\n            return apply(f, source);\n        }\n        return source;\n    }\n```\n\nO(∩_∩)O哈哈~，是不是觉得似曾相识，和create操作符一个套路呀。因此，observeOn也可以简化如下：\n\n```java\nnew ObservableSubscribeOn<T>(this, Schedulers.newThread());\n```\n这里你也许会有疑问，这个this是什么呢？其实这个this就是Observable，具体到上面的代码来说就是ObservableCreate，总之就是一个具体的Observable。\n\n接着看ObservableSubscribeOn 这个类\n\n```java\npublic final class ObservableSubscribeOn<T> extends AbstractObservableWithUpstream<T, T> {\n}\n\n```\n\n看一下 **AbstractObservableWithUpstream.java**\n\n```java\n\nabstract class AbstractObservableWithUpstream<T, U> extends Observable<U> implements HasUpstreamObservableSource<T> {\n\n    /** The source consumable Observable. */\n    protected final ObservableSource<T> source;\n\n    AbstractObservableWithUpstream(ObservableSource<T> source) {\n        this.source = source;\n    }\n\n    @Override\n    public final ObservableSource<T> source() {\n        return source;\n    }\n\n}\n```\n\n再看一下 **HasUpstreamObservableSource.java**\n\n```java\n/**\n * Interface indicating the implementor has an upstream ObservableSource-like source available\n * via {@link #source()} method.\n *\n * @param <T> the value type\n */\npublic interface HasUpstreamObservableSource<T> {\n    /**\n     * Returns the upstream source of this Observable.\n     * <p>Allows discovering the chain of observables.\n     * @return the source ObservableSource\n     */\n    ObservableSource<T> source();\n}\n```\n\n饶了半天，ObservableSubscribeOn 原来和上一篇说的ObservableCreate一样，也是Observable的一个子类。只不过比ObservableCreate多实现了一个接口HasUpstreamObservableSource，这个接口很有意思，他的source()方法返回类型是ObservableSource（还记得这个类的角色吗？）。也就是说ObservableSubscribeOn这个Observable是一个拥有上游的Observable。他有一个非常关键的方法source()，这个方法的返回值就是ObservableSource，也就是说通过调用实现source方法，可以获取到上游的Observeable。**AbstractObservableWithUpstream类继承HasUpstreamObservableSource 并实现了这个source方法，返回结果为ObservableSource，是通过其构造函数获取。**，那么AbstractObservableWithUpstream的构造函数又是在哪里调用的呢？\n\n我们接着看ObservableSubscribeOn的具体实现。\n\n```java\npublic final class ObservableSubscribeOn<T> extends AbstractObservableWithUpstream<T, T> {\n    final Scheduler scheduler;\n\n    public ObservableSubscribeOn(ObservableSource<T> source, Scheduler scheduler) {\n        super(source);\n        this.scheduler = scheduler;\n    }\n\n    @Override\n    public void subscribeActual(final Observer<? super T> s) {\n        final SubscribeOnObserver<T> parent = new SubscribeOnObserver<T>(s);\n\t\t// observer 调用onSubscribe方法，获取上游的控制权\n        s.onSubscribe(parent);\n\n        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));\n    }\n}\n```\n\n- 首先看他的构造函数，参数source就是我们之前提到过的this，scheduler就是Schedulers.newThread()。同时调用了父类AbstractObservableWithUpstream的构造函数，这里结合之前的结论，我们可以确定通过这个构造函数，就创建出来了一个包含上游的ObservableSubscribeOn实例。\n- 再看实现订阅关系的关键方法subscribeActual()，在这里创建了一个SubscribeOnObserver的实例，SubscribeOnObserver 是AtomicReference的子类(保证原子性)，同时实现了 Observer接口 和 Disposable 接口；你可以把他理解成一个Observer。\n\n我们之前说过，subscribeActual()是实现上下游之间订阅关系的重要方法。因为只有真正实现了订阅关系，上下游之间才能连接起来。我们看这个方法的最后一句代码。\n\n```java\n parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));\n```\n这句代码，可以说就是非常关键，因为从这里开始了一系列的连锁反应。首先看一下SubscribeTask\n\n\n```java\n    final class SubscribeTask implements Runnable {\n        private final SubscribeOnObserver<T> parent;\n\n        SubscribeTask(SubscribeOnObserver<T> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void run() {\n            source.subscribe(parent);\n        }\n    }\n```\n\n看到这句 **source.subscribe(parent)**，是不是觉得似曾相识呢？\n\n\nSubscribeTask 实现了是Runnable接口，在其run方法中，定义了一个需要在线程中执行的任务。按照类的继承关系，很明显source 就是ObservableSubscribeOn 的上游Observable，parent是一个Observer。也就是说这个run方法要执行的内容就是实现ObservableSubscribeOn的上游和Observer的订阅。**一旦某个线程执行了这个Runnable（SubscribeTask），就会触发了这个run方法，从而实现订阅**，而一旦这个订阅实现，那么后面的流程就是上节所说的事情了。\n\n**这里可以解答第三个问题了，上游事件是怎么给弄到子线程里去的，这里很明显了，就是直接把订阅方法放在了一个Runnable中去执行，这样就一旦这个Runnable在某个子线程执行，那么上游所有事件只能在这个子线程中执行了。**\n \n好了，线程要执行的任务**似乎**创建完了，下面就接着找看看子线程是怎么创建的。回过头继续看刚才的方法，\n\n```java\nscheduler.scheduleDirect(new SubscribeTask(parent))\n```\n\n**Scheduler.java----scheduleDirect**\n\n```java\n\n    public Disposable scheduleDirect(@NonNull Runnable run) {\n        return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);\n    }\n\n\n    public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {\n        final Worker w = createWorker();\n\t\t// 对run进行了一次装饰\n        final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\n\n        DisposeTask task = new DisposeTask(decoratedRun, w);\n\n        w.schedule(task, delay, unit);\n\n        return task;\n    }\n\n\t@NonNull\n\t// 抽象方法\n    public abstract Worker createWorker();\n```\n\n首先看一下Worker类\n\n```java\n    /**\n     * Sequential Scheduler for executing actions on a single thread or event loop.\n     * <p>\n     * Disposing the {@link Worker} cancels all outstanding work and allows resource cleanup.\n     */\n    public abstract static class Worker implements Disposable {\n  \n        @NonNull\n        public Disposable schedule(@NonNull Runnable run) {\n            return schedule(run, 0L, TimeUnit.NANOSECONDS);\n        }\n\n  \n        @NonNull\n        public abstract Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit);\n\n        \n    }\n\n```\n\nWorker是Scheduler内部的一个静态抽象类，实现了Disposable接口，其schedule()方法也是抽象的。\n\n\n再看一下DisposeTask \n\n\n```java\nstatic final class DisposeTask implements Runnable, Disposable {\n        final Runnable decoratedRun;\n        final Worker w;\n\n        Thread runner;\n\n        DisposeTask(Runnable decoratedRun, Worker w) {\n            this.decoratedRun = decoratedRun;\n            this.w = w;\n        }\n\n        @Override\n        public void run() {\n            runner = Thread.currentThread();\n            try {\n                decoratedRun.run();\n            } finally {\n                dispose();\n                runner = null;\n            }\n        }\n\n        @Override\n        public void dispose() {\n            if (runner == Thread.currentThread() && w instanceof NewThreadWorker) {\n                ((NewThreadWorker)w).shutdown();\n            } else {\n                w.dispose();\n            }\n        }\n\n        @Override\n        public boolean isDisposed() {\n            return w.isDisposed();\n        }\n    }\n\n```\nDisposeTask 又是一个Runnable，同时也实现了Disposable接口。可以看到在他的run方法中会执行decoratedRun的run方法，这个decoratedRun其实就是参数中传递进来的run，**也就是说，执行了这个DisposeTask的run方法，就会触发SubscribeTask中的run方法**，因此，我们就要关注是谁执行了这个DisposeTask。\n\n\n\n回到scheduleDirect()方法\n\n\n```java\n    public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {\n        final Worker w = createWorker();\n\t\t// 对run进行了一次装饰\n        final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\n\n        DisposeTask task = new DisposeTask(decoratedRun, w);\n\n        w.schedule(task, delay, unit);\n\n        return task;\n    }\n```\n\n\nscheduleDirect()方法的实现我们总结一下：\n\n1. 创建一个Worker对象w,而在Scheduler类中createWorker()方法被定义为抽象方法，因此我们需要去Scheduler的具体实现中了解这个Worker的具体实现。\n2. 对参数run通过RxJavaPlugins进行一次装饰，生成一个decoratedRun的Runnable（通过源码可以发现，其实什么也没干，就是原样返回）\n3. 通过decoratedRun和w生成一个DisposeTask对象task\n4. **通过Worker的schedule方法开始执行这个task。**\n\n\nε=(´ο｀*)))唉，说了这么久，子线程是如何创建的依然不清楚，无论是SubscribeTask还是DisposeTask只是定义会在某个子线程中执行的任务，并不代表子线程已被创建。但是通过以上代码，我们也可以收获一些有价值的结论：\n\n- 最终的Runnable任务，将由某个具体的Worker对象的scheduler()方法执行。\n- 这个scheduleDirect会返回一个Disposable对象，这样我们就可以通过Observer去控制整个上游的执行了。\n\n好了，到这里对于subscribeOn()方法的分析已经到了尽头，我们找了最终需要运行子任务的对象Worker,而这个Worker是个抽象类，因此我们需要关注Worker的具体实现了。\n\n下面我们就从刚才丢下的Schedulers.newThread() 换个角度来分析，看看能不能找到这个Worker的具体实现。\n\n\n## Schedulers.newThread()\n\n前面说了subscribeOn()方法需要一个Scheduler 类型的参数，然而通过前面的分析我们知道Scheduler是个抽象类，是无法被实例化的。因此，这里就从Schedulers类出发。\n\n\n```java\n/**\n * Static factory methods for returning standard Scheduler instances.\n */\npublic final class Schedulers {\n}\n```\n\n注释很清楚，这个Schedulers就是一个用于生成Scheduler实例的静态工厂。\n\n下面我们就来看看，在这个工厂中newThread() 生成了一个什么样的Scheduler实例。\n\n```java\n    @NonNull\n    public static Scheduler newThread() {\n        return RxJavaPlugins.onNewThreadScheduler(NEW_THREAD);\n    }\n\n\tNEW_THREAD = RxJavaPlugins.initNewThreadScheduler(new NewThreadTask());\n\n    static final class NewThreadTask implements Callable<Scheduler> {\n        @Override\n        public Scheduler call() throws Exception {\n            return NewThreadHolder.DEFAULT;\n        }\n    }\n\n    static final class NewThreadHolder {\n        static final Scheduler DEFAULT = new NewThreadScheduler();\n    }\n```\n\nnewThread() 方法经过层层委托处理(最终的创建方式，有点单例模式的意味)，最终我们需要的就是一个NewThreadScheduler的实例。\n\n**NewThreadScheduler.java**\n\n```java\npublic final class NewThreadScheduler extends Scheduler {\n\n    final ThreadFactory threadFactory;\n\n    private static final String THREAD_NAME_PREFIX = \"RxNewThreadScheduler\";\n    private static final RxThreadFactory THREAD_FACTORY;\n\n    /** The name of the system property for setting the thread priority for this Scheduler. */\n    private static final String KEY_NEWTHREAD_PRIORITY = \"rx2.newthread-priority\";\n\n    static {\n        int priority = Math.max(Thread.MIN_PRIORITY, Math.min(Thread.MAX_PRIORITY,\n                Integer.getInteger(KEY_NEWTHREAD_PRIORITY, Thread.NORM_PRIORITY)));\n\n        THREAD_FACTORY = new RxThreadFactory(THREAD_NAME_PREFIX, priority);\n    }\n\n    public NewThreadScheduler() {\n        this(THREAD_FACTORY);\n    }\n\n    public NewThreadScheduler(ThreadFactory threadFactory) {\n        this.threadFactory = threadFactory;\n    }\n\n    @NonNull\n    @Override\n    public Worker createWorker() {\n        return new NewThreadWorker(threadFactory);\n    }\n}\n```\n不出所料NewThreadScheduler 是Scheduler的一个子类，在他的静态代码块中构造了一个Priority=5的线程工厂。而在我们最最关注的**createWorker()方法中他又用这个线程工厂创建了一个NewThreadWorker 的实例**。下面就让我们看看最终的NewThreadWorker 做了些什么工作。\n\n**NewThreadWorker.java**(节选关键内容)\n\n```java\n\npublic class NewThreadWorker extends Scheduler.Worker implements Disposable {\n    private final ScheduledExecutorService executor;\n\n    volatile boolean disposed;\n\n    public NewThreadWorker(ThreadFactory threadFactory) {\n        executor = SchedulerPoolFactory.create(threadFactory);\n    }\n\n    @NonNull\n    @Override\n    public Disposable schedule(@NonNull final Runnable run) {\n        return schedule(run, 0, null);\n    }\n\n    \n\n    @Override\n    public void dispose() {\n        if (!disposed) {\n            disposed = true;\n            executor.shutdownNow();\n        }\n    }\n\n}\n```\n\n众里寻他千百度，终于找到了Worker的实现了，同时再一次不出所料的又一次实现了Disposable接口，o(╥﹏╥)o。\n\n\n在其构造函数中，通过NewThreadScheduler中提供的线程工厂threadFactory创建了一个ScheduledExecutorService。\n\n\n**ScheduledExecutorService.java ---create**\n\n```java\n\n    public static ScheduledExecutorService create(ThreadFactory factory) {\n        final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory);\n        if (PURGE_ENABLED && exec instanceof ScheduledThreadPoolExecutor) {\n            ScheduledThreadPoolExecutor e = (ScheduledThreadPoolExecutor) exec;\n            POOLS.put(e, exec);\n        }\n        return exec;\n    }\n```\n\n用大名鼎鼎的Executors(Executor的工具类)，创建了一个核心线程为1的线程。 \n\n**至此，我们终于找到了第一个问题的答案，子线程是谁如何创建的；在NewThreadScheduler的createWorker()方法中，通过其构建好的线程工厂，在Worker实现类的构造函数中创建了一个ScheduledExecutorService的实例，是通过SchedulerPoolFactory创建的。**\n\n同时可以看到，通过执行dispose 方法，可以使用ScheduledExecutorService的shutdown()方法，停止线程的执行。\n\n线程已经创建好了，下面就来看看到底是谁启动了这个线程。前面我们说过，Worker的schedule()方法如果执行了，就会执行我们定义好的Runnable，通过这个Runnable中run方法的执行，就可以实现上下游订阅关系。下面就来看看这个scheduler()方法。\n\n```java\n@NonNull\n    @Override\n    public Disposable schedule(@NonNull final Runnable action, long delayTime, @NonNull TimeUnit unit) {\n        if (disposed) {\n            return EmptyDisposable.INSTANCE;\n        }\n        return scheduleActual(action, delayTime, unit, null);\n    }\n\n    @NonNull\n    public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) {\n        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\n\n        ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent);\n\n        if (parent != null) {\n            if (!parent.add(sr)) {\n                return sr;\n            }\n        }\n\n        Future<?> f;\n        try {\n            if (delayTime <= 0) {\n                f = executor.submit((Callable<Object>)sr);\n            } else {\n                f = executor.schedule((Callable<Object>)sr, delayTime, unit);\n            }\n            sr.setFuture(f);\n        } catch (RejectedExecutionException ex) {\n            if (parent != null) {\n                parent.remove(sr);\n            }\n            RxJavaPlugins.onError(ex);\n        }\n\n        return sr;\n    }\n```\n\n到这里，已经很明显了，在schedulerActual方法中，会通过刚才创建好的子线程对象executor通过submit或schedule执行一个Runnable任务（虽然这个Runnable对象再一次经过了各种装饰和包装，但其本质没有发生变化），并将执行结果封装后返回。而这个Runnable对象追根溯源来说，就是我们在ObservableSubscribeOn类中创建的一个SubscribeTask对象。因此，当这个子线程开始运行的时候就是执行SubscribeTask中run()方法的时机；一旦这个run方法执行，那么\n\n```java\nsource.subscribe(parent)\n```\n这句最关键的代码就开始执行了，一切的一切又回到了我们上一篇那熟悉的流程了。\n\n好了，按照上面的流程捋下来，感觉还是有点分散，那么就用UML图看看整体的结构。\n\n\n![](https://user-gold-cdn.xitu.io/2018/1/23/16123a868c390ac1?w=1127&h=525&f=png&s=51911)\n\n\n\n我们看最下面的ObservableSubscribeOn，**他是subscribeOn 返回的Observable对象，他持有一个Scheduler 实例的引用，而这个Scheduler实例就是NewThreadScheduler(即Schedulers.newThreade())的一个实例。ObservableSubscribeOn 的subscribeActual方法，会触发NewThreadScheduler去执行SubscribeTask中定义的任务，而这个具体的任务又将由Worker类创建的子线程去执行。这样就把上游事件放到了一个子线程中实现。**\n\n\n至于最后一个问题，**多次用 subscribeOn 指定上游线程为什么只有第一次有效?**，看完通篇其实也很好理解了，因为上游Observable只有一个任务，就是subscribe(准确的来说是subscribeActual()），而subscribeOn 要做的事情就是把上游任务切换到一个指定线程里，那么一旦被切换到了某个指定的线程里，后面的切换不就是没有意义了吗。\n\n好了，至此上游事件切换到子线程的过程我们就明白了。下游事件又是如何切换的且听下回分解，本来想一篇写完的，结果发现越写越多，只能分成两篇了！！！o(╯□╰)o。\n\n\n## 写在后面的话\n\n\n####  关于Disposable\n\n在RxJava的分析中，我们经常会遇到Disposable这个单词，确切的说是接口，这里简单说一说这个接口。\n\n```java\n/**\n * Represents a disposable resource.\n */\npublic interface Disposable {\n    void dispose();\n    boolean isDisposed();\n}\n```\n\n我们知道，在Java中，类实现某个接口，通俗来说就是代表这个类多了一项功能，比如一个类实现Serializable接口，代表这个类是可以序列化的。这里Disposable也是代表一种能力，这个能力就是Disposable，就是代表一次性的，用后就丢弃的，比如一次性筷子，还有那啥。\n\n在RxJava中很多类都实现了这个接口，这个接口有两个方法，isDisposed()顾名思义返回当前类是否被抛弃，dispose()就是主动抛弃。因此，所有实现了这个接口的类，都拥有了这样一种能力，就是可以判断自己是否被抛弃，同时也可以主动抛弃自己。\n\n上一篇我们说了，Observer通过onSubscribe(@NonNull Disposable d)，会获得一个Disposable，这样就有能力控制上游的事件发送了。这样，我们就不难理解，为什么那么多类实现了这个接口，因为下游获取到的是一个拥有Disposable的对象，而一旦拥有了一个这样的对象，那么就可以通过下游控制上游了。可以说，这是RxJava对常规的观察者模式所做的最给力的改变。\n\n\n#### 关于各种ObservableXXX ,subscribeXXX,ObserverXXX \n\n在查看RxJava的源码时，可能很多人都和我一样，有一个巨大的困扰，就是这些类的名字好他妈难记，感觉长得都差不多，关键念起来好像也差不多。但其实本质上来说，RxJava对类的命名还是非常规范的，只是我们不太习惯而已。按照英文单词翻译：\n\n- Observable 可观察的（主题 ，上游）\n- Observer   观察者 （订阅者，下游）\n- Subscribe  订阅\n\n其实就这么三个主语，其他的什么ObservableCreate，ObservableSubscribeOn，AbstractObservableWithUpstream，还有上面提到的Disposable，都是对各种各样的Observable和Observer的变形和修饰结果，只要理解这个类的核心含义是什么，就不会被这些名字搞晕了。\n\n\nRxJava 可以说是博大精深，以上所有分析完全是个人平时使用时的总结与感悟，有任何错误之处，还望各位读者提出，共同进步。\n\n关于RxJava 这里墙裂推荐一篇文章[一篇不太一样的RxJava介绍](https://juejin.im/post/5a2549576fb9a04519696d45)，感觉是自扔物线那篇之后，对RxJava思想感悟最深的一篇了。对RxJava 有兴趣的同学，可以多度几遍，每次都会有收获！！\n\n***\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["RxJava2"],"categories":["Android 进阶"]},{"title":"从观察者模式出发，聊聊RxJava2","url":"%2F2018%2F01%2F12%2F%E4%BB%8E%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%87%BA%E5%8F%91%EF%BC%8C%E8%81%8A%E8%81%8ARxJava%2F","content":"\n\n## 前言\n\n### RxJava 是什么\n\n>RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.\n\n以上是RxJava在[Github](https://github.com/ReactiveX/RxJava)上的介绍，大概意思是，**针对于JVM(Java虚拟机）的响应式扩展实现，一个在Java VM上使用可观察的序列来组合实现异步的、基于事件编程的库。**\n\n<!--more-->\n\nRxJava现在大家用的都应该已经很溜了，用法这里就不再多说了。我们都知道RxJava是对**观察者模式**的扩展，下面就从观察者模式的实现机制出发，了解一下RxJava2的实现逻辑。只有真正了解了RxJava 的实现原理，我们才能在遇到问题的时候，更快速更准确的定位的到问题。\n\n> 此次源码分析基于 [RxJava Release 2.1.7](https://github.com/ReactiveX/RxJava/releases/tag/v2.1.7)\n\n\n### 观察者模式\n\n这里简单回顾一下观察者模式的组成及使用方式，通过之前[观察者模式](https://www.jianshu.com/p/6fcce09cc1ce)一文中的分析，我们知道观察者模式中有四个重要的角色：\n\n- 抽象主题：**定义添加和删除观察者的功能，也就是注册和解除注册的功能**\n- 抽象观察者：**定义观察者收到主题通知后要做什么事情**\n- 具体主题：**抽象主题的实现**\n- 具体观察者：**抽象观察者的实现**\n\n当我们创建好了具体主题和观察者类，就可以使用观察者模式了，下面是一个最简单的测试demo。\n\n```java\npublic class TestObservePattern {\n\n    public static void main(String[] args) {\n\t\t// 创建主题(被观察者)\n        ConcreteSubject concreteSubject = new ConcreteSubject();\n\t\t// 创建观察者\n        ObserverOne observerOne=new ObserverOne();\n        // 为主题添加观察者\n        concreteSubject.addObserver(observerOne);        \n        //主题通知所有的观察者\n        concreteSubject.notifyAllObserver(\"wake up,wake up\");\n    }\n\n}\n```\n\n以上就是观察者模式的使用方式，很简单是吧。现在就让我们带着以下几个问题，看看RxJava是如何使用观察者模式的。\n\n用RxJava这么久了，你可以思考一下如下几个问题：\n\n1. RxJava 中上面提到的四个重要角色是如何定义的？\n2. RxJava 中具体的主题，具体的观察者是如何实例化的？\n3. RxJava 中观察者和主题是如何实现订阅的？\n4. RxJava 中上游是怎么发送事件的，下游又是怎样接收到的?\n5. RxJava 中对常规的观察者模式做了怎样调整，带来了什么好处？\n\n*如果对以上几个问题，你有明确的答案，恭喜你，以下内容你就不用再看了，O(∩_∩)O哈哈~。*\n\n>很多开发者对RxJava的学习可能是从**上游**和**下游**的角度开始，这里可以认为这样的叙述更偏重RxJava 事件序列的特征。本文从**被观察者（主题）**和**观察者**的角度出发，可以说是更偏向于RxJava 观察者模式的特征。这里的主题就是上游，观察者就是下游。无论从哪个角度出发去理解，源码就那么一份，无所谓对错，只是每个人的认知角度不同而已，选择一种自己更容易了解的方式即可。\n\n好了，如果你看到了这里，说明你对以上几个问题，还有些许疑问，那么我们就从这几个问题出发，了解一下RxJava的源码实现。\n\n## RxJava2 的观察者模式实现\n\n我们就带着上述几个问题，依次来看看RxJava到底是怎么一回事儿。为了方便叙述和记忆，我们首先看一段RxJava2 最最基础的使用方式。\n\n\n```java\nprivate void basicRxjava2() {\n        Observable mObservable = Observable.create(new ObservableOnSubscribe() {\n            @Override\n            public void subscribe(ObservableEmitter e) throws Exception {\n                e.onNext(\"1\");\n                e.onNext(\"2\");\n                e.onNext(\"3\");\n                e.onNext(\"4\");\n                e.onComplete();\n            }\n        });\n\n        Observer mObserver = new Observer() {\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.e(TAG, \"onSubscribe: d=\" + d);\n                sb.append(\"\\nonSubcribe: d=\" + d);\n            }\n\n            @Override\n            public void onNext(Object s) {\n                Log.e(TAG, \"onNext: \" + s);\n                sb.append(\"\\nonNext: \" + s);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                Log.e(TAG, \"onError: \" + e);\n                sb.append(\"\\nonError: \" + e.toString());\n                logContent.setText(sb.toString());\n            }\n\n            @Override\n            public void onComplete() {\n                Log.e(TAG, \"onComplete\");\n                sb.append(\"\\nonComplete: \");\n                logContent.setText(sb.toString());\n            }\n        };\n\n        mObservable.subscribe(mObserver);\n    }\n```\n\n上面这段代码，应该很容易理解了，输出结果大家闭着眼睛也能想出来吧。我们就以这段代码为基础，结合上面提到的问题依次展开对RxJava的分析。\n\n#### 四个重要的角色\n\n首先看看RxJava 中四个重要的角色是如何定义的。\n\n- 抽象主题\n\n首先可以看看这个Observable类。\n\n```java\npublic abstract class Observable<T> implements ObservableSource<T> {\n……\n}\n```\n他实现了ObservableSource接口，接着看ObservableSource\n\n```java\npublic interface ObservableSource<T> {\n\n    /**\n     * Subscribes the given Observer to this ObservableSource instance.\n     * @param observer the Observer, not null\n     * @throws NullPointerException if {@code observer} is null\n     */\n    void subscribe(@NonNull Observer<? super T> observer);\n}\n```\n\n这里很明显了，ObservableSource 就是抽象主题（被观察者）的角色。按照之前观察者模式中约定的职责，subscribe 方法就是用来实现订阅观察者（Observer）角色的功能。从这里我们也可以看出，抽象观察者的角色就是Observer了。\n\n这里，你也许会有疑问，这么简单？抽象主题（上游）不是需要发送事件吗？onNext(),onComplete()以及onError()跑哪儿去了？别着急，我们后面慢慢看。\n\n- 具体主题\n\n回过头来继续看Observable，他实现了ObservableSource接口，并且实现了其subscribe方法，但是它并没有真正的去完成**主题**和**观察者**之间的订阅关系，而是把这个功能，转接给了另一个抽象方法subscribeActual（具体细节后面分析）。\n\n因此，Observable依旧是一个抽象类，我们知道**抽象类是不能被实例化的**，因此从理论上来说，他好像不能作为具体主题的角色。其实不然，Observable内部提供了create,defer,fromXXX,repeat,just等一系列**创建型操作符**， 用来创建各种Observable。\n```java\n    public static <T> Observable<T> create(ObservableOnSubscribe<T> source) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        return RxJavaPlugins.onAssembly(new ObservableCreate<T>(source));\n    }\n```\n\n\n在RxJava内有很多他的子类。\n\n\n![Observable子类](https://user-gold-cdn.xitu.io/2018/1/7/160d0dafe04868f6?w=669&h=509&f=png&s=53479)\n\n诚然，你可以认为，这些子类其实才是真正的具体主题。但是，换一个角度，从[代理模式](https://juejin.im/post/5a4e4725f265da3e2c37e36e)的角度出发，我们可以把Observable当做是一个代理类，客户端你只管调用create 方法，想要什么样的\nObservable告诉我一声就可以，不同Observable之间的差异你不用管，包在我身上，保证给你返回你想要的Observable实例。\n\n同时，Observable另一个巨大的贡献，就是定义了很多的操作符，我们平时常用的map,flatMap,distinct等，也是在这里定义。并且这些方法都是final类型的，因此他的所有子类都会继承同时也无法改变这些操作符的实现。\n\n因此，Observable 就是具体主题。\n\n- 抽象观察者\n\n在抽象主题里已经提过了，Observer就是抽象观察者的角色。\n\n```java\npublic interface Observer<T> {\n\n    void onSubscribe(@NonNull Disposable d);\n\n    void onNext(@NonNull T t);\n\n    void onError(@NonNull Throwable e);\n\n    void onComplete();\n\n}\n\n```\n\n非常符合观察者模式中抽象观察者的职责描述，Observer 定义了观察者（下游）收到主题（上游）通知后该做什么事情。这里需要注意的是onSubscribe 也是定义在这里的。\n\n\n- 具体的观察者\n\n这个具体的观察者，o(╯□╰)oo(╯□╰)o，就不多说了吧。大家平时使用应该都是直接用new一个Observer的实例。RxJava内部有很多Observer的子类，有兴趣的同学可以具体了解一下。这里其实可以引申出一个有意思的问题，同样是抽象类，为什么接口可以直接实例化，而用abstract修饰过的类就不可以？\n\n#### 具体的观察者是如何实例化的\n\n我们看一下这段代码：\n\n```java\n    Observable mObservable = Observable.create(new ObservableOnSubscribe() {\n            @Override\n            public void subscribe(ObservableEmitter e) throws Exception {\n            }\n        });\n\n    public static <T> Observable<T> create(ObservableOnSubscribe<T> source) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        return RxJavaPlugins.onAssembly(new ObservableCreate<T>(source));\n    }\n\t\n\t\n    public static <T> Observable<T> onAssembly(@NonNull Observable<T> source) {\n        Function<? super Observable, ? extends Observable> f = onObservableAssembly;\n\t\t// 是否有别的其他操作符运算，有的话，在此Observable上执行一遍\n        if (f != null) {\n            return apply(f, source);\n        }\n        return source;\n    }\n\n```\n\n**RxJava的代码里，很多时候会有ObjectHelper.requireNonNull这种空检查的地方，一律都是为了最大程度的防止NPE的出现，后面出现就不再赘述了**.\n\n我们使用create操作符创建Observable的过程中，看似经历了很多方法，**在不考虑任何其他操作符的前提下**，整个过程简化一下的话就这么一句代码\n\n```java\n  Observable mObservable=new ObservableCreate(new ObservableOnSubscribe())\n```\n从之前的分析，我们也看到了ObservableCreate 就是Observeable抽象类的一个子类。我们简单看一下他的实现。\n\n```java\npublic final class ObservableCreate<T> extends Observable<T> {\n    final ObservableOnSubscribe<T> source;\n\n    public ObservableCreate(ObservableOnSubscribe<T> source) {\n        this.source = source;\n    }\n\n    @Override\n    protected void subscribeActual(Observer<? super T> observer) {\n        ……\n    }\n}\n\n```\n\n可以看到，他唯一的构造函数需要一个ObservableOnSubscribe实例，同时他实现subscribeActual方法，说明他真正处理**主题**和**观察者**之间实现订阅的逻辑。\n\n看了半天，你可能一直很好奇，这个ObservableOnSubscribe是个什么东西呢？他其实很简单。\n\n```java\n/**\n * A functional interface that has a {@code subscribe()} method that receives\n * an instance of an {@link ObservableEmitter} instance that allows pushing\n * events in a cancellation-safe manner.\n *\n * @param <T> the value type pushed\n */\npublic interface ObservableOnSubscribe<T> {\n\n    /**\n     * Called for each Observer that subscribes.\n     * @param e the safe emitter instance, never null\n     * @throws Exception on error\n     */\n    void subscribe(@NonNull ObservableEmitter<T> e) throws Exception;\n}\n```\n\nε=(´ο｀*)))唉，怎么又一个subscribe，这又是啥？不要慌，看注释。意思是说，这里的subscribe 接收到一个ObservableEmitter实例后，就会允许他以一种可以安全取消（也就是一定能取消）的形式发送事件。\n\n**就是说会有某个对象，给他一个ObservableEmitte的实例，没给他之前他是不会主动发送事件的，会一直憋着。**，到这里，你是不是想到了什么，我们知道在RxJava 中只有观察者（下游）订阅(subscribe)了主题（上游），主题才会发送事件。这就是和普通的观察者模式有区别的地方之一。\n\n好了，最后再来看看这个神秘的ObservableEmitter是个什么鬼？\n\n```java\npublic interface ObservableEmitter<T> extends Emitter<T> {\n\n    void setDisposable(@Nullable Disposable d);\n\n\n    void setCancellable(@Nullable Cancellable c);\n\n\n    boolean isDisposed();\n\n    ObservableEmitter<T> serialize();\n\n      /**\n     * Attempts to emit the specified {@code Throwable} error if the downstream\n     * hasn't cancelled the sequence or is otherwise terminated, returning false\n     * if the emission is not allowed to happen due to lifecycle restrictions.\n     * <p>\n     * Unlike {@link #onError(Throwable)}, the {@code RxJavaPlugins.onError} is not called\n     * if the error could not be delivered.\n     * @param t the throwable error to signal if possible\n     * @return true if successful, false if the downstream is not able to accept further\n     * events\n     * @since 2.1.1 - experimental\n     */\n    boolean tryOnError(@NonNull Throwable t);\n}\n```\n\n**这里可以关注一下tryOnError这个方法，可以看到他会把某些类型的error传递到下游。**\n\no(╥﹏╥)o，又是一个接口，而且还继承了另一个接口，什么情况？继续看\n\n```java\npublic interface Emitter<T> {\n\n    void onNext(@NonNull T value);\n\n  \n    void onError(@NonNull Throwable error);\n\n   \n    void onComplete();\n}\n```\n\n惊不惊喜，意不意外？ 哈哈，终于找到你了，熟悉的onNext，onError,onComplete.原来在这里。\n\n**这里有个问题可以思考一下，在抽象观察者中，定义了四个处理事件的方法，这里只有三个，按照对应关系来说似乎缺了一个onSubscribe，这又是怎么回事呢？后面会有分析，可以自己先想想**\n\n这两个接口的含义很明显了，总结一下：\n\n- Emitter 定义了可以发送的事件的三种机制\n- ObservableEmitter 在Emitter 做了扩展，添加了Disposable相关的方法，可以用来取消事件的发送。\n\n好了，绕了一大圈，就为了一行代码：\n\n\n```java\n  Observable mObservable=new ObservableCreate(new ObservableOnSubscribe())\n```\n\n总结一下具体主题（上游）的到底干了啥：\n\n- 创建了一个ObservableCreate 的实例对象\n- ObservableCreate 内持有ObservableOnSubscribe 对象的引用\n- ObservableOnSubscribe 是一个接口，内部有一个subscribe方法，调用他之后，会用其ObservableEmitter实例开始发送事件。\n- ObservableEmitter 继承自Emitte。\n\n#### 如何实现订阅、发送事件和接收事件\n\n为了方便叙述，把问题3和4连在一起说了。\n\n通过上面的叙述，现在具体主题和具体的观察者都创建好了，接下来就是实现二者的订阅关系。\n\n```\nmObservable.subscribe(mObserver);\n```\n\n>这里需要明确的一点是，是观察者（下游）订阅了主题（上游），虽然从代码上看好像了前者订阅了后者，不要搞混了。\n\n我们看Observable的subscribe() 方法：\n\n```java\n    public final void subscribe(Observer<? super T> observer) {\n        ObjectHelper.requireNonNull(observer, \"observer is null\");\n        try {\n            observer = RxJavaPlugins.onSubscribe(this, observer);\n\n            ObjectHelper.requireNonNull(observer, \"Plugin returned null Observer\");\n\n            subscribeActual(observer);\n        } catch (NullPointerException e) { // NOPMD\n            throw e;\n        } catch (Throwable e) {\n         ……\n        }\n    }\n```\n\n这个前面已经提到过了，Observable并没有真正的去实现subscribe,而是把他转接给了subscribeActual()方法。\n\n\n前面已经说过，Observable的实例是一个ObservableCreate对象，那么我们就到这个类里去看看subscribeActual()的实现。\n\n```java\n\t// 为了方便，顺便再看一眼构造函数\n    public ObservableCreate(ObservableOnSubscribe<T> source) {\n        this.source = source;\n    }\n    @Override\n    protected void subscribeActual(Observer<? super T> observer) {\n        CreateEmitter<T> parent = new CreateEmitter<T>(observer);\n        observer.onSubscribe(parent);\n\n        try {\n            source.subscribe(parent);\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            parent.onError(ex);\n        }\n    }\n```\n\nCreateEmitter 实现了之前提到的ObservableEmitter接口。这里有一句关键的代码：\n\n```java\nobserver.onSubscribe(parent);\n```\n\n之前在看到Emitter的定义时，我们说缺少了onSubscribe方法，到这里就明白了。**onSubscribe并不是由主题（上游）主动发送的事件，而是有观察者（下游）自己调用的一个事件，只是为了方便获取Emitter的实例对象，准确的说应该是Disposable的实例对象，这样下游就可以控制上游了。**\n\n接下来就更简单了，source 是ObservableOnSubscribe，按照之前的逻辑，调用其subscribe方法，给他一个ObservableEmitter对象实例，ObservableEmitter就会开始发送事件序列。这样，一旦开始订阅了，主题（上游）就开始发送事件了。也就是我们熟悉的onNext,onComplete,onError 方法真正的开始执行了。\n\n接着看看CreateEmitter的实现。\n\n```java\n\npublic final class ObservableCreate<T> extends Observable<T> {\n    final ObservableOnSubscribe<T> source;\n\n    public ObservableCreate(ObservableOnSubscribe<T> source) {\n        this.source = source;\n    }\n\n    @Override\n    protected void subscribeActual(Observer<? super T> observer) {\n        CreateEmitter<T> parent = new CreateEmitter<T>(observer);\n        observer.onSubscribe(parent);\n        ……\n    }\n\n    static final class CreateEmitter<T>\n    extends AtomicReference<Disposable>\n    implements ObservableEmitter<T>, Disposable {\n\n\n        private static final long serialVersionUID = -3434801548987643227L;\n\n        final Observer<? super T> observer;\n\n        CreateEmitter(Observer<? super T> observer) {\n            this.observer = observer;\n        }\n\n        @Override\n        public void onNext(T t) {\n            if (t == null) {\n                onError(new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"));\n                return;\n            }\n            if (!isDisposed()) {\n                observer.onNext(t);\n            }\n        }\n\n        @Override\n        public void onError(Throwable t) {\n            if (!tryOnError(t)) {\n                RxJavaPlugins.onError(t);\n            }\n        }\n\n        @Override\n        public boolean tryOnError(Throwable t) {\n            if (t == null) {\n                t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\");\n            }\n            if (!isDisposed()) {\n                try {\n                    observer.onError(t);\n                } finally {\n                    dispose();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void onComplete() {\n            if (!isDisposed()) {\n                try {\n                    observer.onComplete();\n                } finally {\n                    dispose();\n                }\n            }\n        }\n\n        @Override\n        public void setDisposable(Disposable d) {\n            DisposableHelper.set(this, d);\n        }\n\n        @Override\n        public void setCancellable(Cancellable c) {\n            setDisposable(new CancellableDisposable(c));\n        }\n\n        @Override\n        public ObservableEmitter<T> serialize() {\n            return new SerializedEmitter<T>(this);\n        }\n\n        @Override\n        public void dispose() {\n            DisposableHelper.dispose(this);\n        }\n\n        @Override\n        public boolean isDisposed() {\n            return DisposableHelper.isDisposed(get());\n        }\n    }\n}\n```\n\n- 他的构造函数，需要一个观察者的实例；\n- 他实现了ObservableEmitter接口，并依次实现他的三个方法；\n  - 在每一次的onNext事件中，他不再接受参数为null的类型，在事件序列没有中断的情况下会把主题（上游）发送的事件T原封不动的传递给观察者(下游）。\n  - onComplete事件发生时，他也会通知下游，如果发生异常，则中断事件序列\n  - onError 事件发生时，并没有直接传递到下游，而是在其内部处理\n  - tryOnError 事件发生时，才会把某些特定类型的错误传递到下游。\n- 他实现了Disposable接口，下游根据获取到的Emitter的实例对象，可以方便的获取事件序列的信息，甚至是可以主动关闭事件序列，及断开观察者模式中主题和观察者间的订阅关系。\n\n\n## RxJava 中对常规的观察者模式做了怎样调整，带来了什么好处？\n\n最后再来简单说一下，RxJava中对常规的观察者模式做了怎样的调整，有什么值得借鉴的地方。大部分优点在上面已经提及了，这里就来总结一下。\n\n- 观察者订阅主题后，主题才会开始发送事件\n- RxJava中Observer通过onSubscribe获取了发送事件中的Disposable对象，这样他就可以主动的获取订阅关系中二者的状态，甚至是控制或者是中断事件序列的发送。在常规的观察者模式中，主题有权利添加订阅者，但也能是由他移除特定的订阅者，因为只有他持有所有订阅者的集合\n- 抽象主题（上游）并没有直接控制onNext，onComplete,onError事件的发送，而是只关注Emitter 实例的发送，ObservableOnSubscribe接口监听ObservableEmitter对象的发送，一旦接受到此对象就会通过他开始发送具体的事件，这里可以有点观察者模式嵌套的意味。\n\n\n****\n\n好了，以上就是从观察者模式的角度出发，对RxJava的一次解读，有什么疏漏或理解错误的地方，欢迎读者指出，共同进步！\n\n","tags":["RxJava2"],"categories":["Android 进阶"]},{"title":"代理模式","url":"%2F2018%2F01%2F07%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F","content":"\n## 介绍\n\n代理模式也称为委托模式，是一种**结构性**设计模式。\n\n说到代理，可能大部分人都会有一种陌生又熟悉的感觉，日常生活中好像都能遇到，比如代理上网，招商代理，商务代理等；但又说不出个具体的一二三来；代理这个事情如果我们换个角度，从委托者的角色出发，我们找代理上网，是因为我们在访问某些网站时存在困难，需要有个角色来间接的帮我们实现这个功能；我们找商务代理，可能是因为许多事我们不在行或者其他原因，需要找专业的中间人来帮我们做事。因为，日常生活中我们更多扮演的是委托人的角色，代理以一种中间人的角色，帮我们是处理我们无能为力的事情。\n\n<!--more-->\n\n因此，从写代码的角度出发，当我们遇到以下场景：\n\n- 无法直接访问某个对象\n- 不想直接访问某个对象\n- 访问某个对象存在困难\n\n这个时候，我们就可以通过一个代理，通过它来间接访问真正的对象。\n\n\n\n## 定义及UML图\n\n### 定义： \n\n**为目标对象提供一种代理，客户端通过代理去访问目标对象。**\n\n\n### UML 图\n\n\n\n![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1514862791977&di=a2474587175e0bb92b0178421e86d125&imgtype=jpg&src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D3669500640%2C1002167682%26fm%3D214%26gp%3D0.jpg)\n\n\n从代理模式的UML 类图中，我们可以得到如下结论：\n\n- 代理对象和委托对象需要实现相同的接口（抽象类）\n- 代理对象持有委托对象的引用\n\n可以看到，代理模式非常简洁，总共就三个角色，包括**抽象主题，委托者和代理者。**下面用代码简单实现一下基础的代理模式。\n\n```java\npublic interface Subject {\n    void doSomething();\n}\n\npublic class RealSubject implements Subject {\n    @Override\n    public void doSomething() {\n        System.out.println(\"This is real doSomeThing\");\n    }\n}\n\npublic class ProxySubject implements Subject {\n\n    private Subject mSubject;\n    // 代理类持有委托类的引用\n    public ProxySubject(Subject realSubject) {\n        mSubject = realSubject;\n    }\n\n    @Override\n    public void doSomething() {\n        mSubject.doSomething();\n    }\n}\n\npublic class Client {\n    public static void main(String[] args) {\n        //创建委托类\n        Subject mRealSubject=new RealSubject();\n        //创建代理类\n        ProxySubject mProxy = new ProxySubject(mRealSubject);\n        //由代理类去做具体的操作\n        mProxy.doSomething();\n    }\n}\n\n```\n\n可以看到RealSubject和ProxySubject都实现了接口Subject。在客户端使用ProxySubject的实例调用doSomething方法，而不是使用RealSubject的实例来实现。\n\n你可能会好奇，这么做的意义是什么呢？直接用RealSubject的实例来调用doSomething方法不也可以吗？何必多此一举。试想，如果现在有很多个委托类，他们各自的实现都不同，客户端只关心doSomething 的调用，而不关心具体的实现，这样代理类就可以在其内部屏蔽委托类之间的差异了。这么说可能有点晕，下面就通过Android源码中的实现来感受一下。\n\n## Android 中的代理模式\n\n\n平时写代码的时候，可能感觉代理模式没怎么遇到过。其实不然，甚至可以说代理模式是我们最常用到的一种设计模式。这里就来看看几乎天天都在使用的AppCompatActivity。\n\n最早的时候，我们创建自己的Activity都是直接继承android.app.Activity。后来随着Android版本的升级，我们创建的Activity会继承AppCompatActivity。这里的Compat其实就是Compatible(兼容)的缩写，那么他是怎么实现兼容的呢。\n\n#### onCreate\n\nonCreate()方法是整个Activity生命周期的开始。AppCompatActivity又是怎么实现他的呢。\n\n**AppCompatActivity-onCreate()**\n\n```java\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        final AppCompatDelegate delegate = getDelegate();\n        delegate.installViewFactory();\n        delegate.onCreate(savedInstanceState);\n\t\t……\n    }\n```\n\n可以看到这里他并没具体去实现onCreate,而是使用一个AppCompatDelegate实例的onCreate()方法去实现。继续看getDelegate 的实现。\n\n\n**AppCompatActivity-getDelegate()**\n\n```java\n    @NonNull\n    public AppCompatDelegate getDelegate() {\n        if (mDelegate == null) {\n            mDelegate = AppCompatDelegate.create(this, this);\n        }\n        return mDelegate;\n    }\n```\n\n可以看到这个实例创建是在AppCompatDelegate类中。接着看create的实现\n\n\n**AppCompatDelegate-create()**\n\n```java\n    public static AppCompatDelegate create(Activity activity, AppCompatCallback callback) {\n        return create(activity, activity.getWindow(), callback);\n    }\n\n    private static AppCompatDelegate create(Context context, Window window,\n            AppCompatCallback callback) {\n        if (Build.VERSION.SDK_INT >= 24) {\n            return new AppCompatDelegateImplN(context, window, callback);\n        } else if (Build.VERSION.SDK_INT >= 23) {\n            return new AppCompatDelegateImplV23(context, window, callback);\n        } else if (Build.VERSION.SDK_INT >= 14) {\n            return new AppCompatDelegateImplV14(context, window, callback);\n        } else if (Build.VERSION.SDK_INT >= 11) {\n            return new AppCompatDelegateImplV11(context, window, callback);\n        } else {\n            return new AppCompatDelegateImplV9(context, window, callback);\n        }\n    }\n```\n\n可以看到，这里就不同的Android版本，分别返回了不同的AppCompatDelegate。如果去看源码（这里的源码分析不是重点，就不贴出了，直接给出结论），我们会发现，从\nAppCompatDelegateImplN到AppCompatDelegateImplV9，是子类到父类的关系，之间是依次继承。而AppCompatDelegateImplV9又继承自AppCompatDelegateImplBase（抽象类），而这个AppCompatDelegateImplBase则是继承自AppCompatDelegate。\n\n到这里，结合一开始我们所说的代理模式的内容，我们很容易总结出以下结论：\n\n- AppCompatDelegate 同时兼顾了**抽象主题和代理类**的角色\n- AppCompatDelegateImplN，AppCompatDelegateImplV23等这些都是**委托类**，他们都继承自AppCompatDelegate方法。\n\n通过[AppCompatDelegate.java](https://www.androidos.net.cn/android/8.0.0_r4/xref/frameworks/support/v7/appcompat/src/android/support/v7/app/AppCompatDelegate.java)(点击可直接查看)的源码，我们可以发现，这个抽象类内部定义了一系列和 Activity 相关的抽象方法，包括Activity生命周期函数，setContentView，setSupportActionBar等。我们知道，**子类通过继承父类，可以扩展（spuer)或直接覆盖父类的方法实现。** AppCompatDelegateImplV9 这个类是AppCompatDelegate的具体实现，之后的版本，就可以通过继承AppCompatDelegateImplV9来扩展或修改一些方法实现，通过AppCompatDelegate 在create方法中创建不同的委托类来完成不同的实现，而我们原先写好的代码也不会被破坏，可以看到Android源码对Activity兼容这个事做的非常巧妙。AppCompatDelegate主要是对ActionBar的兼容及夜间模式的处理做了一些方便开发者实现的处理；这里就不再具体分析了。\n\n当然，代理模式这个几乎找不到缺点的设计模式，在Android源码中的应用也是比较广泛，基本上关于兼容性的实现，都会用到以上思路，比如NotificationCompatImpl几乎使用了和AppCompatDelegate同样的思路，实现了在手机通知栏中实现不同的通知样式。除了兼容性的处理，另外一个比较经典的实现就是Binder了，作为跨进程通信的核心理念，Binder巧妙的使用了代理模式，处理了我们无法在不同应用之间共享和传递数据的问题。关于Binder的分析，网上真的太多了，这里就不再赘述了，有兴趣的同学可以看看这篇[代理模式在Binder中的使用](http://blog.csdn.net/singwhatiwanna/article/details/44590179).\n\n## 动态代理\n\n以上的分析中，委托类是由我们直接创建好的；现实中可能还有这样一种场景，委托类并不是在程序编译的时候创建，而是在运行的过程中通过Java的反射机制动态的进行创建，这样的代理模式成为动态代理，对应的之前我们所说的就是静态代理了。\n\n其实，动态代理的实现没有什么可说的，说白了都是模板代码，Java为开发者提供了InvocationHandler,实现该接口重写其invoke 方法即可。\n\n还是以之前的Subject为例\n\n```java\npublic interface Subject {\n    void doSomething();\n}\n\npublic class RealSubject implements Subject {\n    @Override\n    public void doSomething() {\n        System.out.println(\"This is real doSomeThing\");\n    }\n}\n\n\npublic class DynamicProxyHandler implements InvocationHandler {\n    private Object mObject;\n\n\n    public DynamicProxyHandler(Object object) {\n        mObject = object;\n    }\n\n    @Override\n    public Object invoke(Object o, Method method, Object[] objects) throws Throwable {\n        return method.invoke(mObject, objects);\n    }\n}\n\n\npublic class MainClass {\n    public static void main(String[] args) {\n        // 委托类\n        Subject mRealSubject = new RealSubject();\n        // 委托类classLoader\n        ClassLoader mClassLoader = mRealSubject.getClass().getClassLoader();\n        // 委托类对应的ProxyHandler\n        DynamicProxyHandler mProxyHandler = new DynamicProxyHandler(mRealSubject);\n        Class[] mClasses = new Class[]{Subject.class};\n        // 代理类\n        Subject proxySubject = (Subject) Proxy.newProxyInstance(mClassLoader, mClasses, mProxyHandler);\n        // 代理类调用方法\n        proxySubject.doSomething();\n        \n    }\n}\n\n```\n\n这里可以看到，DynamicProxyHandler内部持有的并不是一个具体的对象，而是Object类，而在其invoke方法中，又会根据具体的Object对象及参数调用其对应的方法。这样当我们在客户端调用时，完全是根据委托类通过Proxy.newProxyInstance方法动态的创建代理类。在上面的代码中，我们是通过委托类RealSubject动态的创建了一个代理类，通过代理类调用抽象主题中定义好的方法，实际上就会调用委托类中的具体实现。而在Java中，我们可以通过反射机制，动态的创建类及其实例，因此，我们便可以在运行时通过不同的委托类，更灵活的创建代理类，从而实现不同的功能。\n\n关于动态代理，这篇[十分钟理解Java之动态代理](https://www.jianshu.com/p/cbd58642fc08)分析的非常好，有兴趣的同学可以再看看。\n\n\n在Android中，关于动态代理的使用，最经典的莫过于这几年最火热的Retrofit了。这里可以简单看一下。\n\n```java\n\npublic interface GitHubService {\n  @GET(\"users/{user}/repos\")\n  Call<List<Repo>> listRepos(@Path(\"user\") String user);\n}\n\nGitHubService service = retrofit.create(GitHubService.class);\nCall<List<Repo>> repos = service.listRepos(\"octocat\");\n``` \n\n上面的实现，现在大家应该很熟悉了，当我们用Retrofit实例，调用其create方法时，到底发生了什么呢？\n\n```java\n  public <T> T create(final Class<T> service) {\n    Utils.validateServiceInterface(service);\n    if (validateEagerly) {\n      eagerlyValidateMethods(service);\n    }\n    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n        new InvocationHandler() {\n          private final Platform platform = Platform.get();\n\n          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)\n              throws Throwable {\n            // If the method is a method from Object then defer to normal invocation.\n            if (method.getDeclaringClass() == Object.class) {\n              return method.invoke(this, args);\n            }\n            if (platform.isDefaultMethod(method)) {\n              return platform.invokeDefaultMethod(method, service, proxy, args);\n            }\n            ServiceMethod<Object, Object> serviceMethod =\n                (ServiceMethod<Object, Object>) loadServiceMethod(method);\n            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);\n            return serviceMethod.callAdapter.adapt(okHttpCall);\n          }\n        });\n  }\n```\n\n可以看到，这里就是一个典型的动态代理实现，**通过serviceMethod.callAdapter.adapt返回了一个service对象的代理对象，在上面的例子里，就是返回了一个GitHubService的代理对象，这样我们就可以通过这样一个对象去调用GitHubService中定义好的各种网络请求，而不用在使用的时候再去决定是POST请求还是GET请求,参数是放在Body里还是params里，因为Retrofit 通过把反射注解和动态代理的巧妙结合，屏蔽了复杂的参数拼接操作，把所有我们需要对OKHttp的进行传递的参数，动态的帮我们传递了**，一旦在接口中定义好了使用方式，就可以非常方便的获取到okhttp中最关键的Call了，有了Call我们就可以通过execute或者是enqueue发起网络请求了。\n\n## 总结\n\n以上就是对代理模式的分析，总的来说代理模式的结构非常简单；包括**抽象主题，委托类，代理类**三个核心角色，从大的方向上可以分为静态代理和动态代理两大类；通过静态代理的方式，在开发迭代的过程中，为实现兼容性提供了一种非常友好的实现思路；在日常开发中，如果我们使用的对象之间有着强烈的耦合，可是思考一下是否可以通过代理模式解耦；同时，当我们需要扩展某个类的部分功能时，但又不想去破坏原有的功能或者是根本无法修改时，我们可以考虑代理模式，但也要明白，通过代理模式我们能做的也只能是功能扩展，想要更新委托类中已经实现的内容我们是无能为力的。\n\n\n动态代理，可以根据运行时的委托类动态的生成代理类，这样就减轻了代理类的负担，避免在编码阶段就具体的委托类再做各种判断了。\n\n代理模式很简单，也很实用，但不要忘记**代理类**和**委托类**需要实现功能的接口或抽象类，不要忽略了这一点。\n\n****\n\n\n\n\n\n\n\n\n\n\n\n","categories":["设计模式"]},{"title":"Android 插件化和热修复的前生今世","url":"%2F2017%2F11%2F28%2FAndroid%20%E6%8F%92%E4%BB%B6%E5%8C%96%E5%92%8C%E7%83%AD%E4%BF%AE%E5%A4%8D%E7%9A%84%E5%89%8D%E7%94%9F%E4%BB%8A%E4%B8%96%2F","content":"\n## 概述\n\n在Android开发中，插件化和热修复的话题越来越多的被大家提及，同时随着技术的迭代，各种框架的发展更新，插件化和热修复的框架似乎已经日趋成熟，许多开发者也把这两项技术运用到实际开发协作和正式的产品当中。因此，我们势必需要了解一下这两门技术。\n\n\n## 插件化和热修复\n\n首先需要明确的一点，**插件化和热修复**不是同一个概念，虽然站在技术实现的角度来说，他们都是从系统加载器的角度出发，无论是采用hook方式，亦或是代理方式或者是其他底层实现，都是通过“**欺骗**”Android 系统的方式来让**宿主**正常的加载和运行**插件（补丁）**中的内容；但是二者的出发点是不同的。**插件化**顾名思义，更多是想把需要实现的模块或功能当做一个独立的提取出来，减少**宿主**的规模，当需要使用到相应的功能时再去加载相应的模块。**热修复**则往往是从修复bug的角度出发，强调的是在不需要二次安装应用的前提下修复已知的bug。\n\n<!--more-->\n\n为了方便叙述，做以下称谓约定：\n> 宿主： 就是当前运行的APP\n> 插件： 相对于插件化技术来说，就是要加载运行的apk类文件\n> 补丁： 相对于热修复技术来说，就是要加载运行的*.patch,*.dex,*.apk等一系列包含dex修复内容的文件。\n\n以下提到内容中的宿主和插件（补丁），均是上述含义，不再赘述。\n\n\n![Android插件化技术的典型应用](http://s1.knowsky.com/20170206/e4as0errukk22.png)\n\n上图就是对Android插件化和热修复之间关系的体现。据我所知，在某些开发团队中，会把热修复的技术，作为在APP端部署日常活动的功能来用。虽然，实际效果来看是没有问题的，但长期使用还是值得商榷的。\n\n早期很多应用的动态换肤功能，就是参考了Android 插件化的技术，最早的新浪微博夜间模式就是通过下载一个夜间模式的apk文件完成，当时做为开发者的自己，感觉很高级。关于动态加载的应用，其实有很多可以扩展的思路，比如特定节日的促销活动，逃避审核机制的动态广告加载都是Android插件化技术可以考虑的实现，更多内容可以参考[**Android动态加载技术 简单易懂的介绍方式**](https://segmentfault.com/a/1190000004062866)\n\n\n\n\n下面就从插件化技术的发展源头，逐步叙述一下二者的发展历程及现状，了解一下时至今日，热修复框架的发展到了各种地步，总体梳理一下热修复的原理，对现有的框架有一个了解。\n\n\n## 插件化\n\n### 发展历程及现状\n\n关于插件化技术的起源可以追溯到5年前\n- 2012年的 [AndroidDynamicLoader](https://github.com/mmin18/AndroidDynamicLoader) ，他的原理是动态加载不同的Fragment实现UI替换，可以说是开山鼻祖了，但是这种方案可扩展性不强。\n- 再到后来出现了23Code,他可以直接下载一个自定义控件的demo，并且运行起来。\n- 2014年一个里程碑式的年份，任玉刚（俗称主席）发布了[dynamic-load-apk](https://github.com/singwhatiwanna/dynamic-load-apk),也叫做DL。在这个框架里提供了两个很重要的思路：\n  - 如何管理插件内Activity的生命周期： 使用 DLProxyActivity 采用静态代理的方式去调用插件中Activity的生命周期方法。\n  - 如何加载插件内的资源文件：通过反射调用AssetManager 中到的addAssetPath方法就可以将特定路径的资源加载到系统内存中使用。\n\n  以上两点，可以说是非常有意义的，尤其是第二点关于插件资源的记载，是后期出现的许多框架的参考思路。这个框架也有一些局限，不支持插件内Service、BroadcastReceiver等需要注册才能使用的组件，同时插件apk也需要按照其开发规范来实现，总体来说还是有一定的成本，但无论怎样都是一个很有价值的框架。（话说这个框架貌似已经不再维护了，最近一次关于代码的更新都是2年前了，o(╥﹏╥)o）。\n- 2015年 [DroidPlugin](https://github.com/DroidPluginTeam/DroidPlugin) \n**[DroidPlugin 是Andy Zhang在Android系统上实现了一种新的 插件机制 :它可以在无需安装、修改的情况下运行APK文件,此机制对改进大型APP的架构，实现多团队协作开发具有一定的好处。](https://github.com/DroidPluginTeam/DroidPlugin/blob/master/readme_cn.md)** 这段话是DroidPlugin在Github README 文档中的介绍。这款来自360的插件化框架.\n- 2015年 [DynamicAPK](https://github.com/CtripMobile/DynamicAPK) 这个就……，貌似因为License的原因已经完全不更新了。\n\n- 2017 [RePlugin](https://github.com/Qihoo360/RePlugin) 这是360 开源的插件化框架，按照他自己的说法，相较于其他框架，他对系统的hook只有一处，那就是ClassLoader，这样从理论来说，貌似会有更好的稳定性。\n\n- 2017年 [atlas](https://github.com/alibaba/atlas)这个是阿里今年刚刚开源的插件化开发框架，可以说是非常强大；具体原理参考[详解 Atlas 框架原理](https://www.xttblog.com/?p=1141)；还没有用过。\n\n- [Small](https://github.com/wequick/Small)  最后再说一下Small，个人感觉Small 所提供了一种比插件化更高层次的概念，组件化；把一个完整的APP看成是由许多可以复用模块组件组成（这个有点像React Native的开发理念）；开发起来像是搭积木的感觉。有兴趣的可以去[Small官网](http://code.wequick.net/Small/cn/home)了解一下。\n\n\n## 热修复\n\n相较于插件化，热修复技术的使用更加的频繁，因为这项技术切实关切到我们实际开发的产品，能够更快速更便捷的修复线上bug，才能带来更好的用户体验。因此下面就结合热修复的原理了解一下热修复的使用及发展现状。\n\n> 以下所有分析源自热修复相关文章，这里只是把结论整理了出来。具体分析就不再拾人牙慧了，对实现细节有兴趣的同学可以查看相应的链接。\n\n\n### 类加载原理\n\n说起热修复就不得不提类的加载机制，和常规的JVM类似，在Android中类的加载也是通过ClassLoader来完成，具体来说就是PathClassLoader 和 DexClassLoader 这两个Android专用的类加载器，这两个类的区别如下：\n\n- PathClassLoader：只能加载已经安装到Android系统中的apk文件（/data/app目录），是Android默认使用的类加载器。\n- DexClassLoader：可以加载任意目录下的dex/jar/apk/zip文件，也就是我们一开始提到的补丁。\n\n这两个类都是继承自BaseDexClassLoader，我们可以看一下BaseDexClassLoader的构造函数。\n\n```java\n    public BaseDexClassLoader(String dexPath, File optimizedDirectory,\n            String libraryPath, ClassLoader parent) {\n        super(parent);\n        this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);\n    }\n```\n这个构造函数只做了一件事，就是通过传递进来的相关参数，初始化了一个DexPathList对象。**DexPathList的构造函数，就是将参数中传递进来的程序文件（就是补丁文件）封装成Element对象，并将这些对象添加到一个Element的数组集合dexElements中去**。\n\n\n>ClassLoaer 的加载机制是一种特别聪明的方式，**双亲委托机制**，在这种机制下，一个Class只会被加载一次。\n\n\n对于ClassLoader加载机制及双亲委托机制的分析可以参考[Android解析ClassLoader（一）Java中的ClassLoader](http://liuwangshu.cn/application/classloader/1-java-classloader-.html)。\n\n\n这里需要明白的一点是对于一个ClassLoader（类加载器）来说，将一个具体的类（class）加载到内存中其实是由虚拟机完成的，对于开发者来说，我们关注的重点应该是**如何去找到这个需要加载的类**。\n\n假设我们现在要去查找一个名为name的class，那么DexClassLoader将通过以下步骤实现：\n\n- 在DexClassLoader的findClass 方法中通过一个DexPathList对象findClass()方法来获取class\n- 在DexPathList的findClass 方法中，对之前构造好dexElements数组集合进行遍历，一旦找到类名与name相同的类时，就直接返回这个class，找不到则返回null。\n\n总的来说，**通过DexClassLoader查找一个类，最终就是就是在一个数组中查找特定值的操作。**\n\n综合以上所有的观点，我们很容易想到一种非常简单粗暴的热修复方案。假设现在代码中的某一个类或者是某几个类有bug，那么我们可以在修复完bug之后，可以**将这些个类打包成一个补丁文件，然后通过这个补丁文件封装出一个Element对象，并且将这个Element对象插到原有dexElements数组的最前端**，这样当DexClassLoader去加载类时，优先会从我们插入的这个Element中找到相应的类，虽然那个有bug的类还存在于数组中后面的Element中，但由于双亲加载机制的特点，这个有bug的类已经没有机会被加载了，这样一个bug就在没有重新安装应用的情况下修复了。\n\n有了上面的思路，其实我们就可以自己动手去实现一个简单的热修复框架了。这里推荐一篇\n[热修复——深入浅出原理与实现](https://juejin.im/post/5a0ad2b551882531ba1077a2)，文中作者深入分析了热修复原理，并基于以上原理实现了一个基础的热修复框架，实现过程分析的非常细致深入，非常适合做为热修复入门原理的了解。\n\n### QQ 空间超级补丁方案\n\n看完上面的原理，是不是觉得热修复很简单，没什么可研究的呢？其实不然，Java是一门面向对象的语言，我们使用的类会有继承关系，会相互依赖引用。同时Android虚拟机和常规的JVM 不同，加载的并不是.class而是dex(准确的来说是经过优化的odex)，在这样一个过程中，势必会有一些新的问题值得我们去关注。这个问题就是的CLASS_ISPREVERIFIED，什么意思呢。\n\n>- 在apk安装的时候系统会将dex文件优化成odex文件，在优化的过程中会涉及一个预校验的过程\n>- 如果一个类的static方法，private方法，override方法以及构造函数中引用了其他类，而且这些类都属于同一个dex文件，此时该类就会被打上CLASS_ISPREVERIFIED \n>- 如果在运行时被打上CLASS_ISPREVERIFIED的类引用了其他dex的类，就会报错\n>- 正常的分包方案会保证相关类被打入同一个dex文件\n>- 想要使得patch可以被正常加载，就必须保证类不会被打上CLASS_ISPREVERIFIED标记。而要实现这个目的就必须要在分完包后的class中植入对其他dex文件中类的引用\n \n*以上内容摘自[Android热修复技术——QQ空间补丁方案解析(2) ](https://yq.aliyun.com/articles/70321?spm=5176.100239.blogcont70320.23.Bhmli6)*\n\n**要在已经编译完成后的类中植入对其他类的引用，就需要操作字节码，惯用的方案是插桩。常见的工具有javaassist，asm等**\n\nQQ 空间补丁方案就是使用javaassist 插桩的方式解决了CLASS_ISPREVERIFIED的难题。\n\n\n### Tinker \n\nQQ空间超级补丁，**“超级补丁”**很多情况下意味着补丁文件很大，而将这样一个大文件夹加载在内存中构建一个Element对象，插入到数组最前端是需要耗费时间的,无疑会印象应用启动的速度。因此Tinker 提出了另外一种思路。\n\n![](https://raw.githubusercontent.com/Tencent/tinker/master/assets/tinker.png)\n\n图片源自https://github.com/Tencent/tinker\n\nTinker的思路是这样的，通过修复好的class.dex 和原有的class.dex比较差生差量包补丁文件patch.dex，在手机上这个patch.dex又会和原有的class.dex 合并生成新的文件fix_class.dex，用这个新的fix_class.dex 整体替换原有的dexPathList的中的内容，可以说是从根本上把bug给干掉了。\n\nTinker 提供的思路可以说是非常新奇，也非常值得我们去学习。上图中过程看似简单，但其实具体实现起来还真的不简单。你有想过两个.dex 是如何比较得出差异化文件patch.dex 的吗？有兴趣的同学可以看看鸿翔的这篇分析[Android 热修复 Tinker 源码分析之DexDiff / DexPatch](http://blog.csdn.net/lmj623565791/article/details/60874334)\n\n当然，需要注意的是，patch.dex和原先的class.dex 合并的时候需要新的进程去完成，同时考虑的现在大多数应用的规模，multidex已经是很常见的事情了，因此多个dex 之间的合并策略及成功率，都是在使用Tinker时需要考虑的问题。\n\n关于Tinker 更多细节可以参考 [微信Android热补丁实践演进之路](https://github.com/WeMobileDev/article/blob/master/微信Android热补丁实践演进之路.md)\n\n\n**Tinker 提供的文档及example非常完善，对于有兴趣接入的开发者可以说是非常友好了，但总体来说接入过程还是有些复杂，对整个项目的侵入还是较强，Tinker是个人唯一使用过的热修复的框架，总体来说还是不错的，通过接入到实际应用中，对gradle也有了新的认识，对gradle有兴趣的同学，其实可以看看tinker的gradle接入方式**\n### HotFix\n\n以上提到的两种方式，虽然策略有所不同，但总的来说都是从上层ClassLoader的角度出发，由于ClassLoader的特点，如果想要新的补丁文件再次生效，无论你是插桩还是提前合并，都需要重新启动应用来加载新的DexPathList。这样就无法在用户神不知鬼不觉的情况下把bug修复了，HotFix在这方面就有绝对的优势了。\n\n>HotFix(即AndFix），是在AndFix 的基础之上提供了补丁安全服务及版本管理等相关内容，方便广大的开发人员使用。\n\nAndFix 提供了一种运行时在Native修改Filed指针的方式，实现方法的替换，达到即时生效无需重启，对应用无性能消耗的目的。\n\n![AndFix原理图](https://github.com/alibaba/AndFix/raw/master/images/principle.png)\n\n更多细可以参考[https://github.com/alibaba/AndFix](https://github.com/alibaba/AndFix)，Native层不怎么理解，就不强行装逼了o(╯□╰)o。\n\n由于他是Native层操作，因此如果我们在Java层中新增字段，或者是修改类的方法，他是无能为力的。同时由于Android在国内变成了安卓，各大手机厂商定制了自己的ROM，所以很多底层实现的差异，导致AndFix的兼容性并不是很好。\n\n\n### Sophix\n\n**阿里推出业界首个非侵入式热修复方案Sophix，颠覆移动端传统发版更新流程！**\n\n这是我第一次了解到Sophix时看到的文章标题[原文链接](http://mp.weixin.qq.com/s/5KjSPvUflbg0pVRIjtLiRA?spm=5176.100239.blogcont102404.14.ARzI6c);对于技术类的文章来说，敢于使用**颠覆**这两个字，要么是标题党；要么就是真的很有货。\n\nSophix 可以说是博采众长，前面提到的Tinker及AndFix 都在某一方面存在缺陷。因此Sophix 便取长补短，采用**全量替换**的思路，从一种更高的层次实现了热修复。这貌似也是事物发展的一贯规律，后来的新生事物总结前人的经验教训，吸收好的思想，变得更好。\n\n关于Sophix 的原理看了很多篇文章，感觉这篇[干货满满，Android热修复方案介绍](https://yq.aliyun.com/articles/231111?utm_content=m_34179)分析的不错，有兴趣的可以看一下。\n\n总的来说，Sophix应该是现有最成熟的热修复方案了。\n\n### 其他及总结\n\n当然就热修复的实现，各个大厂还有各自的实现，比如饿了吗的[Amigo](https://github.com/eleme/Amigo),美团的[Robust](https://github.com/Meituan-Dianping/Robust),实现及优缺点各有差异，但总的来说就是两大类\n\n- ClassLoader 加载方案\n- Native层替换方案\n\n或者是参考Android Studio Instant Run 的思路实现代码整体的增量更新。但这样势必会带来性能的影响。\n\n综上所述，其实对于热修复很难有一种十分完美的解决方案。在Android开发中，四大组件使用前需要在AndroidManifest中提前声明，而如果需要使用热修复的方式，无论是提前占坑亦或是动态修改，都会带来很强的侵入性（因此，Sophix是不支持四大组件修复的，这也是其非侵入性设计理念无法避免的事情了，不知道以后会不会有新的办法）。再者Android碎片化的问题，对热修复方案的适配也是一个考验。通过查看几大以开源在Github上的热修复方案，在issue中可以看到提到最多的问题还是兼容性。\n\n因此，面对实际的开发，选择使用或者说选择哪种方案，必须符合实际的应用的场景，一句话，没有最好的，只有合适的。\n\n\n******\n\n好了，插件化和热修复知识就梳理到这里了。\n\n## 相关内容\n\n[Android动态加载技术 简单易懂的介绍方式](https://segmentfault.com/a/1190000004062866)\n[Android 插件化的 过去 现在 未来](https://www.kymjs.com/code/2016/05/04/01/)\n[ZeusPlugin: 掌阅APP插件补丁](http://www.jianshu.com/p/b1e7b6326330)\n[Android插件化：从入门到放弃](http://www.infoq.com/cn/articles/android-plug-ins-from-entry-to-give-up)\n[Android 全面插件化 RePlugin 流程与源码解析](https://juejin.im/post/59752eb1f265da6c3f70eed9)\n[《全面插件化——RePlugin的使命》](https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651113434&amp;idx=1&amp;sn=99a473c6fad2f7b366b2cba2afb96f7a&amp;chksm=844c6e07b33be7112222c0d78be23979912f12d6c99ad2c7bfac766e67e4be4619709f170b09&amp;mpshare=1&amp;scene=1&amp;)\n[详解 Atlas 框架原理](https://www.xttblog.com/?p=1141)\n[热修复——深入浅出原理与实现](https://juejin.im/post/5a0ad2b551882531ba1077a2)\n[Android解析ClassLoader（一）Java中的ClassLoader](http://liuwangshu.cn/application/classloader/1-java-classloader-.html)\n[Android热修复技术——QQ空间补丁方案解析(2) ](https://yq.aliyun.com/articles/70321?spm=5176.100239.blogcont70320.23.Bhmli6)\n[Android热修复技术——QQ空间补丁方案解析(3)](https://yq.aliyun.com/articles/70337?spm=5176.100239.blogcont70321.18.sDlCFI)\n[微信Android热补丁实践演进之路](https://github.com/WeMobileDev/article/blob/master/微信Android热补丁实践演进之路.md)\n[Android热修复技术总结 ](https://yq.aliyun.com/articles/184258?spm=5176.100239.blogcont70337.29.WSmFxM)\n[干货满满，Android热修复方案介绍](https://yq.aliyun.com/articles/231111?utm_content=m_34179)\n","tags":["热修复"],"categories":["Android 进阶"]},{"title":"自定义View高仿懂球帝我是教练效果","url":"%2F2017%2F07%2F23%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E9%AB%98%E4%BB%BF%E6%87%82%E7%90%83%E5%B8%9D%E6%88%91%E6%98%AF%E6%95%99%E7%BB%83%E6%95%88%E6%9E%9C%2F","content":"\n## 前言\n\n这几天很多欧洲球队来中国进行热身赛，不知道喜欢足球的各位小伙伴们有没有看球。喜欢足球的朋友可能知道懂球帝APP，鄙人也经常使用这个应用，里面有一个我是教练的功能挺好玩,就是可以模拟教练员的身份，排兵布阵；本着好奇心简单模仿了一下，在这里和大家分享。\n\n\n## 效果图\n\n老规矩，先上效果图看看模仿的像不。\n\n\n![add_player](https://user-gold-cdn.xitu.io/2017/7/23/68d1796a8b77eaee289378a8686b508f)\n\n\n![move_player](https://user-gold-cdn.xitu.io/2017/7/23/bd8a6abef46a6e25d06a447ec5e68c87)\n\n玩过我是教练这个功能的小伙伴可以对比一下。\n\n总的来说，这样的一个效果，其实很简单，就是一个view随着手指在屏幕上移动的效果，外加一个图片替换的动画。但就是这些看似简单的效果，在实现的过程中也是遇到了很多坑，涨了许多新姿势。好了，废话不说，代码走起(｡◕ˇ∀ˇ◕)。\n\n<!--more-->\n\n## 自定义View-BallGameView\n\n整个内容中最核心的就是一个自定义View-BallGameView，就是屏幕中绿色背景，有气泡和球员图片的整个view。\n\n*说到自定义View，老生常谈，大家一直都在学习，却永远都觉得自己没有学会，但是自定义View的知识本来就很多呀，想要熟练掌握，必须假以时日*。\n\n\n既然是自定View就从大家最关心的两个方法 onMeasure和onDraw 两个方法说起。这里由于是纯粹继承自View，就不考虑onLayout的实现了。\n\n#### 测量-onMeasure\n\n```java\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int viewW = screenW;\n        int viewH = (int) (screenW * 1.3);\n        setMeasuredDimension(viewW, viewH);\n    }\n```\n\n这里onMeasure()方法的实现很简单，简单的用屏幕的宽度规定了整个View 的宽高；至于1.3这个倍数，完全一个估算值，不必深究。\n\n#### 绘制-onDraw\n\nonDraw()方法是整个View中最核心的方法。\n\n```java\n@Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        //绘制背景\n        canvas.drawBitmap(backgroundBitmap, bitmapRect, mViewRect, mPaint);\n        //绘制提示文字透明背景\n        canvas.drawRoundRect(mRoundRect, 8, 8, mRectPaint);\n        //绘制底部提示文字 ( TextPiant 文字垂直居中实现 http://blog.csdn.net/hursing/article/details/18703599)\n        Paint.FontMetricsInt fontMetrics = mTipPaint.getFontMetricsInt();\n        float baseY=(mRoundRect.bottom+mRoundRect.top)/2-(fontMetrics.top+fontMetrics.bottom)/2;\n        canvas.drawText(tips, screenW / 2, baseY, mTipPaint);\n\n\n        //绘制初始的11个气泡\n        for (int i = 0; i < players.length; i++) {\n            //绘制当前选中的球员\n            if (i == currentPos) {\n\n                if (players[i].isSetReal()) {\n                    //绘制球员头像\n                    canvas.drawBitmap(players[i].getBitmap(), positions[i].x - playW / 2,\n                            positions[i].y - playW / 2, mPaint);\n                    //绘制选中球员金色底座\n                    canvas.drawBitmap(playSelectedBitmap, positions[i].x - goldW / 2,\n                            positions[i].y - goldH / 2, mPaint);\n\n                    //绘制球员姓名\n                    canvas.drawText(players[i].getName(), positions[i].x,\n                            positions[i].y + playW, mTextPaint);\n\n                } else {\n                    canvas.drawBitmap(selectedBitmap, positions[i].x - playW / 2,\n                            positions[i].y - playW / 2, mPaint);\n                }\n\n\n            } else {\n                canvas.drawBitmap(players[i].getBitmap(), positions[i].x - playW / 2,\n                        positions[i].y - playW / 2, mPaint);\n                if (players[i].isSetReal()) {\n\n                    //绘制球员姓名\n                    canvas.drawText(players[i].getName(), positions[i].x,\n                            positions[i].y + playW, mTextPaint);\n                    //绘制已设置正常图片球员背景\n                    canvas.drawBitmap(playeBgBitmap, positions[i].x - grayW / 2,\n                            positions[i].y + 200, mPaint);\n                }\n            }\n        }\n    }\n```\n\n可以看到，在onDraw方法里，我们主要使用了canvas.drawBitmap 方法，绘制了很多图片。下面就简单了解一下canvas.drawBitmap 里的两个重载方法。\n\n- drawBitmap(Bitmap bitmap,Rect src,Rect dst,Paint paint) \n\n```java\n/**\n     * Draw the specified bitmap, scaling/translating automatically to fill\n     * the destination rectangle. If the source rectangle is not null, it\n     * specifies the subset of the bitmap to draw.\n     *\n     *\n     * @param bitmap The bitmap to be drawn\n     * @param src    May be null. The subset of the bitmap to be drawn\n     * @param dst    The rectangle that the bitmap will be scaled/translated\n     *               to fit into\n     * @param paint  May be null. The paint used to draw the bitmap\n     */\n    public void drawBitmap(@NonNull Bitmap bitmap, @Nullable Rect src, @NonNull Rect dst,\n            @Nullable Paint paint) {\n       \n    }\n```\n\ndrawBitmap(Bitmap bitmap,Rect src,Rect dst,Paint paint),这个重载方法主要是通过两个Rectangle 决定了bitmap以怎样的形式绘制出来。**简单来说，src 这个长方形决定了“截取”bitmap的大小，dst 决定了最终绘制出来时Bitmap应该占有的大小。**。就拿上面的代码来说\n\n```java\n        backgroundBitmap = BitmapFactory.decodeResource(res, R.drawable.battle_bg);\n        //确保整张背景图，都能完整的显示出来\n        bitmapRect = new Rect(0, 0, backgroundBitmap.getWidth(), backgroundBitmap.getHeight());\n        //目标区域，在整个视图的大小中，绘制Bitmap\n        mViewRect = new Rect(0, 0, viewW, viewH);\n        //绘制背景\n        canvas.drawBitmap(backgroundBitmap, bitmapRect, mViewRect, mPaint);\n\n```\n\nbitmapRect 是整个backgroundBitmap的大小，mViewRect也就是我们在onMeasure里规定的整个视图的大小，这样相当于把battle_bg这张图片，以scaleType=\"fitXY\"的形式画在了视图大小的区域内。这样，你应该理解这个重载方法的含义了。\n\n- drawBitmap(Bitmap bitmap, float left, float top, Paint paint)\n\n```\n    /**\n     * Draw the specified bitmap, with its top/left corner at (x,y), using\n     * the specified paint, transformed by the current matrix.\n     *\n     *\n     * @param bitmap The bitmap to be drawn\n     * @param left   The position of the left side of the bitmap being drawn\n     * @param top    The position of the top side of the bitmap being drawn\n     * @param paint  The paint used to draw the bitmap (may be null)\n     */\n    public void drawBitmap(@NonNull Bitmap bitmap, float left, float top, @Nullable Paint paint) {\n\n    }\n```\n\n这个重载方法应该很容易理解了，left，top 规定了绘制Bitmap的左上角的坐标，然后按照其大小正常绘制即可。\n\n这里我们所有的气泡（球员位置）都是使用这个方法绘制的。足球场上有11个球员，因此我们通过数组预先定义了11个气泡的初始位置，然后通过其坐标位置，绘制他们。为了绘制精确，需要减去每张图片自身的宽高，这应该是很传统的做法了。\n\n\n同时，在之后的触摸反馈机制中，我们会根据手指的滑动，修改这些坐标值，这样就可以随意移动球员在场上的位置了；具体实现，结合代码中的注释应该很容易理解了，就不再赘述；可以查看完整源码[BallGameView](https://github.com/REBOOTERS/AndroidAnimationExercise/blob/dev/app/src/main/java/home/smart/fly/animations/customview/views/BallGameView.java)。\n\n\n##### 文字居中绘制\n\n这里再说一个在绘制过程中遇到一个小问题，可以看到在整个视图底部，绘制了一个半透明的圆角矩形，并在他上面绘制了一行黄色的文字，这行文字在水平和垂直方向都是居中的；使用TextPaint 绘制文字实现水平居中是很容易的事情，只需要设置mTipPaint.setTextAlign(Paint.Align.CENTER)即可，但是在垂直方向实现居中，就没那么简单了，这里需要考虑一个文本绘制时**基线**的问题，具体细节可以参考[这篇文章](http://blog.csdn.net/hursing/article/details/18703599)，分析的很详细。\n\n我们在这里为了使文字在圆角矩形中居中，如下实现。\n\n```\n        canvas.drawRoundRect(mRoundRect, 8, 8, mRectPaint);\n        Paint.FontMetricsInt fontMetrics = mTipPaint.getFontMetricsInt();\n        float baseY = (mRoundRect.bottom + mRoundRect.top) / 2 - (fontMetrics.top + fontMetrics.bottom) / 2;\n        canvas.drawText(tips, screenW / 2, baseY, mTipPaint);\n```\n\n圆角矩形的垂直中心点的基础上，再一次做修正，确保实现真正的垂直居中。\n\n\n\n好了，结合[扔物线](https://juejin.im/user/552f20a7e4b060d72a89d87f)大神所总结的自定义View关键步骤，以上两点算是完成了**绘制和布局**的工作,下面就看看**触摸反馈**的实现。\n\n\n\n#### 触摸反馈-onTouchEvent\n\n这里触摸反馈机制，使用到了GestureDetector这个类；这个类可以用来进行手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。内部提供了OnGestureListener、OnDoubleTapListener和OnContextClickListener三个接口，并提供了一系列的方法，比如常见的\n- onSingleTapUp ： 手指轻触屏幕离开\n- onScroll : 滑动\n- onLongPress： 长按\n- onFling： 按下后，快速滑动松开（类似切水果的手势）\n- onDoubleTap : 双击\n\n\n可以看到，使用这个类可以更加精确的处理手势操作。\n\n\n**这里引入GestureDetector的原因是这样的，单独在onTouchEvent处理所有事件时，在手指点击屏幕的瞬间，很容易触发MotionEvent.ACTION_MOVE事件，导致每次触碰气泡，被点击气泡的位置都会稍微颤抖一下，位置发生轻微的偏移，体验十分糟糕。采用GestureDetector对手指滑动的处理，对点击和滑动的检测显得更加精确**\n\n\n```java\n@Override\n    public boolean onTouchEvent(MotionEvent event) {\n        if (mValueAnimator != null) {\n            if (mValueAnimator.isRunning()) {\n                return false;\n            }\n        }\n        m_gestureDetector.onTouchEvent(event);\n        int lastX = (int) event.getX();\n        int lastY = (int) event.getY();\n\n\n        if (event.getAction() == MotionEvent.ACTION_DOWN) {\n            for (int i = 0; i < positions.length; i++) {\n                int deltaX = positions[i].x - lastX;\n                int deltaY = positions[i].y - lastY;\n\n                // 手指 -- ACTION_DOWN 时，落在了某一个气泡上时，刷新选中气泡（球员）的bitmap\n                if (Math.abs(deltaX) < playW / 2 && Math.abs(deltaY) < playW / 2) {\n                    position = i;\n                    currentPos = i;\n                    invalidate();\n                    moveEnable = true;\n                    Log.e(TAG, \"onTouchEvent: position= \" + position);\n                    return true;\n                }\n\n\n            }\n\n            //没有点击中任意一个气泡，点击在外部是，重置气泡（球员）状态\n            resetBubbleView();\n            moveEnable = false;\n            return false;\n        }\n\n\n        return super.onTouchEvent(event);\n\n    }\n```\n\n这里m_gestureDetector.onTouchEvent(event)，这样就可以让GestureDetector在他自己的回调方法OnGestureListener里，处理触摸事件。\n\n上面的逻辑很简单，动画正在进行是，直接返回。MotionEvent.ACTION_DOWN事件发生时的处理逻辑，通过注释很容易理解，就不再赘述。\n\n当我们点击到某个气泡时，就获取到了当前选中位置currentPos；下面看看GestureDetector的回调方法，是怎样处理滑动事件的。\n\n\n```\nGestureDetector.OnGestureListener onGestureListener = new GestureDetector.SimpleOnGestureListener() {\n        @Override\n        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n            if (moveEnable) {\n                positions[position].x -= distanceX;\n                positions[position].y -= distanceY;\n\n\n                //滑动时，考虑一下上下边界的问题，不要把球员移除场外\n                // 横向就不考虑了，因为底图是3D 摆放的，上窄下宽，无法计算\n                // 主要限制一下，纵向滑动值\n                if (positions[position].y < minY) {\n                    positions[position].y = minY;\n                } else if (positions[position].y > maxY) {\n                    positions[position].y = maxY;\n                }\n\n                Log.e(TAG, \"onScroll: y=\" + positions[position].y);\n\n                //跟随手指，移动气泡（球员）\n                invalidate();;\n            }\n            return true;\n        }\n    };\n```\nSimpleOnGestureListener 默认实现了OnGestureListener，OnDoubleTapListener, OnContextClickListener这三个接口中所有的方法，因此非常方便我们使用GestureDetector进行特定手势的处理。\n\n\n这里的处理很简单，当气泡被选中时moveEnable=true，通过onScroll回调方法返回的距离，不断更新当前位置的坐标，同时记得限制一下手势滑动的边界，总不能把球员移动到场地外面吧o(╯□╰)o，最后的postInvalidate()是关键，触发onDraw方法，实现重新绘制。\n\n**这里有一个细节，不知你发现没有，我们在更新坐标的时候，每次都是在当前坐标的位置，减去了滑动距离（distanceX/distanceY)。这是为什么(⊙o⊙)?，为什么不是加呢？**\n\n我们可以看看这个回调方法的定义\n\n```java\n       /**\n         * Notified when a scroll occurs with the initial on down {@link MotionEvent} and the\n         * current move {@link MotionEvent}. The distance in x and y is also supplied for\n         * convenience.\n         *\n         * @param e1 The first down motion event that started the scrolling.\n         * @param e2 The move motion event that triggered the current onScroll.\n         * @param distanceX The distance along the X axis that has been scrolled since the last\n         *              call to onScroll. This is NOT the distance between {@code e1}\n         *              and {@code e2}.\n         * @param distanceY The distance along the Y axis that has been scrolled since the last\n         *              call to onScroll. This is NOT the distance between {@code e1}\n         *              and {@code e2}.\n         * @return true if the event is consumed, else false\n         */\n        boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY);\n```\n\n可以看到，这里特定强调了**This is NOT the distance between {@code e1}and {@code e2}**，就是说这个距离并不是两次事件e1和e2 之间的距离。那么这个距离又是什么呢？那我们就找一找到底是在哪里触发了这个回调方法.\n\n最终在GestureDetector类的onTouchEvent()方法里找到了触发这个方法发生的地方：\n\n\n```java\npublic boolean onTouchEvent(MotionEvent ev) {\n\n\t.....\n\n        final boolean pointerUp =\n                (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;\n        final int skipIndex = pointerUp ? ev.getActionIndex() : -1;\n\n        // Determine focal point\n        float sumX = 0, sumY = 0;\n        final int count = ev.getPointerCount();\n        for (int i = 0; i < count; i++) {\n            if (skipIndex == i) continue;\n            sumX += ev.getX(i);\n            sumY += ev.getY(i);\n        }\n        final int div = pointerUp ? count - 1 : count;\n        final float focusX = sumX / div;\n        final float focusY = sumY / div;\n\n        boolean handled = false;\n\n        switch (action & MotionEvent.ACTION_MASK) {\n\n        case MotionEvent.ACTION_MOVE:\n            if (mInLongPress || mInContextClick) {\n                break;\n            }\n            final float scrollX = mLastFocusX - focusX;\n            final float scrollY = mLastFocusY - focusY;\n            if (mIsDoubleTapping) {\n                // Give the move events of the double-tap\n                handled |= mDoubleTapListener.onDoubleTapEvent(ev);\n            } else if (mAlwaysInTapRegion) {\n                final int deltaX = (int) (focusX - mDownFocusX);\n                final int deltaY = (int) (focusY - mDownFocusY);\n                int distance = (deltaX * deltaX) + (deltaY * deltaY);\n                if (distance > mTouchSlopSquare) {\n                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);\n                    mLastFocusX = focusX;\n                    mLastFocusY = focusY;\n                    mAlwaysInTapRegion = false;\n                    mHandler.removeMessages(TAP);\n                    mHandler.removeMessages(SHOW_PRESS);\n                    mHandler.removeMessages(LONG_PRESS);\n                }\n                if (distance > mDoubleTapTouchSlopSquare) {\n                    mAlwaysInBiggerTapRegion = false;\n                }\n            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {\n                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);\n                mLastFocusX = focusX;\n                mLastFocusY = focusY;\n            }\n            break;\n\n        \n        return handled;\n    }\n```\n\n这里还涉及到多指触控的考虑，情况较为复杂；简单说一下结论，**在ACTION_MOVE时，会从上一次手指离开的距离，减去此次手指触碰的位置；这样当scrollX>0时，就是在向右滑动，反之向左；scrollY > 0 时，是在向上滑动，反之向下**；因此，这两个距离和我们习以为常的方向恰好都是相反的，因此，在更新坐标时，需要做相反的处理。\n\n**有兴趣的同学，可以把上面的“-”改成“+”，尝试运行一下代码，就会明白其中的道理了。**\n\n好了，到了这里按照**绘制，布局，触摸反馈**的顺序我们已经完成了BallGameView这个自定义View自己的内容了，但是我们还看到在点击下面的球员头像时，还有一个简单的动画，下面就看看动画是如何实现的。\n\n\n## 动画效果\n\n首先说明一下，底部球员列表是一个横向的RecyclerView，这样一个横向滑动的双列展示的RecyclerView 应该很简单了，这里就不再详述。文末有源码，最后可以查看。\n\n这里看一下每一个RecyclerView中item的点击事件\n\n\n```java\n\n@Override\n    public void onRVItemClick(ViewGroup parent, View itemView, int position) {\n\n        if (mPlayerBeanList.get(position).isSelected()) {\n            Toast.makeText(mContext, \"球员已被选择!\", Toast.LENGTH_SHORT).show();\n        } else {\n            View avatar = itemView.findViewById(R.id.img);\n            int width = avatar.getWidth();\n            int height = avatar.getHeight();\n            Bitmap bitmap = Tools.View2Bitmap(avatar, width, height);\n            int[] location = new int[2];\n            itemView.getLocationOnScreen(location);\n            if (bitmap != null) {\n                mGameView.updatePlayer(bitmap, mPlayerBeanList.get(position).getName(), location, content);\n            }\n\n        }\n\n    }\n```\n\n这里可以看到调用了GameView的updatePlayer方法：\n\n```java\n/**\n     * 在下方球员区域，选中球员后，根据位置执行动画，将球员放置在选中的气泡中\n     *\n     * @param bitmap      被选中球员bitmap\n     * @param name        被选中球员名字\n     * @param location    被选中球员在屏幕中位置\n     * @param contentView 根视图（方便实现动画）\n     */\n    public void updatePlayer(final Bitmap bitmap, final String name, int[] location, final ViewGroup contentView) {\n\n        Path mPath = new Path();\n        mPath.moveTo(location[0] + bitmap.getWidth() / 2, location[1] - bitmap.getHeight() / 2);\n        mPath.lineTo(positions[currentPos].x - playW / 2, positions[currentPos].y - playW / 2);\n\n\n        final ImageView animImage = new ImageView(getContext());\n        animImage.setImageBitmap(bitmap);\n        RelativeLayout.LayoutParams params = new RelativeLayout.LayoutParams(120, 120);\n        contentView.addView(animImage, params);\n\n\n        final float[] animPositions = new float[2];\n        final PathMeasure mPathMeasure = new PathMeasure(mPath, false);\n\n        mValueAnimator = ValueAnimator.ofFloat(0, mPathMeasure.getLength());\n        mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                float value = (float) animation.getAnimatedValue();\n                mPathMeasure.getPosTan(value, animPositions, null);\n\n                animImage.setTranslationX(animPositions[0]);\n                animImage.setTranslationY(animPositions[1]);\n\n            }\n        });\n\n        mValueAnimator.addListener(new AnimatorListenerAdapter() {\n            @Override\n            public void onAnimationEnd(Animator animation) {\n                super.onAnimationEnd(animation);\n\n                contentView.removeView(animImage);\n\n                players[currentPos].setBitmap(bitmap);\n                players[currentPos].setSetReal(true);\n                players[currentPos].setName(name);\n\n                invalidate();\n\n\n            }\n        });\n        mValueAnimator.setDuration(500);\n        mValueAnimator.setInterpolator(new AccelerateInterpolator());\n        mValueAnimator.start();\n\n\n    }\n```\n\n这个动画，简单来说就是一个一阶贝塞尔曲线。根据RecyclerView中item在屏幕中的位置，构造一个一模一样的ImageView添加到根视图中，然后通过一个属性动画，在属性值不断更新时，在回调方法中不断调用setTranslation方法，改变这个ImageView的位置，呈现出动画的效果。动画结束后，将这个ImageView从视图移除，同时气泡中的数据即可，最后再次invalidate导致整个视图重新绘制，这样动画完成时，气泡就被替换为真实的头像了。\n\n\n\n到这里，基本上所有功能，都实现了。最后就是把自己排出来的阵型，保存为图片分享给小伙伴了。这里主要说一下保存图片的实现；分享功能，就不作为重点讨论了。\n\n## 自定义View保存为Bitmap\n\n\n```java\nprivate class SavePicTask extends AsyncTask<Bitmap, Void, String> {\n\n        @Override\n        protected String doInBackground(Bitmap... params) {\n            Bitmap mBitmap = params[0];\n            String filePath = \"\";\n            Calendar now = new GregorianCalendar();\n            SimpleDateFormat simpleDate = new SimpleDateFormat(\"yyyyMMddHHmmss\", Locale.getDefault());\n            String fileName = simpleDate.format(now.getTime());\n            //保存在应用内目录，免去申请读取权限的麻烦\n            File mFile = new File(mContext.getExternalFilesDir(Environment.DIRECTORY_PICTURES), fileName + \".jpg\");\n            try {\n                OutputStream mOutputStream = new FileOutputStream(mFile);\n                mBitmap.compress(Bitmap.CompressFormat.JPEG, 100, mOutputStream);\n                mOutputStream.flush();\n                mOutputStream.close();\n                filePath = mFile.getAbsolutePath();\n\n\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n\n            return filePath;\n        }\n    }\n```\n\n```java\n\n                mGameView.setDrawingCacheEnabled(true);\n                Bitmap mBitmap = mGameView.getDrawingCache();\n\n                if (mBitmap != null) {\n                    new SavePicTask().execute(mBitmap);\n                } else {\n                    Toast.makeText(mContext, \"fail\", Toast.LENGTH_SHORT).show();\n                }\n\n```\n\n\n一个典型的AsyncTask实现，文件流的输出，没什么多说的。主要是存储目录的选择，**这里有个技巧，如果没有特殊限制，平时我们做开发的时候，可以 把一些存储路径做如下定义**\n\n\n- mContext.getExternalFilesDir(Environment.DIRECTORY_PICTURES)：代表/storage/emulated/0/Android/data/{packagname}/files/Pictures\n- mContext.getExternalCacheDir() 代表 /storage/emulated/0/Android/data/{packagname}/cache\n\n对于mContext.getExternalFilesDir还可定义为Environment.DIRECTORY_DOWNLOADS，Environment.DIRECTORY_DOCUMENTS等目录，对应的文件夹名称也会变化。\n\n这个目录中的内容会随着用户卸载应用，一并删除。**最重要的是，读写这个目录是不需要权限的，因此省去了每次做权限判断的麻烦，而且也避免了没有权限时的窘境**。\n\n\n到这里，模仿功能，全部都实现了。下面稍微来一点额外的扩展。\n\n我们希望**图片保存后可以在通知栏提示用户，点击通知栏后可以通过手机相册查看保存的图片。**\n\n\n## 扩展-Android  Notification & FileProvider 的使用\n\n```\nprivate void SaveAndNotify() {\n        if (!TextUtils.isEmpty(picUrl)) {\n          \n            NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(mContext);\n            mBuilder.setWhen(System.currentTimeMillis())\n                    .setTicker(\"下载图片成功\")\n                    .setContentTitle(\"点击查看\")\n                    .setSmallIcon(R.mipmap.app_start)\n                    .setContentText(\"图片保存在:\" + picUrl)\n                    .setAutoCancel(true)\n                    .setOngoing(false);\n            //通知默认的声音 震动 呼吸灯\n            mBuilder.setDefaults(NotificationCompat.DEFAULT_ALL);\n\n            Intent mIntent = new Intent();\n            mIntent.setAction(Intent.ACTION_VIEW);\n            Uri contentUri;\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n                // 将文件转换成content://Uri的形式\n                contentUri = FileProvider.getUriForFile(mContext, getPackageName() + \".provider\", new File(picUrl));\n                // 申请临时访问权限\n                mIntent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n            } else {\n                contentUri = Uri.fromFile(new File(picUrl));\n            }\n\n            mIntent.setDataAndType(contentUri, \"image/*\");\n\n\n            PendingIntent mPendingIntent = PendingIntent.getActivity(mContext\n                    , 0, mIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n            mBuilder.setContentIntent(mPendingIntent);\n            Notification mNotification = mBuilder.build();\n            mNotification.flags |= Notification.FLAG_AUTO_CANCEL;\n            NotificationManager mManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n            mManager.notify(0, mNotification);\n        } else {\n            T.showSToast(mContext, \"图片保存失败\");\n        }\n    }\n```\n\nAndroid 系统中的通知栏，随着版本的升级，已经形成了固定了写法，在Builder模式的基础上，通过链式写法，可以非常方便的设置各种属性。这里重点说一下PendingIntent的用法，我们知道这个PendingIntent 顾名思义，就是处于Pending状态，当我们点击通知栏，就会触发他所包含的Intent。\n\n严格来说，通过自己的应用想用手机自带相册打开一张图片是无法实现的，因为无法保证每一种手机上面相册的包名是一样的，因此这里我们创建ACTION=Intent.ACTION_VIEW的 Intent，去匹配系统所有符合这个Action 的Activity，系统相册一定是其中之一。\n\n到这里，还有一定需要注意，Android 7.0 开始，无法以file://xxxx 形式向外部应用提供内容了，因此需要考虑使用FileProvider。当然，对这个问题，Google官方提供了完整的使用实例，实现起来都是套路，没有什么特别之处。\n\n重点记住下面的对应关系即可：\n\n```\n <root-path/> 代表设备的根目录new File(\"/\");\n <files-path/> 代表context.getFilesDir()\n <cache-path/> 代表context.getCacheDir()\n <external-path/> 代表Environment.getExternalStorageDirectory()\n <external-files-path>代表context.getExternalFilesDirs()\n <external-cache-path>代表getExternalCacheDirs()\n```\n\n\n按照上面，我们存储图片的目录，我们在file_path.xml 做如下定义即可：\n\n```xml\n\n<paths xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <external-path\n        name=\"root\"\n        path=\"\"/>\n</paths>\n```\n在AndroidManifest中完成如下配置 ：\n\n```\n        <!-- Android 7.0 FileUriExposedException -->\n        <provider\n            android:name=\"android.support.v4.content.FileProvider\"\n            android:authorities=\"${applicationId}.provider\"\n            android:exported=\"false\"\n            android:grantUriPermissions=\"true\">\n            <meta-data\n                android:name=\"android.support.FILE_PROVIDER_PATHS\"\n                android:resource=\"@xml/file_path\"/>\n        </provider>\n```\n\n这样，当Build.VERSION.SDK_INT大于等于24及Android7.0时，可以安心的使用FileProvider来和外部应用共享文件了。\n\n\n\n## 最后\n\n好了，从一个简单的自定义View 出发，又牵出了一大堆周边的内容。好在，总算完整的说完了。\n\n**特别申明**\n\n>以上代码中所用到的图片资源，全部源自懂球帝APP内；此处对应用解包，只是本着学习的目的，没有其他任何用意。\n\n\n\n******************\n\n**源码地址：** [Github-AndroidAnimationExercise](https://github.com/REBOOTERS/AndroidAnimationExercise)。\n\n有兴趣的同学欢迎 star &  fork。\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["自定义View"],"categories":["Android 进阶"]},{"title":"仿简书长按文章生成图片效果","url":"%2F2017%2F03%2F19%2F%E4%BB%BF%E7%AE%80%E4%B9%A6%E9%95%BF%E6%8C%89%E6%96%87%E7%AB%A0%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E6%95%88%E6%9E%9C%2F","content":"\n\n## 前言\n\n使用简书APP的同学都知道，简书有这样一个功能；文章页长按内容时底部会出现一个**生成图片分享**的按钮，点击之后就可以将当前的文章生成一张长图片；这张图片可以保存到本地或分享给好友，同时还可为图片设置成为白和黑两种风格，很有艺术范。个人一直很喜欢这个功能。\n\n但是从某一个版本开始，这个功能开始有bug了，生成的图片只有底部的固定标题，而没有文章内容，长图也变成了小短图。向简书意见反馈后，得到的回复是，使用点击分享按钮生成图片功能；分享菜单包含的生成长图功能的确是可以的。但是，还是很怀念之前长按生成图片的功能，所以作为一名程序猿；怀着好奇的心情，决定自己去实现这样一个功能.\n\n## 效果预览\n\n老规矩，首先看一下实现后的效果；虽然整体没有简书有范，个人感觉还是挺像的。\n\n\n![效果图](https://user-gold-cdn.xitu.io/2017/3/19/5bfdffd406bed1f24293ff9cc5ffe3c8)\n\n<!--more-->\n\n## 文章页实现\n\n#### 内容\n\n文章页内容的实现，没有什么难点。布局总的来说很简单，包含户信息和文章信息的一个LinearLayout，外加一个WebView即可。数据是根据布局中所需的内容，封装了一个HtmlBean 对象，而这个对象的则是通过使用Jsoup 解析当前页面的HTML文档内容获得（这里使用Jsoup 方式获取简书网页内容，只是个人学习，没有其他用意）。具体实现可查看[源码](https://github.com/REBOOTERS/AndroidAnimationExercise)\n\n#### 长按菜单实现\n\n这里特意说一下，长按弹出底部按钮的实现方式。一般情况下对于长按效果的实现，我们都会通过设置View的OnLongClickListene事件去实现相应的功能，但是对于这里的WebView可以如下实现：\n\n```java\n        mWebView.setOnCreateContextMenuListener(new View.OnCreateContextMenuListener() {\n            @Override\n            public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n                genImg.setVisibility(View.VISIBLE);\n                T.showSToast(mContext, \"再次点击文章可隐藏图片分享\");\n            }\n        });\n        // 点击隐藏底部按钮\n        mWebView.setOnTouchListener(new View.OnTouchListener() {\n            @Override\n            public boolean onTouch(View v, MotionEvent event) {\n                switch (event.getAction()) {\n                    case MotionEvent.ACTION_DOWN:\n                        lastTime = SystemClock.uptimeMillis();\n                        break;\n                    case MotionEvent.ACTION_UP:\n                        if (SystemClock.uptimeMillis() - lastTime < 300) {\n                            genImg.setVisibility(View.GONE);\n                        }\n                        break;\n                }\n                return false;\n            }\n        });\n```\n*****\n这里通过监听WebView的ContextMenu 监听何时显示底部按钮；同时在onTouch方法中隐藏底部按钮。\n\n```java\n        genImg.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                genImg.setVisibility(View.INVISIBLE);\n                Intent intent = new Intent(FakeJianShuActivity.this, GenScreenShotActivity.class);\n                intent.putExtra(\"data\", mHtmlBean);\n                startActivity(intent);\n            }\n        });\n```\n点击底部的Button就会跳转到生成长图的界面，同时将之前获取到的HTMLBean对象传递过去。\n\n## 长图效果实现\n\n这里首先说一下实现思路（思路来源于[此](http://www.jianshu.com/p/c34aad68bf46)）。\n- 首先通过WebView加载一个本地的Html页面，这个页面包含一些固定，定义了一些标签。然后根据传递过来的mHtmlBean 对象中的信息，通过执行JavaScript动态的替换静态HTML页面中的内容；\n- 关于黑白两种风格的实现，同样是WebView执行Js，动态替换HTML中CSS 样式，修改WebView的背景色呈现出两种不同的UI 效果。\n- 通过WebView的capturePicture 和Canvas 可以生成出当前WebView的Bitmap对象，有了这个Bitmap就可以图片保存的功能了。\n\n好了，下面就通过代码分别实现上述步骤。\n\n#### Html 页面（JianShu.html）\n\n```html \n<html>\n<head>\n    <meta charset=\"utf-8\"/>\n</head>\n<body>\n<img src=\"mark.png\" width=\"13px\" height=\"20px\"\n     style=\"position:absolute;top: 0px;left: 12px;margin-bottom: 15px;\"/>\n<article id=\"content\" style=\"margin: 25px;\"></article>\n<script type=\"text/javascript\">\n        function changeContent(content) {\n            document.getElementById('content').innerHTML = content;\n        }\n\n</script>\n</body>\n</html>\n```\n\n这个HTML页面的内容很简单，在整个文档左上角放置了一个小角标，就是简书APP生成长图时的那个mark.\n同时定义了一个JavaScript 方法，功能也很简单，就是用传递的参数content替换article标签中的文档内容。 \n\n#### 自定义WebView \n\n为了方便，我们自定义WebView，这里看一下核心逻辑：\n\n```java\npublic class FakeWebView extends WebView {\n     \n    private boolean isFirstLoad = false;\n\n    public void loadData(HtmlBean bean) {\n        assembleData(bean);\n        if (Build.VERSION.SDK_INT >= 21) {\n            isFirstLoad = true;\n            webView.setWebChromeClient(new WebChromeClient() {\n                @Override\n                public void onProgressChanged(WebView view, int newProgress) {\n                    if (newProgress == 100) {\n                        if (isFirstLoad) {\n                            isFirstLoad = false;\n                            Log.e(\"TAG\", \"onProgressChanged\");\n                            updateView();\n                        }\n                    }\n                }\n            });\n        } else {\n            isFirstLoad = true;\n            webView.setVisibility(View.INVISIBLE);\n\n            webView.setWebChromeClient(new WebChromeClient() {\n                @Override\n                public void onProgressChanged(WebView view, int newProgress) {\n                    if (newProgress == 100) {\n                        updateView();\n                        if (!isFirstLoad)\n                            webView.setVisibility(View.VISIBLE);\n                    }\n                }\n            });\n        }\n        webView.loadUrl(\"file:///android_asset/JianShu.html\");\n\n    }\n\n    private void assembleData(HtmlBean bean) {\n        final String data = bean.getContent();\n        final String title = bean.getTitle();\n        final String username = bean.getUsername();\n        final String publishTime = bean.getPublishTime();\n        String Title = \"<h2>\" + title + \"</h2>\";\n        String Footer = \"<p>\" + username + \"</p><p>\" + publishTime + \"</p>\";\n        content = Title + data + Footer;\n    }\n\n\n    public void updateView() {\n        if (mode == MODE_DAY) {\n            webView.setBackgroundColor(Color.WHITE);\n        } else {\n            webView.setBackgroundColor(Color.parseColor(\"#263238\"));\n            content = \"<div style=\\\"color: gray;display: inline;\\\">\" + content + \"</div>\";\n        }\n        webView.loadUrl(\"javascript:changeContent(\\\"\" + content.replace(\"\\n\", \"\\\\n\").replace(\"\\\"\", \"\\\\\\\"\").replace(\"'\", \"\\\\'\") + \"\\\")\");\n    }\n}\n```\n\n这几个方法是生成长图最核心的方法。在loadData 方法中首先调用了assembleData，这个方法会根据mHtmlBean 这个对象中的数据拼接出一段 HTML 文档。在webView的loadUrl 方法中会从本地加载之前定义好的JianShu.html这个页面。然后在页面加载完成，即onProgressChanged 回调方法中newProgress 的值等于100时调用updateView方法；这个方法会根据当前设置的模式，设置WebView的背景，如果是夜间模式，则会对assembleData 中生成的文档外部在添加 一个灰色风格的div标签，将整个内容包在这个div标签中，最后WebView执行JS方法 changeContent，传递的参数就是之前我们拼接好的内容。这样整个WebView又会刷新一次，整个WebView的内容就是文章内容了。\n\n####  GenScreenShotActivity \n\n```java\n        mFakeWebView = (FakeWebView) findViewById(R.id.fakeWebView);\n        bean = (HtmlBean) getIntent().getSerializableExtra(\"data\");\n        RadioGroup changeMode = (RadioGroup) findViewById(R.id.changeMode);\n        changeMode.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(RadioGroup group, @IdRes int checkedId) {\n                if (checkedId == R.id.rb_day) {\n                    mFakeWebView.setMode(FakeWebView.MODE_DAY);\n                } else {\n                    mFakeWebView.setMode(FakeWebView.MODE_NIGHT);\n                }\n            }\n        });\n        mFakeWebView.loadData(bean);\n\n      /**\n     * @param mode\n     */\n    public void setMode(@ViewMode int mode) {\n        this.mode = mode;\n        updateView();\n    }\n```\n\n这样在Activity中，mFakeWebView对象通过上一个页面（文章页）传递的mHtmlBean 对象就可以更新当前视图了，同时可以通过RadioButton实现页面风格的切换。\n\n#### 保存图片\n距离我们最后的目标**生成长图片**，前面的工作可以说只是完成了50%，因为到目前为止我们只不过是在WebView中把整个文章内容加载出来而已；长图还没有呢。因此，下面的工作就是通过WebView 生成长图。\n\n```java \n    public Bitmap getScreenView(){\n        Picture snapShot = webView.capturePicture();\n        Bitmap bmp = Bitmap.createBitmap(snapShot.getWidth(),snapShot.getHeight(), Bitmap.Config.ARGB_8888);\n        Canvas canvas = new Canvas(bmp);\n        snapShot.draw(canvas);\n        return bmp;\n    }\n```\n\nWebVeiw 很人性化，通过这个方法，我们就可以获得当前WebView视图**可见与不可见**部分的Bitmap了。\n其实通过WebView生成图片并不是一件难事，难得是如何把我们这里的图片保存下来；因为我们这里生成的是长图，如下图所示，这张照片的高度达到了惊人的。因此这里就要需要之前在[Bitmap 初探](http://www.jianshu.com/p/dc5e390d189a)中提到的第一种压缩方法进行文件大小的压缩了。具体实现，就不再重复贴出代码了，有兴趣的同学可参考文末Github源码。\n\n\n\n到这里，我们就完全实现了仿照简书长按生成图片的功能。那么回过头再来看，这样一个功能，为什么在我的手机上，简书APP的长按功能会有bug呢。\n\n## 缺陷\n\n文章详情页的WebView是系统自带的WebView，在加载带 代码的文章时，没有对代码类的内容做特殊的解析，因此无法对代码高亮显示。只是最为普通的文本进行了显示，因此生成的长图中代码也是普通文本。简书APP还是高大上呀，对代码的高亮显示正是棒棒哒！\n\n## 后话\n\n一个偶然的机会，在尝试简书长按生成图片的功能时发现，原来简书是通过WebView选择的区域生成第二页的内容；因此当我在文章页空白区域长按后，点击生成图片时必然是只有空白的，只有底部的一些固定标签。因此，这应该不算是一个bug，只是为大家提供了一种更方便的功能，可以按自己喜欢的内容生成更有效的长图。\n\n*******\n最后 [Github AndroidAnimationExercise](https://github.com/REBOOTERS/AndroidAnimationExercise)，这是一个平常自己学习Android各种动画、自定义View的集合项目，有兴趣的同学欢迎 star & fork 。","tags":["自定义View"],"categories":["Android 进阶"]},{"title":"2017 booklist","url":"%2F2017%2F03%2F01%2F2017-booklist%2F","content":"\n\n- 尤瓦尔·赫拉利-人类简史 Done\n- 肯·福莱特-世纪三部曲-巨人的陨落 Done\n- 肯·福莱特-世纪三部曲-世界的凛冬 Done\n- 肯·福莱特-世纪三部曲-永恒的边缘 Done\n\n\ntodo\n\n- 刘慈欣-三体 Delayed\n","tags":["读书"]},{"title":"Android MVP 十分钟入门！","url":"%2F2017%2F01%2F24%2FAndroid%20MVP%20%E5%8D%81%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8%EF%BC%81%2F","content":"\n## 前言##\n在日常开发APP 的过程中，随着业务的扩展，规模的变化。我们的代码规模也会逐渐变得庞大，每一个类里的代码也会逐渐增多。尤其是Activity和Fragment ，由于Context 的存在，基本上所有对视图的操作我们只能在Activity和Fragment中完成；即便是对某些逻辑进行封装，Activity和Fragment 依旧会显得过于臃肿。因此，我们需要换一种思路去写代码，这个时候MVP模式就应用而生了！那么MVP 怎么用呢，下面就来说一说。\n\n假设你现在如要实现下图中的功能：\n\n\n![](https://lc-mhke0kuv.cn-n1.lcfile.com/ddbae96177704862aa4c.jpg)\n\n这个需求很简单，就是点击按钮，下载一张图片，显示下载进度；下载完成后，在ImageView中显示这张图片。\n下面我们就分别用传统的方式（也就是所谓的MVC)和MVP 模式分别取实现这个功能。然后分析一下MVP 到底好在哪里。\n\n<!--more-->\n\n## MVC##\n\n```java\npublic class MVCActivity extends AppCompatActivity {\n\n    private Context mContext;\n    private ImageView mImageView;\n    private MyHandler mMyHandler;\n    private ProgressDialog progressDialog;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_mvc);\n        mContext = this;\n        init();\n    }\n\n    private void init() {\n        //view init\n        mImageView = (ImageView) findViewById(R.id.image);\n        mMyHandler = new MyHandler();\n\n        progressDialog = new ProgressDialog(mContext);\n        progressDialog.setButton(DialogInterface.BUTTON_NEGATIVE, \"Cancle\", new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialog, int which) {\n                progressDialog.dismiss();\n            }\n        });\n        progressDialog.setCanceledOnTouchOutside(false);\n        progressDialog.setTitle(\"下载文件\");\n        progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n\n\n        //click-event\n        findViewById(R.id.downloadBtn).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                progressDialog.show();\n                HttpUtil.HttpGet(Constants.DOWNLOAD_URL, new DownloadCallback(mMyHandler));\n            }\n        });\n\n        findViewById(R.id.downloadBtn1).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                progressDialog.show();\n                HttpUtil.HttpGet(Constants.DOWNLOAD_ERROR_URL, new DownloadCallback(mMyHandler));\n            }\n        });\n\n    }\n\n\n    class MyHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n            switch (msg.what) {\n                case 300:\n                    int percent = msg.arg1;\n                    if (percent < 100) {\n                        progressDialog.setProgress(percent);\n                    } else {\n                        progressDialog.dismiss();\n                        Glide.with(mContext).load(Constants.LOCAL_FILE_PATH).into(mImageView);\n                    }\n                    break;\n                case 404:\n                    progressDialog.dismiss();\n                    Toast.makeText(mContext, \"Download fail !\", Toast.LENGTH_SHORT).show();\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n}\n```\n用mvc的方式，一个Activity就能搞定。代码逻辑很简单，点击按钮后显示之前初始化好ProgressDialog，然后开始下载任务（这里HttpUtil 内部简单封装了OKHttp 的异步GET请求，实现下载文件保存到本地的功能，实现细节在此不做深入探讨，有兴趣的同学可以查看[源码](https://github.com/REBOOTERS/My-MVP))，然后将请求结果通过Handler返回，在handleMessage中根据返回数据的信息做出不同的UI 处理；下载成功时在ImageView中显示图片，下载失败时Toast提示。\n\n可以发现，在这种情况之前，Activity的任务十分繁重，既要负责下载任务的具体实施，还要根据下载进行再次的逻辑判断，才能去更新UI。这里只是一个简单的任务，你可能觉得无所谓，但是实际开发中，一个Activity中有许多的交互事件，这个时候Activity的代码就显得特别的庞大；一旦需求变更或出现bug，那简直就是噩梦一场。\n\n因此，我们希望Activity可以变成下面这样\n\n- 他负责发起处理和用户交互的内容，但又不负责具体的实现；\n- 需要显示什么，不显示什么，什么东西显示多少，有个东西可以直接告诉他，\n- Activity不再做复杂的逻辑处理；\n\n具体到上面的demo里就是，**Activity负责发起下载任务，但是不负责具体实现；什么时候显示ProgressDialog，显示多少？什么时候提示错误信息，这一切都希望有个东西能直接告诉Activity，而不再是在Activity里再做判断。怎样才能做到呢？那就得靠MVP 了。**\n\n## MVP ##\n\n**MVP 模式所做的事情很简单，就是将业务逻辑和视图逻辑抽象到接口中。**\n\n怎么理解呢，我们就根据此次要实现的下载功能，用代码说话。\n\n### 定义Model，View，Presenter 接口###\n\n#### Model Interface####\n\nModel 接口定义所有需要实现的**业务逻辑**，在我们的下载任务中，业务逻辑只有一个，就是下载；因此Model 接口可以这么定义 ：\n\n```java\npublic interface IDownloadModel {\n    /**\n     * 下载操作\n     * @param url\n     */\n    void download(String url);\n}\n```\n\n#### View Interface####\n\nView 接口定义所有需要实现的**视图逻辑**，在我们的下载任务中，视图逻辑包括\n- 显示ProgressDialog；\n- 显示Dialog具体进度；\n- 显示具体的View（设置图片）；\n- 显示错误信息（Toast提示）\n\n因此View接口可以这么定义：\n\n```java\npublic interface IDownloadView {\n    /**\n     * 显示进度条\n     * @param show\n     */\n    void showProgressBar(boolean show);\n\n    /**\n     * 设置进度条进度\n     * @param progress\n     */\n    void setProcessProgress(int progress);\n\n    /**\n     * 根据数据设置view\n     * @param result\n     */\n    void setView(String result);\n\n    /**\n     * 设置请求失败时的view\n     */\n    void showFailToast();\n}\n```\n#### Presenter Interface####\n\nPresenter 接口作为连接Model和View的中间桥梁，需要将二者连接起来，因此他需要完成以下工作：\n- 执行下载任务\n- 下载成功返回下载结果\n- 下载过程返回下载进度\n- 下载失败回调\n\n因此，Presenter 就可以这么定义：\n\n```java\npublic interface IDowndownPresenter {\n    /**\n     * 下载\n     * @param url\n     */\n    void download(String url);\n\n    /**\n     * 下载成功\n     * @param result\n     */\n    void downloadSuccess(String result);\n\n    /**\n     * 当前下载进度\n     * @param progress\n     */\n    void downloadProgress(int progress);\n\n    /**\n     * 下载失败\n     */\n    void downloadFail();\n}\n```\n### 接口Model，View，Presenter 具体实现###\n\n上面实现了，各个接口的定义，下面来看看他们具体的实现：\n\n#### Model 具体实现####\n\n```java\npublic class DownloadModel implements IDownloadModel {\n    private IDowndownPresenter mIDowndownPresenter;\n    private MyHandler mMyHandler = new MyHandler();\n\n    public DownloadModel(IDowndownPresenter IDowndownPresenter) {\n        mIDowndownPresenter = IDowndownPresenter;\n    }\n\n    @Override\n    public void download(String url) {\n        HttpUtil.HttpGet(url, new DownloadCallback(mMyHandler));\n    }\n\n    class MyHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n            switch (msg.what) {\n                case 300:\n                    int percent = msg.arg1;\n                    if (percent < 100) {\n                        mIDowndownPresenter.downloadProgress(percent);\n                    } else {\n                        mIDowndownPresenter.downloadSuccess(Constants.LOCAL_FILE_PATH);\n                    }\n                    break;\n                case 404:\n                    mIDowndownPresenter.downloadFail();\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n}\n```\n在MVP模式中，Model的工作就是完成具体的业务操作，网络请求，持久化数据增删改查等任务。同时Model中又不会包含任何View。\n这里Model的具体实现很简单，将Http任务的结果返回到Handler当中，而在Handler中的实现又是由Presenter完成。\n那么Presenter接口又是怎样实现的呢？赶紧来看看\n\n#### Presenter 具体实现####\n\n```java\npublic class DownloadPresenter implements IDowndownPresenter {\n    private IDownloadView mIDownloadView;\n    private IDownloadModel mIDownloadModel;\n\n\n    public DownloadPresenter(IDownloadView IDownloadView) {\n        mIDownloadView = IDownloadView;\n        mIDownloadModel = new DownloadModel(this);\n    }\n\n    @Override\n    public void download(String url) {\n        mIDownloadView.showProgressBar(true);\n        mIDownloadModel.download(url);\n    }\n\n    @Override\n    public void downloadSuccess(String result) {\n        mIDownloadView.showProgressBar(false);\n        mIDownloadView.setView(result);\n    }\n\n    @Override\n    public void downloadProgress(int progress) {\n        mIDownloadView.setProcessProgress(progress);\n    }\n\n    @Override\n    public void downloadFail() {\n        mIDownloadView.showProgressBar(false);\n        mIDownloadView.showFailToast();\n    }\n}\n```\n\n可以看到，我们在DownloadPresenter的构造方法中，同时实例化了Model和View，这样Presenter中就同时包含了两者；\n这样；**在Presenter具体实现中，业务相关的操作由Model去完成（例如download），视图相关的操作由View去完成\n（如setView等）**。Presenter 作为桥梁的作用就这样体现出来了，巧妙的将View和Model的具体实现连接了起来。\n\n\n#### View具体实现####\n\n最后再看一下View接口的具体实现，也就是Activity的实现：\n\n```java\npublic class MVPActivity extends AppCompatActivity implements IDownloadView {\n    private Context mContext;\n    private ImageView mImageView;\n    private ProgressDialog progressDialog;\n\n    private DownloadPresenter mDownloadPresenter;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mContext = this;\n        setContentView(R.layout.activity_mvp);\n        init();\n    }\n\n    private void init() {\n        mDownloadPresenter = new DownloadPresenter(this);\n        //view init\n        mImageView = (ImageView) findViewById(R.id.image);\n        findViewById(R.id.downloadBtn).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                mDownloadPresenter.download(Constants.DOWNLOAD_URL);\n            }\n        });\n\n        findViewById(R.id.downloadBtn1).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                mDownloadPresenter.download(Constants.DOWNLOAD_ERROR_URL);\n            }\n        });\n\n        progressDialog = new ProgressDialog(mContext);\n        progressDialog.setButton(DialogInterface.BUTTON_NEGATIVE, \"Cancle\", new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialog, int which) {\n                progressDialog.dismiss();\n            }\n        });\n        progressDialog.setCanceledOnTouchOutside(false);\n        progressDialog.setTitle(\"下载文件\");\n        progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n\n    }\n\n    @Override\n    public void showProgressBar(boolean show) {\n        if (show) {\n            progressDialog.show();\n        } else {\n            progressDialog.dismiss();\n        }\n    }\n\n    @Override\n    public void setProcessProgress(int progress) {\n        progressDialog.setProgress(progress);\n    }\n\n    @Override\n    public void setView(String result) {\n        Glide.with(mContext).load(result).into(mImageView);\n    }\n\n    @Override\n    public void showFailToast() {\n        Toast.makeText(mContext, \"Download fail !\", Toast.LENGTH_SHORT).show();\n    }\n}\n```\n在点下按钮执行开始下载任务的时候，View（Activity）中没有具体的实现，只是调用了Presenter中的download方法，而Presenter中的download又会去调用Model的download方法，Model又会在根据具体逻辑（在这里就是Http请求）的状态去调用Presenter中的方法，例如我们在handleMessage方法中，调用mIDowndownPresenter.downloadProgress(percent)时，就会去调用Presenter的具体实现\n\n```java\n    @Override\n    public void downloadProgress(int progress) {\n        mIDownloadView.setProcessProgress(progress);\n    }\n```\n而他的内部实现又是操作具体的View，也就是我们在Activity中初始化Presenter中传递的this，也就是当前Activity（View），这样最终回到了Activity中的\n\n```java\n\n    @Override\n    public void setProcessProgress(int progress) {\n        progressDialog.setProgress(progress);\n    }\n```\n我们为progressDialog 设置进度。\n\n\n\n至此，我们就通过MVP 的模式实现了我们之前所设想的Activity\n\n- Button的click方法负责发起下载任务，但又不负责具体实现，而是由Presenter转接给Model去实现\n- Activity 什么时候显示ProgressDialog，什么时候显示Toast直接由Presenter告诉他，他只做一个View想做的事情\n- Activity里没有任何逻辑处理，所有的逻辑判断都在Model中完成了。\n\n这就是MVP ！！！\n\n## MVC VS MVP##\n\n通过上面的两种实现方案，相信每个人都已经理解了MVC和MVP的区别；下面就其各自的优缺点再做一下\n总结；**当然，这里的优缺点只是相对而言**。\n\n#### 优点####\n\n\n![MVC](https://lc-mhke0kuv.cn-n1.lcfile.com/423fe583f67b01d47106.gif)\n\n\n![MVP](https://lc-mhke0kuv.cn-n1.lcfile.com/8de34d72fad5bc8d67e2.png)\n\n\n上面两张图分别是MVC和MVP架构图。相信许多和我一样尝试去学习和了解MVP架构的同学对这两图（或类似的图）并不陌生。\n\n**结构更加清晰***\n\n我们回过头再去看MVCActivity 的实现，暂且将我们对Http请求的封装归结为Model(M),那么剩下的就只有Activity了,而这个Activity即实现视图逻辑，又需要实现部分业务逻辑，也就是说他既是Controller（C）又是View（V）。V和C的划分完全不清晰；因此，传统的代码结构只能勉强称为MV 或者是MC，如果算上xml 的布局文件，才能牵强的称为MVC 结构。\n\n而MVP 就不同了，Model，View，Presenter各司其职，互相搭配，实现了解耦，完全解放了Activity（或者是Fragment）。这就是MVP 的优势，代码结构更加清晰。可以这样说，同一个模块的实现，甚至允许几个人分工完成；假设有一个非常复杂的Activity，如果使用MVP 的模式开发；那么这个时候，定义好MVP的接口之后，就可以有人专门去做Model，另一个人专门去做View；再由一个人写Presenter的代码，当然这需要极强的代码规范和协作能力；但这在传统的MVC模式中根本是无法想象的，所有的东西都在一个类里，两个人一起改，有了冲突怎么玩/(ㄒoㄒ)/~~。\n\n**需求变更，不再是噩梦**\n\n假设现在有新的需求，产品经理认为下载失败后只有一个Toast提示太单调了（而且用户有可能错过了这Toast的显示，而误以为APP失去了响应），因此，现在希望在下载失败后弹出一个Dialog，可以重试下载任务。是想，如果代码使用传统的MVC 结构，恰巧这个代码不是你写的，或者说就是你写的，但是你已经忘记了具体的逻辑；那么为了实现这个需求你又得去重新捋一遍逻辑，到某个类的xxx行进行修改；但是如果使用MVP就不同了View接口已经定义好了showFailToast就是用来显示错误提示的；因此即便代码不是你写的，你都可以很快的找到，应该去哪里改；而省去很多时间。\n\n\n**更容易写单元测试**\n\n这个就不展开说了，总之写过单元测试的人应该都有这样的体会。\n\n#### 缺点####\n\nMVP这么好，也不是没有缺点。\n\n\n![](https://lc-mhke0kuv.cn-n1.lcfile.com/7e28a3b3f0bc414e469b.png)\n\n如图中所示，使用MVP 架构之后，多出了许多类；这是必然的；每一个View（Activity或Fragment）都至少需要各自的Model、Presenter和View接口，在加上他们各自的实现，也就是说每一个页面都会有6个java文件（算上Fragment或Activity，因为他就是View的实现），这样一个稍有点规模的APP，类就会变得异常的多，而每一个类的加载又会消耗资源；因此，相较于MVC，这算是MVP最大的缺点了吧。\n\n当然，对于这个问题我们可以通过泛型参数、抽象父类的方式，将一些公用的Model及Presenter抽象出来。这应该就是使用MVP架构的精髓了。\n\n\n## 最后##\n\n个人感觉，使用MVP 架构是利大于弊的；随着项目规模的增加，代码逻辑的清晰才是最重要的事情。况且Google官方也出推出了一系列关于[MVP的使用demo](https://github.com/googlesamples/android-architecture)。\n因此，这也是官方提倡大家使用的。凡事，有利必有弊；类数目的增长是无法避免的事情，因此如何使用泛型和抽象优化MVP 的结构就变成了我们用好\nMVP的关键了。\n\n当然，我们不能为了MVP而去MVP，如果项目结构不是很庞大，业务不是很复杂；那么传统的MVC 架构足以，而且也方便！\n\n****\n年前的最后一个工作日了，我居然写了一篇学习笔记；今天一定是上了假的班儿！明天回家过年，O(∩_∩)O哈哈哈~！每一个人，新年快乐！\n\n\n\n","tags":["mvp/mvc"],"categories":["Android 进阶"]},{"title":"仿知乎首页学习CoordinateLayout","url":"%2F2016%2F12%2F22%2F%E4%BB%BF%E7%9F%A5%E4%B9%8E%E9%A6%96%E9%A1%B5%E5%AD%A6%E4%B9%A0CoordinateLayout%E7%94%A8%E6%B3%95%2F","content":"\n\n### 前言###\n\n第一次接触CoordinateLayout的时候深深的被其炫酷的特效所吸引；想着什么时候在实际项目中可以使用一下，无奈实际项目因行业特点，并不需要使用到CoordinateLayout这么高端的交互体验；所以本着学习的态度，便用CoordinateLayout模仿了一下知乎首页效果，这也是现在掘金APP首页的效果；这种效果其实很友好，能让用户最大限度的使用到手机屏幕。\n\n\n好了，废话不多说，先看看模仿效果。\n\n<!--more-->\n\n\n![index](https://user-gold-cdn.xitu.io/2016/12/22/f9d16ce6e1191880092de3903be0e63f)\n\n\n![discovery](https://user-gold-cdn.xitu.io/2016/12/22/0fffb5a7fb23a754884ab7b13bb87c60)\n\n\n![message](https://user-gold-cdn.xitu.io/2016/12/22/bedd0f983f9217f3342c45094779718f)\n\n\n![userCenter](https://user-gold-cdn.xitu.io/2016/12/22/cce602916eb19ba376f1e429b96ceb6f)\n\n**这里用到的icon 大部分来源于[iconfont](http://www.iconfont.cn/)。**\n\n*使用模拟器截取gif貌似永远都是这样模糊不清*，有兴趣的同学可以点[github](https://github.com/REBOOTERS/ZhiHuIndex)查看源码，实际运行在手机上效果会比这里好一些。\n\n### 综述###\n\nCoordinateLayout是Android Design Support Library提供的一种布局方式。\n\n\n查看源码我们可以看到 CoordinateLayout继承自ViewGroup，是一个“超级强大”的FrameLayout，FrameLayout 相信大家都很熟悉，使用也很简单，FrameLayout可以说是让Android布局中有了“**层**”的概念，那么这个CoordinateLayout又有什么神奇之处呢，下面我们就学习一下。\n\n**Coordinate  按照字面意思理解，就是协调。它可以方便的实现布局内view协调**\n\n那么究竟是怎么个调节法呢，我们来看一下。\n\n### CoordinateLayout 使用###\n\n#### 结合Snackbar####\n\n关于CoordinateLayout最经典的例子就是其结合Snackbar的使用了。\n\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.design.widget.CoordinatorLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <android.support.design.widget.FloatingActionButton\n        android:id=\"@+id/fab\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"end|bottom\"\n        android:layout_margin=\"16dp\"\n        android:src=\"@drawable/ic_done\" />\n\n</android.support.design.widget.CoordinatorLayout>\n\n```\n\n\n``` java\n@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        findViewById(R.id.fab).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n\n                Snackbar.make(view,\"FAB\",Snackbar.LENGTH_LONG)\n                        .setAction(\"cancel\", new View.OnClickListener() {\n                            @Override\n                            public void onClick(View v) {\n                                \n                            }\n                        })\n                        .show();\n            }\n        });\n    }\n\n```\n****\n\n上面这份代码应该是很多人对CoordinateLayout的第一印象，这也是关于CoordinateLayout最直观的解释。\n\n这里实现的效果就是如上面第三幅动图message中那样，底部弹出一个SnackBar，FloatingActionButton自动上移；这就是所谓的协调，协调FloatingActionButton上移，不被顶部弹出的SnackBar所遮挡。\n\n这里如果没有使用CoordinateLayout作为根布局，而是使用LinearLayout或RelativeLayout等，如果FloatingActionButton距离底部太近，那么它将会被底部弹出的Snackbar所遮挡。\n\n#### 结合AppBarLayout使用####\n\n说到CoordinateLayout就不得不提这个AppBarLayout，他们俩简直就是天生一对，二者结合使用，那画面真是太美了，想想都觉得刺激。\n\n这里看一下我们模仿首页顶部搜索栏的代码：\n\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:id=\"@+id/coordinatorLayout\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".fragments.IndexFragment\">\n\n    <android.support.design.widget.AppBarLayout\n        android:id=\"@+id/index_app_bar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:theme=\"@style/AppTheme.AppBarOverlay\">\n\n        <RelativeLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"?attr/actionBarSize\"\n            android:background=\"@color/colorPrimary\"\n            app:layout_scrollFlags=\"scroll|enterAlways\">\n\n            <ImageView\n                android:id=\"@+id/live\"\n                android:layout_width=\"24dp\"\n                android:layout_height=\"24dp\"\n                android:layout_alignParentRight=\"true\"\n                android:layout_centerVertical=\"true\"\n                android:layout_marginRight=\"5dp\"\n                android:src=\"@drawable/live_button\" />\n\n            <RelativeLayout\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_margin=\"10dp\"\n                android:layout_toLeftOf=\"@id/live\"\n                android:background=\"@color/searchmenu\">\n\n                <ImageView\n                    android:id=\"@+id/search\"\n                    android:layout_width=\"24dp\"\n                    android:layout_height=\"24dp\"\n                    android:layout_centerVertical=\"true\"\n                    android:layout_marginLeft=\"10dp\"\n                    android:src=\"@drawable/ic_search\" />\n\n                <TextView\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"wrap_content\"\n                    android:layout_centerVertical=\"true\"\n                    android:layout_marginLeft=\"10dp\"\n                    android:layout_toRightOf=\"@id/search\"\n                    android:text=\"搜索话题、问题或人\"\n                    android:textSize=\"16sp\" />\n\n            </RelativeLayout>\n        </RelativeLayout>\n    </android.support.design.widget.AppBarLayout>\n\n        .......\n\n</android.support.design.widget.CoordinatorLayout>\n\n```\n***\n这里我们在AppBarLayout内部嵌套了一个RelativeLayout，在这个RelativeLayout中我们模仿了顶部的搜索栏的布局效果，这个很简单。这里最核心的东西就是\n\n``` xml\napp:layout_scrollFlags=\"scroll|enterAlways\"\n```\n\n这行代码。什么意思呢？这个app:layout_scrollFlags有下面几个值：\n\n* scroll: 所有想滚动出屏幕的view都需要设置这个flag， 没有设置这个flag的view将被固定在屏幕顶部。\n\n* enterAlways: 设置这个flag时，向下的滚动都会导致该view变为可见。\n\n* enterAlwaysCollapsed: 当你的视图已经设置minHeight属性又使用此标志时，你的视图只能已最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。\n\n* exitUntilCollapsed: 滚动退出屏幕，最后折叠在顶端。\n\n* snap: 视图在滚动时会有一种“就近原则”，怎么说呢，就是当视图展开时，如果滑动中展   开的内容超过视图的75%,那么视图依旧会保持展开；当视图处于关闭时，如果滑动中展开的部分小于视图的25%，那么视图会保持关闭。总的来说，就是会让动画有一种弹性的视觉效果。\n\n这里我们使用了scroll 和 enterAlways ，就很容易的实现了向下滑动时顶部隐藏，向下滑动时顶部出现的效果。\n\n#### 结合TabLayout使用####\n\n注意，这里所说的TabLayout是android.support.design.widget.TabLayout，不是很久以前的那个TabLayout。\n\n使用这个TabLayout可以产生一种滑动时tab 悬停的效果，这里我们模仿的时候，用于种种原因没能使用TabLayout的动态效果，只是简单的结合ViewPager使用了一下，第二个页面discovery就是使用TabLayout作为顶部的Indicator使用；这个很简单，就不展开说了；具体实现看查看源码。\n\n#### 结合CollapsingToolbarLayout使用####\n\n个人感觉，这是整个CoordinateLayout中最拉风的动画特效，主要是实现一种“折叠”的动画效果。我们在模仿个人中心的时候就是用到了这个功能：\n\n看一下个人中心的布局文件：\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <android.support.design.widget.AppBarLayout\n        android:id=\"@+id/appbar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"256dp\"\n        android:fitsSystemWindows=\"true\"\n        android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\">\n\n        <android.support.design.widget.CollapsingToolbarLayout\n            android:id=\"@+id/collapsing_toolbar\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            android:fitsSystemWindows=\"true\"\n            app:contentScrim=\"?attr/colorPrimary\"\n            app:expandedTitleMarginEnd=\"64dp\"\n            app:expandedTitleMarginStart=\"48dp\"\n            app:layout_scrollFlags=\"scroll|exitUntilCollapsed|snap\">\n\n            <RelativeLayout\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:background=\"@drawable/user_bg\"\n                app:layout_collapseMode=\"parallax\">\n\n                <de.hdodenhof.circleimageview.CircleImageView\n                    android:layout_width=\"68dp\"\n                    android:layout_height=\"68dp\"\n                    android:layout_centerInParent=\"true\"\n                    android:src=\"@drawable/profile\" />\n\n            </RelativeLayout>\n\n            <android.support.v7.widget.Toolbar\n                android:id=\"@+id/toolbar\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"?attr/actionBarSize\"\n                app:layout_collapseMode=\"pin\"\n                app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" />\n\n        </android.support.design.widget.CollapsingToolbarLayout>\n\n    </android.support.design.widget.AppBarLayout>\n\n    <android.support.v4.widget.NestedScrollView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        app:layout_behavior=\"@string/appbar_scrolling_view_behavior\">\n\n        <LinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"vertical\"\n            android:paddingTop=\"10dp\">\n\n            <ImageView\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:scaleType=\"fitStart\"\n                android:src=\"@drawable/fake\" />\n\n        </LinearLayout>\n\n    </android.support.v4.widget.NestedScrollView>\n\n    <android.support.design.widget.FloatingActionButton\n        android:id=\"@+id/btn\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"16dp\"\n        android:clickable=\"true\"\n        android:src=\"@drawable/ic_edit\"\n        app:layout_anchor=\"@id/appbar\"\n        app:layout_anchorGravity=\"bottom|right|end\" />\n\n</android.support.design.widget.CoordinatorLayout>\n```\n\n***\n\n* 首先，我们在AppBarLayout中嵌套一个CollapsingToolbarLayout，并指定其\n\n```\napp:layout_scrollFlags=\"scroll|exitUntilCollapsed|snap\"\n```\n这个属性前面介绍过了，这里三种属性结合就可实现滚动中“折叠视差”的效果了。\n\n* 接下来，我们又在CollapsingToolbarLayout放置了一个RelativeLayout。这个RelativeLayout有一个很重要的设置；\n\n```\napp:layout_collapseMode=\"parallax\"\n```\n这个layout_collapseMode就是用来设置整个RelativeLayout的折叠效果的，有两种取值，“pin”：固定模式，在折叠的时候最后固定在顶端；“parallax”：视差模式，在折叠的时候会有个视差折叠的效果。\n\n* 最后是Toolbar，可以看到Toolbar的collapseMode设置为pin，这样向上滑动时，当RelativeLayout的内容完全折叠后，Toolbar将显示在顶部；而向下滑动时，Toolbar将消失，而RelativeLayout的内容会动态的折叠展开，而且由于设置了snap，会有一种轻微的弹性效果。\n\n**这里需要注意，这个时候，我们需要将AppBarLayout的高度设置为固定值**\n\nCoordinatorLayout 还提供了一个 layout_anchor 的属性，连同 layout_anchorGravity 一起，可以用来放置与其他视图关联在一起的悬浮视图（如 FloatingActionButton）。\n\n这里如果我们将floatingActionButton设置为：\n\n```\nandroid:layout_gravity=\"bottom|right|end\"\n```\n\nFloatingActionButton将位于整个屏幕的右下角。\n\n### 使用细节###\n\n这里需要注意的是，使用AppBarLayout时，为了实现其滚动时的效果，在其下面必须有一个可滚动的View，并且需要为其设置app:layout_behavior属性。\n\n比如我们在结合结合CollapsingToolbarLayout使用时，\n在AppBarLayout的下面放置了一个NestedScrollView，并设置其app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"。\n\n而在其他页面，我们AppBarLayout的下面放置了ViewPager或者是FrameLayout都设置了相应的属性；具体可参考源码。\n\n### Behavior###\n\n上面我们提到了layout_behavior，这是个什么意思呢？\n\n这里就不得不说这个Behavior了，可以说Behavior是整个CoordinateLayout最核心的东西。还记得我们最开始的列子吗？FloatingActionButton会随着Snackbar的出现，自动的调节自己的位置，这是怎样的实现的呢？\n\n我们通过追踪查看 Snackbar 的 show() 这个方法，最终会在Snack的源码中找到如下实现：\n\n``` java\nfinal void showView() {\n        if (mView.getParent() == null) {\n            final ViewGroup.LayoutParams lp = mView.getLayoutParams();\n\n            if (lp instanceof CoordinatorLayout.LayoutParams) {\n                // If our LayoutParams are from a CoordinatorLayout, we'll setup our Behavior\n                final CoordinatorLayout.LayoutParams clp = (CoordinatorLayout.LayoutParams) lp;\n\n                final Behavior behavior = new Behavior();\n                behavior.setStartAlphaSwipeDistance(0.1f);\n                behavior.setEndAlphaSwipeDistance(0.6f);\n                behavior.setSwipeDirection(SwipeDismissBehavior.SWIPE_DIRECTION_START_TO_END);\n                behavior.setListener(new SwipeDismissBehavior.OnDismissListener() {\n                    @Override\n                    public void onDismiss(View view) {\n                        view.setVisibility(View.GONE);\n                        dispatchDismiss(Callback.DISMISS_EVENT_SWIPE);\n                    }\n\n                    @Override\n                    public void onDragStateChanged(int state) {\n                        switch (state) {\n                            case SwipeDismissBehavior.STATE_DRAGGING:\n                            case SwipeDismissBehavior.STATE_SETTLING:\n                                // If the view is being dragged or settling, cancel the timeout\n                                SnackbarManager.getInstance().cancelTimeout(mManagerCallback);\n                                break;\n                            case SwipeDismissBehavior.STATE_IDLE:\n                                // If the view has been released and is idle, restore the timeout\n                                SnackbarManager.getInstance().restoreTimeout(mManagerCallback);\n                                break;\n                        }\n                    }\n                });\n                clp.setBehavior(behavior);\n                // Also set the inset edge so that views can dodge the snackbar correctly\n                clp.insetEdge = Gravity.BOTTOM;\n            }\n\n            mTargetParent.addView(mView);\n        }\n\n        \n    ......\n        \n    }\n```\n\n***\n\n我们可以看到，当Snack执行show方法的时候，会生成一个Behavior对象，然后将这个对象set给CoordinateLayout，而CoordinateLayout会根据这个Behavior执行动作。这个方法下面省略的代码大体上就是一个Translation属性动画的实现，这里就不展开来说了。\n\n回到我们之前所说，我们需要为带有滚动属性的view设置layout_behavior这个属性，我们为其设置的值\n\n``` xml\napp:layout_behavior=\"@string/appbar_scrolling_view_behavior\"\n```\n\n```\n<string name=\"appbar_scrolling_view_behavior\" translatable=\"false\">android.support.design.widget.AppBarLayout$ScrollingViewBehavior</string>\n```\n***\n\n我们可以在AppBarLayout的源码中找到这个ScrollingViewBehavior，其最终也是继承自Behavior实现了特定的效果。\n\n现在或许你有疑问，这个神秘的Behavior到底是个什么鬼？\n\n#### Behavior 核心概念####\n\nBehavior 就是行为，他定义了View的行为。\n\nCoordinatorLayout的工作原理是搜索定义了CoordinatorLayout Behavior的子view，不管是通过在xml中使用app:layout_behavior标签还是通过在代码中对view类使用@DefaultBehavior修饰符来添加注解。当滚动发生的时候，CoordinatorLayout会尝试触发那些声明了依赖的子view。\n\nBehavior最基础的两个方法是：layoutDependsOn() 和onDependentViewChanged()；这两个方法的说明如下：\n\n``` java\n public boolean layoutDependsOn(CoordinatorLayout parent, T child, \n                                            View dependency) {\n    boolean result;\n    //返回false表示child不依赖dependency，ture表示依赖\n    return result;    \n}\n\n```\n\n``` java\n/**\n* 当dependency发生改变时（位置、宽高等），执行这个函数\n* 返回true表示child的位置或者是宽高要发生改变，否则就返回false\n*/\n@Override\npublic boolean onDependentViewChanged(CoordinatorLayout parent, T child, View dependency) {\n     //child要执行的具体动作\n        return true;\n}\n```\n***\n\n#### FloatingActionButton 的Behavior####\n\n我们用Android Studio查看FloatingActionButton的源码，会发现他包含了一个Behavior的注解：\n\n``` java\n@CoordinatorLayout.DefaultBehavior(FloatingActionButton.Behavior.class)\npublic class FloatingActionButton extends VisibilityAwareImageButton {\n.....\n}\n```\n***\n\n这里我们看一下FloatingActionButton的注解参数FloatingActionButton.Behavior.class 是怎样实现的。通过源码我们发现这个FloatingActionButton的Behavior继承自CoordinateLayout的Behavior，而且只实现了onDependentViewChanged方法，我们看一下：\n\n``` java\npublic static class Behavior extends CoordinatorLayout.Behavior<FloatingActionButton> {\n        private static final boolean AUTO_HIDE_DEFAULT = true;\n\n        private Rect mTmpRect;\n        private OnVisibilityChangedListener mInternalAutoHideListener;\n        private boolean mAutoHideEnabled;\n\n        public Behavior() {\n            super();\n            mAutoHideEnabled = AUTO_HIDE_DEFAULT;\n        }\n\n        public Behavior(Context context, AttributeSet attrs) {\n            super(context, attrs);\n            TypedArray a = context.obtainStyledAttributes(attrs,\n                    R.styleable.FloatingActionButton_Behavior_Layout);\n            mAutoHideEnabled = a.getBoolean(\n                    R.styleable.FloatingActionButton_Behavior_Layout_behavior_autoHide,\n                    AUTO_HIDE_DEFAULT);\n            a.recycle();\n        }\n\n        @Override\n        public boolean onDependentViewChanged(CoordinatorLayout parent, FloatingActionButton child,\n                View dependency) {\n            if (dependency instanceof AppBarLayout) {\n                // If we're depending on an AppBarLayout we will show/hide it automatically\n                // if the FAB is anchored to the AppBarLayout\n                updateFabVisibilityForAppBarLayout(parent, (AppBarLayout) dependency, child);\n            } else if (isBottomSheet(dependency)) {\n                updateFabVisibilityForBottomSheet(dependency, child);\n            }\n            return false;\n        }\n\n      \n    }\n```\n***\n可以看到他在onDependentViewChanged中直接判断了当前依赖的view。我们在模仿个人中心时，设置的FloatingActionButton的dependency就是AppBarLayout。而在这个方法中，他就会根据此执行特定的操作，也就是updateFabVisibilityForAppBarLayout 这个方法中的内容。\n\n#### 自定义Behavior####\n\n好了，说了这么多，下面我们说一下自定义Behavior。我们在模仿知乎底部用于切换Fragment的Tab时，便使用了一个自定义的Behavior。\n\n##### BottomViewBehavior #####\n``` java\npublic class BottomViewBehavior extends CoordinatorLayout.Behavior<View> {\n    public BottomViewBehavior(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    @Override\n    public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) {\n        return dependency instanceof AppBarLayout;\n    }\n\n    @Override\n    public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) {\n        float translationY = Math.abs(dependency.getTop());\n        child.setTranslationY(translationY);\n        return true;\n    }\n\n}\n```\n***\n\n这里我们的思路很简单，就是我们的View 要依赖于顶部的AppBarLayout，而用其距离屏幕的距离，作为底部（tab)相对于屏幕的距离，这样当顶部的AppBarLayout 滑动出屏幕时，底部也将做相应的位移，当然这里底部tab 的高度是需要做限制的，不能大于顶部AppBarLayout的高度。\n\n``` xml\n<LinearLayout \n        android:id=\"@+id/bottom\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"48dp\"\n        android:layout_gravity=\"bottom\"\n        android:background=\"@color/white\"\n        android:orientation=\"horizontal\"  \n      app:layout_behavior=\"home.smart.fly.zhihuindex.behavior.BottomViewBehavior\">\n\n        <RadioGroup\n            android:id=\"@+id/tabs_rg\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            android:orientation=\"horizontal\"\n            android:paddingLeft=\"5dp\"\n            android:paddingRight=\"5dp\">\n\n            <RadioButton\n                android:id=\"@+id/home_tab\"\n                android:layout_width=\"0dp\"\n                android:layout_height=\"match_parent\"\n                android:layout_weight=\"1\"\n                android:background=\"#00000000\"\n                android:button=\"@null\"\n                android:checked=\"true\"\n                android:drawableTop=\"@drawable/home_sel\"\n                android:gravity=\"center|bottom\"\n                android:paddingTop=\"5dp\" />\n\n            <RadioButton\n                android:id=\"@+id/explore_tab\"\n                android:layout_width=\"0dp\"\n                android:layout_height=\"match_parent\"\n                android:layout_weight=\"1\"\n                android:background=\"#00000000\"\n                android:button=\"@null\"\n                android:drawableTop=\"@drawable/explore_sel\"\n                android:gravity=\"center|bottom\"\n                android:paddingTop=\"5dp\" />\n\n            <RadioButton\n                android:id=\"@+id/notify_tab\"\n                android:layout_width=\"0dp\"\n                android:layout_height=\"match_parent\"\n                android:layout_weight=\"1\"\n                android:background=\"#00000000\"\n                android:button=\"@null\"\n                android:drawableTop=\"@drawable/notify_sel\"\n                android:gravity=\"center|bottom\"\n                android:paddingTop=\"5dp\" />\n\n            <RadioButton\n                android:id=\"@+id/user_tab\"\n                android:layout_width=\"0dp\"\n                android:layout_height=\"match_parent\"\n                android:layout_weight=\"1\"\n                android:background=\"#00000000\"\n                android:button=\"@null\"\n                android:drawableTop=\"@drawable/user_sel\"\n                android:gravity=\"center|bottom\"\n                android:paddingTop=\"5dp\" />\n        </RadioGroup>\n\n    </LinearLayout>\n```\n***\n\n我们将自定义的Behavior设置为这个bottom的app:layout_behavior就可以实现类似于知乎首页的那种效果了。\n\n##### FabBehavior #####\n\n这里我们用到的FloatingActionButton也可以自定义Behavior。\n\n```\npublic class FabBehavior extends CoordinatorLayout.Behavior<View> {\n    private static final Interpolator INTERPOLATOR = new FastOutSlowInInterpolator();\n    /**\n     * 控件距离coordinatorLayout底部距离\n     */\n    private float viewDistance;\n    private boolean aninmating;\n\n    public FabBehavior(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    @Override\n    public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) {\n\n        if(child.getVisibility() == View.VISIBLE&& viewDistance ==0){\n            //获取控件距离父布局（coordinatorLayout）底部距离\n            viewDistance =coordinatorLayout.getHeight()-child.getY();\n        }\n\n        return (nestedScrollAxes & ViewCompat.SCROLL_AXIS_VERTICAL) != 0;//判断是否竖直滚动\n    }\n\n    @Override\n    public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) {\n        //dy大于0是向上滚动 小于0是向下滚动\n\n        if (dy >=0&&!aninmating &&child.getVisibility()==View.VISIBLE) {\n            hide(child);\n        } else if (dy <0&&!aninmating &&child.getVisibility()==View.GONE) {\n            show(child);\n        }\n    }\n\n    private void hide(final View view) {\n        ViewPropertyAnimator animator = view.animate().translationY(viewDistance).setInterpolator(INTERPOLATOR).setDuration(200);\n\n        animator.setListener(new Animator.AnimatorListener() {\n            @Override\n            public void onAnimationStart(Animator animator) {\n                aninmating =true;\n            }\n\n            @Override\n            public void onAnimationEnd(Animator animator) {\n                view.setVisibility(View.GONE);\n                aninmating =false;\n            }\n\n            @Override\n            public void onAnimationCancel(Animator animator) {\n                show(view);\n            }\n\n            @Override\n            public void onAnimationRepeat(Animator animator) {\n            }\n        });\n        animator.start();\n    }\n\n    private void show(final View view) {\n        ViewPropertyAnimator animator = view.animate().translationY(0).setInterpolator(INTERPOLATOR).setDuration(200);\n        animator.setListener(new Animator.AnimatorListener() {\n            @Override\n            public void onAnimationStart(Animator animator) {\n                view.setVisibility(View.VISIBLE);\n                aninmating =true;\n            }\n\n            @Override\n            public void onAnimationEnd(Animator animator) {\n                aninmating =false;\n            }\n\n            @Override\n            public void onAnimationCancel(Animator animator) {\n                hide(view);\n            }\n\n            @Override\n            public void onAnimationRepeat(Animator animator) {\n            }\n        });\n        animator.start();\n    }\n}\n```\n***\n这里我们并没有去实现layoutDependsOn() 和onDependentViewChanged()这两个方法，前面我们看FloatingActionButton源码的时候知道他已经实现了onDependentViewChanged，我们这里我们从自身需求出发，就其滑动时的特性，做了一个滑动屏幕时FloatingActionButton快速从底部弹出或隐藏的Behavior。结合注释，代码很容易理解。\n\n好了，这就是所有关于CoordinateLayout的东西了，可以看到Behavior是这个控件的核心，也是最难理解的东西。自定义Behavior可以让我们的滑动动画有无限的可能。\n\n### 总结###\n\n关于这个模仿知乎首页的实现，最初真的只是想研究一下“首页”是怎么实现的。结果随着Demo的展开，加上轻微强迫症的作祟，便成了现在这个样子。\n\n到这里，不得不说一下，个人感觉，真正的知乎首页应该是没有使用CoordinateLayout；因为按现在这种Activity+n*Fragment 的套路，使用CoordinateLayout完全是给自己添乱，因为CoordinateLayout是滑动特性是无法嵌套使用的（或者说很复杂，我没发现），当我在最外层的Activity中使用了CoordinateLayout后，内部的Fragment中再次使用CoordinateLayout时，就会发生意想不到的各种bug，所以你会发现我们模拟的个人中心是有问题的，这里就是嵌套CoordinateLayout后外部的CoordinateLayout失效了，导致底部的Behavior也失效。\n\n不过在整个模仿的过程，也算是对CoordinateLayout的一次深入了解吧，顺便也对SwipeRefreshLayout的内容和Tween Animation的使用做了一次巩固。首页RecycleView item中仿照Toolbar的弹出菜单，真的是耗费了不少时间。\n\n***源码地址***\n\n好了，按照惯例再次给出[github](https://github.com/REBOOTERS/ZhiHuIndex)地址，欢迎star&fork。\n\n\n****\n\n## 后话##\n\n之前学习CoordinateLayout模仿知乎首页的效果，断断续续的大概用了一周时间；现在回过头来再看，其实关于CoordinateLayout的使用很简单，甚至有些无聊；因为app:layout_scrollFlags和 app:layout_collapseMode 这两个属性的可选值都也就那么几个；这其实是一种局限性，大家在应用中使用这个东西，产生的滑动视差效果几乎就是相似的，唯一就是颜色及主题风格的差异；这很容易让用户产生审美疲劳；唯一变化的就是Behavior，这是我们可以自定义的东西，因此这也是最难掌握的东西。知乎首页以及掘金首页的效果比我在这里实现的要更加柔和舒服，至于其是否使用了CoordinateLayout就不得而知了。\n\n\n\n\n\n\n\n\n","tags":["Android 动画"],"categories":["Android 进阶"]},{"title":"我们真的需要使用RxJava+Retrofit吗？","url":"%2F2016%2F12%2F12%2F%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8RxJava%2BRetrofit%E5%90%97%2F","content":"\n\n\n## 前言 ##\n\n可以说RxJava+Retrofit是整个2016年Android 开发圈内最受关注的的组合。各大Android论坛上有大量以RxJava+Retrofit+xxx 为标题的文章，此类文章也备受大家的关注。这个组合仿佛已经成为了Android开发的必备组件，项目里没使用这个组合好像自己都out了似的。\n\n平心而论，RxJava和Retrofit 相较于以往的各种框架（如 AsyncHttpClient，Volley等 )学习和使用起来会有一些难度；RxJava 强大而又庞大的操作符，Retrofit采用注解风格定义接口，都会让初学者花费不少功夫，绕不少圈子，踩大量的坑。既然这样，那么就会有人怀疑，我们真的需要学习RxJava和Retrofit吗？\n\n任意一款需要联网的APP，最典型的套路就是请求后端数据，解析数据进行UI更新；响应用户操作，再次请求数据，更新UI。这里我们就从最基础的网络请求出发，带着疑问，逐步了解一下Retrofit的前生今世，看一看RxJava和Retrofit的价值所在。\n\n<!--more-->\n\n## Android Http ##\n\n### 最基础的实现方式 ###\n\n初学Android开发时，还在上大学，那会儿还不知有AsyncHttpClient，Volley，OKHttp 这么方便的框架存在于这个世界上；一个简单的网络请求通常要写一大段代码。\n\n#### 使用HttpURLConnection实现网络请求#### \n\n\n``` java\nclass MyTask extends AsyncTask<String, Void, String> {\n\n        @Override\n        protected String doInBackground(String... params) {\n            InputStream mInputStream = null;\n            HttpURLConnection connection = getHttpUrlConnection(params[0]);\n            String result = \"\";\n            try {\n                connection.connect();\n                int statusCode = connection.getResponseCode();\n                String response = connection.getResponseMessage();\n                mInputStream = connection.getInputStream();\n                InputStreamReader inputStreamReader = new InputStreamReader(mInputStream);\n                BufferedReader reader = new BufferedReader(inputStreamReader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    sb.append(line + \"\\n\");\n                }\n\n                result = \"StatusCode: \" + statusCode + \"\\n\"\n                        + \"Response\" + response + \"\\n\"\n                        + sb.toString();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return result;\n        }\n\n        @Override\n        protected void onPostExecute(String s) {\n            super.onPostExecute(s);\n            tv.setText(s);\n        }\n    }\n\n    private HttpURLConnection getHttpUrlConnection(String url) {\n        HttpURLConnection connection = null;\n        try {\n            URL mUrl = new URL(url);\n            connection = (HttpURLConnection) mUrl.openConnection();\n            connection.setConnectTimeout(20000);\n            connection.setReadTimeout(40000);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json\");\n            connection.setRequestProperty(\"Accept\", \"application/json\");\n            connection.setRequestProperty(\"Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Length\", \"0\");\n\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return connection;\n    }\n```\n\n```java\nnew MyTask().execute(BASE_URL);\n```\n\n这段代码的逻辑很简单，就是将网络请求的结果显示在一个TextView上。很大一部分的内容都是在执行HttpURLConnection 相关的配置及初始化工作。\n\n记得第一次通过网络请求把数据显示的Android模拟器（那时候还是穷学生，买不起Android手机）的屏幕上时，虽然只是一大堆别人看不懂的json字符串，但是感觉自己就要上天了，现在想想真是。。。。。\n\n即便是这么长的一段代码，还没有包含网络请求异常的内容，如果加上网络请求失败处理的逻辑，将使得整个代码结构更加臃肿庞大。\n\n### 网络请求框架的涌现###\n\n一款联网的APP至少会有十几次的网络请求，更多的就无法估计了。因此，每一次的网络请求不可能像上面那样写。所以，我们需要封装，将一些固定的操作统一处理；当然已经有许多大神比我早想到了这个问题，便出现了许多对网络请求进行封装的库。\n\n- AsyncHttpClient（底层基于HttpClient）\n- afinal（FinalHttp，同样是基于HttpClient封装）\n- xUtils (基于afinal)\n- Volley（Google官方出品）\n- okHttp\n- NoHttp (个人开发)\n\n这里列出的几个库当中，个人使用AsyncHttpClient较多，AsyncHttpClient 的确非常好用，但是后来伴随着Android sdk 23 中HttpClient的废弃也逐渐被遗忘。\nafinal和xUtils 都没有在实际项目中没用过，不做评价。\n\nVolley作为Google官方在2013年I/O 大会上推出的库，相较于AsyncHttpClient 更强大。\n\n下面简单列举一个使用Volley进行get请求的demo。\n\n#### Volley 简单使用####\n\n添加依赖：\n\n```\ncompile 'com.mcxiaoke.volley:library:1.0.19'\n```\n\n``` java\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mContext = this;\n        queue = Volley.newRequestQueue(mContext);\n        setContentView(R.layout.activity_http_volley_demo);\n        tv = (TextView) findViewById(R.id.editText);\n\n        final StringRequest request = new StringRequest(Request.Method.GET, BASE_URL,\n                new ResponseSuccessListener(), new ResponseFailListener());\n        findViewById(R.id.volley).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                queue.add(request);\n            }\n        });\n\n    }\n\n    private class ResponseSuccessListener implements com.android.volley.Response.Listener<String> {\n\n        @Override\n        public void onResponse(String response) {\n            tv.setText(response);\n        }\n    }\n\n    private class ResponseFailListener implements Response.ErrorListener {\n\n        @Override\n        public void onErrorResponse(VolleyError error) {\n            Toast.makeText(mContext, error.toString(), Toast.LENGTH_SHORT).show();\n        }\n    }\n```\n\n\n\n这段代码和上面的功能一样，都是将网络请求的结果显示在TextView。但是通过Volley对http请求进行一次封装后，我们不再关注网络请求的具体细节，而是将重点放在了对请求结果的处理上；网络请求无论成功还是失败，我们都可以很多好的应对。\n\n而且在Volley中，异步网络请求的回调方法已然处于UI线程中，这样我们就可以直接在回调方法中进行UI更新了。\n\n可以说，使用Volley已经可以非常方便的处理Android 网络请求的相关内容了。既然如此，为什么还会有OKHttp和Retrofit的出现呢?他们的优势又在哪里呢？\n\n#### OKHttp 简单介绍####\n\nokHttp 是由square 推出的一个网络请求库，包括Retrofit也是由其开发，这里为square点个赞。\n\n使用之前加入依赖\n\n```\n    compile 'com.squareup.okhttp3:okhttp:3.4.1'\n    compile 'com.squareup.okio:okio:1.11.0'\n```\n\n**okHttp 网络请求实现**\n\n\n\n```\nfindViewById(R.id.get).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                tv.setText(\"\");\n                loading.setVisibility(View.VISIBLE);\n                client = new OkHttpClient();\n                Request.Builder builder = new Request.Builder()\n                        .url(BASE_URL)\n                        .method(\"GET\", null);\n\n                request = builder.build();\n                Call mCall = client.newCall(request);\n                mCall.enqueue(new MyCallback());\n            }\n        });\n\nprivate class MyCallback implements Callback {\n\n        @Override\n        public void onFailure(Call call, IOException e) {\n            Message msg = new Message();\n            msg.what = 100;\n            msg.obj = e;\n            handler.sendMessage(msg);\n        }\n\n        @Override\n        public void onResponse(Call call, Response response) throws IOException {\n            Message msg = new Message();\n            msg.what = 200;\n            msg.obj = response.body().string();\n            handler.sendMessage(msg);\n        }\n    }\n\nclass MyHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n            loading.setVisibility(View.GONE);\n            switch (msg.what) {\n                case 100:\n                    Object e = msg.obj;\n                    Toast.makeText(mContext, e.toString(), Toast.LENGTH_SHORT).show();\n                    break;\n                case 200:\n                    String response = (String) msg.obj;\n                    tv.setText(response);\n                    break;\n                case 300:\n                    int percent = msg.arg1;\n                    Log.e(\"llll\", \"the percent is \" + percent);\n                    if (percent < 100) {\n                        progressDialog.setProgress(percent);\n                    } else {\n                        progressDialog.dismiss();\n                        Glide.with(mContext).load(FILE_PATH).into(imageView);\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n```\n\n\n**这里必须了解的是，okHttp的回调方法，并不处于UI 线程中，对网络请求结果如果涉及UI 线程的操作，需要使用Handler**。这么看来，okHttp 貌似反而不如Volley了。其实不然，okhttp的封装套路和Volley，AsyncHttp不是一个级别的，不能和后两者作比较，okhttp 和HttpClient、HttpUriConneciton 才是一个级别的产物，相较于这两者，okhttp显然强大了许多。\n\n所以，OKHttp不仅仅可以用于Android开发，Java开发也是OK的。\n\n## Retrofit ##\n\n> A type-safe HTTP client for Android and Java\n> \n> 一个针对Android和Java类型安全的http客户端\n\n上面这句话，就是Squire对Retrofit的说明，言简意赅。Retrofit其实是对okhttp 做了进一步的封装，有了okhttp 的基础，使用Retrofit会很容易。\n\n下面就来看看，使用Retrofit做网络请求又是一种怎样的体验。\n\n这里为了方便我们使用\n\n>https://api.github.com/\n\n作为网络请求的接口基地址\n\n使用之前加入依赖：\n\n``` \ncompile 'com.squareup.retrofit2:retrofit:2.1.0'\n\n```\n\n**定义接口**\n\n``` java\npublic interface GithubService {\n\n    @GET(\"users/{user}\")\n    Call<ResponseBody> getUserString(@Path(\"user\") String user);\n\n}\n```\n\n这里我们使用http中的get 方法获取users这个接口下，当前user的具体信息，参数为当前user名。返回内容为Http请求的ResponseBody。\n\n**Retrofit 返回ResponseBody**\n\n```java\nprivate void SimpleRetrofit() {\n        OkHttpClient.Builder httpClient = new OkHttpClient.Builder();\n        Retrofit.Builder builder = new Retrofit.Builder()\n                .baseUrl(BASE_URL);\n        Retrofit retrofit = builder.client(httpClient.build()).build();\n        GithubService simpleService = retrofit.create(GithubService.class);\n        Call<ResponseBody> call = simpleService.getUserString(name);\n        call.enqueue(new Callback<ResponseBody>() {\n            @Override\n            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {\n                loading.dismiss();\n                try {\n                    String result = response.body().string();\n                    Gson gson = new Gson();\n                    GithubUserBean bean = gson.fromJson(result, GithubUserBean.class);\n                    setUserView(bean);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            @Override\n            public void onFailure(Call<ResponseBody> call, Throwable t) {\n                loading.dismiss();\n            }\n        });\n    }\n\nprivate void setUserView(GithubUserBean user) {\n        if (user != null) {\n            viewShell.removeAllViews();\n            View view = LayoutInflater.from(mContext).inflate(R.layout.user_item_layout, null);\n            TextView title = (TextView) view.findViewById(R.id.title);\n            TextView id = (TextView) view.findViewById(R.id.userId);\n            TextView creteaTime = (TextView) view.findViewById(R.id.createTime);\n            TextView updateTime = (TextView) view.findViewById(R.id.updateTime);\n            TextView bio = (TextView) view.findViewById(R.id.bio);\n            ImageView avatar = (ImageView) view.findViewById(R.id.avatar);\n\n            title.setText(\"Name: \" + user.getLogin());\n            bio.setText(\"Bio: \" + user.getBio());\n            id.setText(\"Id: \" + String.valueOf(user.getId()));\n            creteaTime.setText(\"createTime: \" + user.getCreated_at());\n            updateTime.setText(\"updateTime: \" + user.getUpdated_at());\n            Glide.with(mContext).load(user.getAvatar_url()).into(avatar);\n\n            viewShell.addView(view);\n        } else {\n            Toast.makeText(mContext, \"result is null\", Toast.LENGTH_SHORT).show();\n        }\n    }\n```\n\n**GitHubUserBean** 为网络请求结果json数据所对应的实体类。\n\n通过这段代码，我们在最终的回调方法里可以友好的处理请求结果，失败时onFailure方法执行。成功时，onResponse方法执行，我们在这里用Gson解析返回的数据，并进行UI更新操作（setUserView(bean))，\n\n这里我们这样做有些啰嗦，Gson转换的方式都是类似，唯一不同的只是每次网络请求结果对应的实体类；因此我们可以借助强大的Retrofit帮助我们完成Gson转换的步骤。当然，如果在你所在的开发环境中，接口返回的并不是json格式的数据，也没有问题的。\n\n\n![convert](https://lc-mhke0kuv.cn-n1.lcfile.com/12c4ecd081399a08d6ca.png)\n\n上图是Retrofit官网对可转换类型给出的介绍。有这么多种，当然了如果你们家服务器返回的数据格式比较神奇，你也可以自定义转换类。\n\n好了，言归正传，这里还是以Json 格式数据为例。\n\n添加依赖：\n\n```\ncompile 'com.squareup.retrofit2:converter-gson:2.1.0'\n```\n\n**注意这里converter-gson 的版本号，要和之前Retrofit的版本号保持一致。**\n\n我们重新定义接口：\n\n``` java\npublic interface GithubService {\n    @GET(\"users/{user}\")\n    Call<GithubUserBean> getUser(@Path(\"user\") String user);\n\n}\n```\n这里我们用GithubUserBean取代ResponseBody，直接将其作为返回类型。\n\n**Retrofit 返回对象**\n\n``` java\nprivate void LazyRetrofit() {\n        OkHttpClient.Builder httpClient = new OkHttpClient.Builder();\n        Retrofit.Builder builder = new Retrofit.Builder()\n                .baseUrl(BASE_URL)\n                .addConverterFactory(GsonConverterFactory.create());\n        Retrofit retrofit = builder.client(httpClient.build()).build();\n        GithubService service = retrofit.create(GithubService.class);\n        Call<GithubUserBean> call = service.getUser(name);\n        call.enqueue(new Callback<GithubUserBean>() {\n            @Override\n            public void onResponse(Call<GithubUserBean> call, Response<GithubUserBean> response) {\n                GithubUserBean bean = response.body();\n                setUserView(bean);\n                loading.dismiss();\n            }\n\n            @Override\n            public void onFailure(Call<GithubUserBean> call, Throwable t) {\n                loading.dismiss();\n            }\n        });\n    }\n```\n\n这里的实现方式和上面基本相似，只是多了一行\n\n```java\n.addConverterFactory(GsonConverterFactory.create());\n```\n\n这样，我们在onResponse中获得就是对象，不再需要做额外的转换工作，可以直接使用。\n\n**Retrofit 简单封装**\n\n这里我们可以看到，Retrofit使用有着一定的套路，所以我们可以将Retrofit初始化相关得内容做一次简单的封装。\n\n``` java\npublic class GenServiceUtil {\n    private static final String BASE_URL = \"https://api.github.com/\";\n\n    private static OkHttpClient.Builder httpClient = new OkHttpClient.Builder();\n\n    private static Retrofit.Builder builder = new Retrofit.Builder()\n            .baseUrl(BASE_URL)\n            .addConverterFactory(GsonConverterFactory.create());\n\n    private static Retrofit retrofit = builder.client(httpClient.build()).build();\n\n    public static <S> S createService(Class<S> serviceClass) {\n        return retrofit.create(serviceClass);\n    }\n\n}\n\nprivate void EasyRetrofit() {\n        GithubService service = GenServiceUtil.createService(GithubService.class);\n        Call<GithubUserBean> call = service.getUser(name);\n        call.enqueue(new Callback<GithubUserBean>() {\n            @Override\n            public void onResponse(Call<GithubUserBean> call, Response<GithubUserBean> response) {\n                GithubUserBean bean = response.body();\n                loading.dismiss();\n                setUserView(bean);\n            }\n\n            @Override\n            public void onFailure(Call<GithubUserBean> call, Throwable t) {\n                loading.dismiss();\n            }\n        });\n    }\n\n```\n\n我们只需传入定义好的借口，会使代码简介许多。看到这里可以发现，Retrofit的确很厉害，那为什么又要将他和RxJava结合在一起呢？下面我们就来看看。\n\n## RxJava+Retrofit ##\n\n关于什么是RxJava，这里不再赘述，不了解的看以看看[这里](http://www.jianshu.com/p/ce9574619697)。这里我们就看看将RxJava 和我们之前的内容结合在一起会有怎样的效果。\n\n首先，加入依赖\n\n```\n    compile 'io.reactivex:rxjava:1.1.7'\n    compile 'io.reactivex:rxandroid:1.2.1'\n```\n\n### RxJava+Retrofit 实现###\n\n``` java\nprivate void RxRetrofit() {\n        GithubService service = GenServiceUtil.createService(GithubService.class);\n        final Call<GithubUserBean> call = service.getUser(name);\n        final Observable myObserable = Observable.create(new Observable.OnSubscribe<GithubUserBean>() {\n            @Override\n            public void call(Subscriber<? super GithubUserBean> subscriber) {\n                Response<GithubUserBean> bean = null;\n                try {\n                    bean = call.execute();\n                    subscriber.onNext(bean.body());\n\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    subscriber.onError(e);\n                }\n\n                subscriber.onCompleted();\n            }\n        });\n\n        myObserable\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .map(new Func1<GithubUserBean, GithubUserBean>() {\n                    @Override\n                    public GithubUserBean call(GithubUserBean o) {\n                        if (TextUtils.isEmpty(o.getBio())) {\n                            o.setBio(\"nothing !\");\n                        }\n                        return o;\n                    }\n                })\n                .subscribe(new Subscriber<GithubUserBean>() {\n                    @Override\n                    public void onCompleted() {\n                        loading.dismiss();\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        loading.dismiss();\n                    }\n\n                    @Override\n                    public void onNext(GithubUserBean o) {\n                        setUserView(o);\n                    }\n                });\n\n    }\n```\n\n这里有几点需要注意：\n\n- RxJava 本身最大的特定就是异步，因此这里我们Retrofit执行网络请求的时候，使用了execute（同步请求），而不再是enqueue。\n- RxJava 可以使用subscribeOn和observeOn完美处理Observeable和Subscribe的执行线程问题。\n- 这里使用RxJava中map操作符，对返回内容中的为null或“” 的对象做了简单的处理。\n\n我们引入RxJava实现了同样的功能，却使得代码量增加了很多。不禁要问，RxJava的价值到底在哪里呢？\n\n### RxJava + Retrofit 到底好在哪里 ###\n\n好了，为了说明为题，我们添加一个接口\n\n``` java\npublic interface GithubService {\n\n    @GET(\"users/{user}\")\n    Call<GithubUserBean> getUser(@Path(\"user\") String user);\n\n    @GET(\"users/{user}/followers\")Observable<List<UserFollowerBean>> followers(@Path(\"user\") String usr);\n\n}\n```\n当然这里依旧需要添加依赖：\n\n```\ncompile 'com.squareup.retrofit2:adapter-rxjava:2.1.0'\n````\n同时在Service的封装方法中添加\n\n```\n.addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n```\n\n这样，RxJava就和Retrofit完美的关联在了一起。\n\n我们在接口中，定义followers()方法直接返回了Observable，因为Observable是RxJava的源头，而且Retrofit可以很好的支持RxJava，这样就非常方便了。\n\n\n```java\n    private void RxRetrofitList() {\n        GithubService service = GenServiceUtil.createService(GithubService.class);\n        Observable<List<UserFollowerBean>> myObserve = service.followers(name);\n        myObserve\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Subscriber<List<UserFollowerBean>>() {\n                    @Override\n                    public void onCompleted() {\n                        loading.dismiss();\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        loading.dismiss();\n                        e.printStackTrace();\n                    }\n\n                    @Override\n                    public void onNext(List<UserFollowerBean> userFollowerBeen) {\n                        setFollowersView(userFollowerBeen);\n                    }\n                });\n\n    }\n```\n\n\n\n在接口中返回的内容就是Observable，因此不用再像之前一样单独定义Observable；在onNext 方法中，接收到返回的对象，更新UI。 这里如果我们不使用RxJava,单独使用Retrofit实现这个过程是没有任何问题的； RxJava看似没有价值；但是假设现在出现如下之一的情景\n\n- 需要对返回的userFollowerBeen 这个list 进行按用户名从小到大的排序\n- 需要对返回的userFollowerBeen 这个list 进行按用户ID从小到大的排序\n- 如果返回的userFollowerBeen 这个list 中，某一项的头像地址为空，则不显示该项\n\n.....\n\n这种情景在实际开发中太常见了，试想如果没有RxJava；那么每一次需求的变更都意味着我们需要去修改setFollowersView这个方法，需求一旦变更，就去修改这个方法，这样会不可避免的产生各种bug。那有没有办法不去修改这个方法呢？这个时候，就需要强大的RxJava了。\n\n这里我们就看看如何在不修改setFollowersView的前提下，实现对用户名从小到大的排序：\n\n```java\n    private void RxRetrofitList() {\n        GithubService service = GenServiceUtil.createService(GithubService.class);\n        Observable<List<UserFollowerBean>> myObserve = service.followers(name);\n        myObserve\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .map(new Func1<List<UserFollowerBean>, List<UserFollowerBean>>() {\n                    @Override\n                    public List<UserFollowerBean> call(List<UserFollowerBean> userFollowerBeen) {\n                        for (UserFollowerBean bean : userFollowerBeen) {\n                            String name = \"\";\n                            name = bean.getLogin().substring(0, 1).toUpperCase() + bean.getLogin().substring(1, bean.getLogin().length());\n                            bean.setLogin(name);\n                        }\n                        return userFollowerBeen;\n                    }\n                })\n                .map(new Func1<List<UserFollowerBean>, List<UserFollowerBean>>() {\n                    @Override\n                    public List<UserFollowerBean> call(List<UserFollowerBean> userFollowerBean) {\n                        Collections.sort(userFollowerBean, new Comparator<UserFollowerBean>() {\n                            @Override\n                            public int compare(UserFollowerBean o1, UserFollowerBean o2) {\n                                return o1.getLogin().compareTo(o2.getLogin());\n                            }\n                        });\n                        return userFollowerBean;\n                    }\n                })\n                .subscribe(new Subscriber<List<UserFollowerBean>>() {\n                    @Override\n                    public void onCompleted() {\n                        loading.dismiss();\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        loading.dismiss();\n                        e.printStackTrace();\n                    }\n\n                    @Override\n                    public void onNext(List<UserFollowerBean> userFollowerBeen) {\n                        setFollowersView(userFollowerBeen);\n                    }\n                });\n\n    }\n```\n\n*RxJava 链式风格的代码*\n\n**在代码中我们使用RxJava的map 操作符，对返回数据做了两次处理，首先将所有用户名的首字母转换为大写字母；然后对整个list按照用户名从小到大排序。因为用户名中同时包含以大小写字母打头的内容，所以为了方便，我们进行了一次转换大写的操作。**\n\n\n同样是随着需求变更，修改代码；但是你会发现，使用RxJava的方式，会降低出现bug的概率，而且就算是不同的人去改，也会比较方便维护。\n\n看到了吧，这就是RxJava的优点，当然这个例子也只是冰山一角。这里提到的map操作符只是RxJava庞大操作符集合中的一员，更特别的是，RxJava的操作符还是可以自定义的，这样让我们的代码有了无限的可能；RxJava的存在不仅仅在于网络请求，可以用在别的方面；RxJava其实是体现了一种思路，所有对数据的操作都在流上完成，将最终的结果返回给观察者。**同时，如果返回的followers 列表有任何异常，RxJava的onError 方法会执行，这就方便我们去处理异常数据了。**\n\n## 总结##\n\n通篇通过对Android 网络请求各种实现的总结，可以看到 相对于Volley，AsyncHttpClient 等库，RxJava+Retrofit 的优势并非特别显著；在执行效率及功能上并无大的亮点；对Volley进行良好的封装同样可以实现类似Retrofit自动转Gson的功能；RxJava+Retrofit 结合会让我们写代码的方式更加有条理，虽然代码量会增多，但逻辑的清晰才是最重要的不是吗？所以，RxJava+Retrofit 组合不失为一种好的选择。\n\n所以，赶紧拥抱RxJava+Retrofit吧！\n\n***\n\n文中所有源码地址[github](https://github.com/REBOOTERS/My-MVP)\n\n","tags":["RxJava，Retrofit"],"categories":["Android 进阶，Android 三方框架"]},{"title":"Android 动画总结","url":"%2F2016%2F10%2F19%2FAndroid%20%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93%2F","content":"\n\n在日常的Android开发中，经常会使用到动画，这里就对Android开发中的动画做一下总结。\n\n## Android 动画分类\n\n总的来说，Android动画可以分为两类，最初的**传统动画**和Android3.0 之后出现的**属性动画**；\n传统动画又包括 帧动画（Frame Animation）和补间动画（Tweened Animation）。\n\n\n## 传统动画\n### 帧动画\n\n帧动画是最容易实现的一种动画，这种动画更多的依赖于完善的UI资源，他的原理就是将一张张单独的图片连贯的进行播放，\n从而在视觉上产生一种动画的效果；有点类似于某些软件制作gif动画的方式。\n\n\n\n![frame.gif](http://upload-images.jianshu.io/upload_images/1115031-b52487cb6b97f911.gif?imageMogr2/auto-orient/strip)\n\n如上图中的京东加载动画，代码要做的事情就是把一幅幅的图片按顺序显示，造成动画的视觉效果。\n\n<!--more-->\n\n**京东动画实现**\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item\n        android:drawable=\"@drawable/a_0\"\n        android:duration=\"100\" />\n    <item\n        android:drawable=\"@drawable/a_1\"\n        android:duration=\"100\" />\n    <item\n        android:drawable=\"@drawable/a_2\"\n        android:duration=\"100\" />\n</animation-list>\n```\n```\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_frame_animation);\n        ImageView animationImg1 = (ImageView) findViewById(R.id.animation1);\n        animationImg1.setImageResource(R.drawable.frame_anim1);\n        AnimationDrawable animationDrawable1 = (AnimationDrawable) animationImg1.getDrawable();\n        animationDrawable1.start();\n    }\n```\n*可以说，图片资源决定了这种方式可以实现怎样的动画*\n\n*在有些代码中，我们还会看到android：oneshot=\"false\" ，这个oneshot 的含义就是动画执行一次（true）还是循环执行多次。*\n\n这里其他几个动画实现方式都是一样，无非就是图片资源的差异。\n\n### 补间动画\n\n补间动画又可以分为四种形式，分别是 **alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）**。\n补间动画的实现，一般会采用xml 文件的形式；代码会更容易书写和阅读，同时也更容易复用。\n\n#### XML 实现\n\n首先，在res/anim/ 文件夹下定义如下的动画实现方式\n\n**alpha_anim.xml 动画实现**\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"1000\"\n    android:fromAlpha=\"1.0\"\n    android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"\n    android:toAlpha=\"0.0\" />\n```\n**scale.xml 动画实现**\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<scale xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"1000\"\n    android:fromXScale=\"0.0\"\n    android:fromYScale=\"0.0\"\n    android:pivotX=\"50%\"\n    android:pivotY=\"50%\"\n    android:toXScale=\"1.0\"\n    android:toYScale=\"1.0\"/>\n```\n然后，在Activity中 \n\n```\nAnimation animation = AnimationUtils.loadAnimation(mContext, R.anim.alpha_anim);\nimg = (ImageView) findViewById(R.id.img);\nimg.startAnimation(animation);\n```\n这样就可以实现ImageView alpha 透明变化的动画效果。\n\n也可以使用set 标签将多个动画组合（代码源自Android SDK API）\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:interpolator=\"@[package:]anim/interpolator_resource\"\n    android:shareInterpolator=[\"true\" | \"false\"] >\n    <alpha\n        android:fromAlpha=\"float\"\n        android:toAlpha=\"float\" />\n    <scale\n        android:fromXScale=\"float\"\n        android:toXScale=\"float\"\n        android:fromYScale=\"float\"\n        android:toYScale=\"float\"\n        android:pivotX=\"float\"\n        android:pivotY=\"float\" />\n    <translate\n        android:fromXDelta=\"float\"\n        android:toXDelta=\"float\"\n        android:fromYDelta=\"float\"\n        android:toYDelta=\"float\" />\n    <rotate\n        android:fromDegrees=\"float\"\n        android:toDegrees=\"float\"\n        android:pivotX=\"float\"\n        android:pivotY=\"float\" />\n    <set>\n        ...\n    </set>\n</set>\n```\n可以看到组合动画是可以嵌套使用的。\n\n各个动画属性的含义结合动画自身的特点应该很好理解，就不一一阐述了；这里主要说一下**interpolator** 和 **pivot**。\n\n>Interpolator 主要作用是可以控制动画的变化速率 ，就是动画进行的快慢节奏。\n\nAndroid 系统已经为我们提供了一些Interpolator ，比如 accelerate_decelerate_interpolator，accelerate_interpolator等。更多的interpolator 及其含义可以在Android SDK 中查看。同时这个Interpolator也是可以自定义的，这个后面还会提到。\n\n\n>pivot 决定了当前动画执行的参考位置\n\npivot 这个属性主要是在translate 和 scale 动画中，这两种动画都牵扯到view 的“物理位置“发生变化，所以需要一个参考点。而pivotX和pivotY就共同决定了这个点；它的值可以是float或者是百分比数值。\n\n\n我们以pivotX为例，\n\n|pivotX取值|含义|\n|---|:-----:|\n|10|距离动画所在view自身左边缘10像素|\n|10%|距离动画所在view自身左边缘 的距离是整个view宽度的10%|\n|10%p|距离动画所在view父控件左边缘的距离是整个view宽度的10%|\n\npivotY 也是相同的原理，只不过变成的纵向的位置。如果还是不明白可以参考[源码](https://github.com/REBOOTERS/AndroidAnimationExercise)，在Tweened Animation中结合seekbar的滑动观察rotate的变化理解。\n\n\n\n![rotate1.gif](http://upload-images.jianshu.io/upload_images/1115031-743288fa3be134ea.gif?imageMogr2/auto-orient/strip)\n\n#### Java Code  实现\n\n有时候，动画的属性值可能需要动态的调整，这个时候使用xml 就不合适了，需要使用java代码实现\n\n```\nprivate void RotateAnimation() {\n        animation = new RotateAnimation(-deValue, deValue, Animation.RELATIVE_TO_SELF,\n                pxValue, Animation.RELATIVE_TO_SELF, pyValue);\n        animation.setDuration(timeValue);\n\n        if (keep.isChecked()) {\n            animation.setFillAfter(true);\n        } else {\n            animation.setFillAfter(false);\n        }\n        if (loop.isChecked()) {\n            animation.setRepeatCount(-1);\n        } else {\n            animation.setRepeatCount(0);\n        }\n\n        if (reverse.isChecked()) {\n            animation.setRepeatMode(Animation.REVERSE);\n        } else {\n            animation.setRepeatMode(Animation.RESTART);\n        }\n        img.startAnimation(animation);\n    }\n```\n**这里animation.setFillAfter决定了动画在播放结束时是否保持最终的状态；animation.setRepeatCount和animation.setRepeatMode 决定了动画的重复次数及重复方式，具体细节可查看源码理解。**\n\n好了，传统动画的内容就说到这里了。\n\n\n## 属性动画\n\n属性动画，顾名思义它是对于对象属性的动画。因此，所有补间动画的内容，都可以通过属性动画实现。\n\n### 属性动画入门\n\n首先我们来看看如何用属性动画实现上面补间动画的效果\n\n```\n    private void RotateAnimation() {\n        ObjectAnimator anim = ObjectAnimator.ofFloat(myView, \"rotation\", 0f, 360f);\n        anim.setDuration(1000);\n        anim.start();\n    }\n\n    private void AlpahAnimation() {\n        ObjectAnimator anim = ObjectAnimator.ofFloat(myView, \"alpha\", 1.0f, 0.8f, 0.6f, 0.4f, 0.2f, 0.0f);\n        anim.setRepeatCount(-1);\n        anim.setRepeatMode(ObjectAnimator.REVERSE);\n        anim.setDuration(2000);\n        anim.start();\n    }\n```\n这两个方法用属性动画的方式分别实现了旋转动画和淡入淡出动画，其中setDuration、setRepeatMode及setRepeatCount和补间动画中的概念是一样的。\n\n可以看到，属性动画貌似强大了许多，实现很方便，同时动画可变化的值也有了更多的选择，动画所能呈现的细节也更多。\n\n当然属性动画也是可以组合实现的\n\n```\n                ObjectAnimator alphaAnim = ObjectAnimator.ofFloat(myView, \"alpha\", 1.0f, 0.5f, 0.8f, 1.0f);\n                ObjectAnimator scaleXAnim = ObjectAnimator.ofFloat(myView, \"scaleX\", 0.0f, 1.0f);\n                ObjectAnimator scaleYAnim = ObjectAnimator.ofFloat(myView, \"scaleY\", 0.0f, 2.0f);\n                ObjectAnimator rotateAnim = ObjectAnimator.ofFloat(myView, \"rotation\", 0, 360);\n                ObjectAnimator transXAnim = ObjectAnimator.ofFloat(myView, \"translationX\", 100, 400);\n                ObjectAnimator transYAnim = ObjectAnimator.ofFloat(myView, \"tranlsationY\", 100, 750);\n                AnimatorSet set = new AnimatorSet();\n                set.playTogether(alphaAnim, scaleXAnim, scaleYAnim, rotateAnim, transXAnim, transYAnim);\n//                set.playSequentially(alphaAnim, scaleXAnim, scaleYAnim, rotateAnim, transXAnim, transYAnim);\n                set.setDuration(3000);\n                set.start();\n```\n可以看到这些动画可以同时播放，或者是按序播放。\n\n### 属性动画核心原理\n\n在上面实现属性动画的时候，我们反复的使用到了ObjectAnimator  这个类，这个类继承自ValueAnimator，使用这个类可以对任意对象的**任意属性**进行动画操作。而ValueAnimator是整个属性动画机制当中最核心的一个类；这点从下面的图片也可以看出。\n\n\n![valueanimator.png](http://upload-images.jianshu.io/upload_images/1115031-80301bbb0ae884b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n属性动画核心原理，此图来自于Android SDK API 文档。\n\n>属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等。\n\n从上图我们可以了解到，通过duration、startPropertyValue和endPropertyValue 等值，我们就可以定义动画运行时长，初始值和结束值。然后通过start方法开始动画。\n那么ValueAnimator 到底是怎样实现从初始值平滑过渡到结束值的呢？这个就是由TypeEvaluator 和TimeInterpolator 共同决定的。\n\n具体来说，**TypeEvaluator 决定了动画如何从初始值过渡到结束值。**\n**TimeInterpolator 决定了动画从初始值过渡到结束值的节奏。**\n\n说的通俗一点，你每天早晨出门去公司上班，TypeEvaluator决定了你是坐公交、坐地铁还是骑车；而当你决定骑车后，TimeInterpolator决定了你一路上骑行的方式，你可以匀速的一路骑到公司，你也可以前半程骑得飞快，后半程骑得慢悠悠。\n\n如果，还是不理解，那么就看下面的代码吧。首先看一下下面的这两个gif动画，一个小球在屏幕上以 y=sin(x) 的数学函数轨迹运行，同时小球的颜色和半径也发生着变化，可以发现，两幅图动画变化的节奏也是不一样的。\n\n\n\n![anim1.gif](http://upload-images.jianshu.io/upload_images/1115031-741c714c3ef5fa84.gif?imageMogr2/auto-orient/strip)\n\n\n![anim2.gif](http://upload-images.jianshu.io/upload_images/1115031-dbbb2e4aca44b0e7.gif?imageMogr2/auto-orient/strip)\n\n*如果不考虑属性动画，这样的一个动画纯粹的使用Canvas+Handler的方式绘制也是有可能实现的。但是会复杂很多，而且加上各种线程，会带来很多意想不到的问题。*\n\n这里就通过自定义属性动画的方式看看这个动画是如何实现的。\n\n### 属性动画自定义实现\n这个动画最关键的三点就是 运动轨迹、小球半径及颜色的变化；我们就从这三个方面展开。最后我们在结合Interpolator说一下TimeInterpolator的意义。\n\n##### 用TypeEvaluator 确定运动轨迹\n\n前面说了，TypeEvaluator决定了动画如何从初始值过渡到结束值。这个TypeEvaluator是个接口，我们可以实现这个接口。\n\n```\npublic class PointSinEvaluator implements TypeEvaluator {\n\n    @Override\n    public Object evaluate(float fraction, Object startValue, Object endValue) {\n        Point startPoint = (Point) startValue;\n        Point endPoint = (Point) endValue;\n        float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());\n\n        float y = (float) (Math.sin(x * Math.PI / 180) * 100) + endPoint.getY() / 2;\n        Point point = new Point(x, y);\n        return point;\n    }\n}\n```\n\nPointSinEvaluator 继承了TypeEvaluator类，并实现了他唯一的方法evaluate；这个方法有三个参数，第一个参数fraction 代表当前动画完成的**百分比**，这个值是如何变化的后面还会提到；第二个和第三个参数代表动画的**初始值和结束值**。这里我们的逻辑很简单，x的值随着fraction 不断变化，并最终达到结束值；y的值就是当前x值所对应的sin(x) 值，然后用x 和 y 产生一个新的点（Point对象）返回。\n\n这样我们就可以使用这个PointSinEvaluator 生成属性动画的实例了。\n\n```\n        Point startP = new Point(RADIUS, RADIUS);//初始值（起点）\n        Point endP = new Point(getWidth() - RADIUS, getHeight() - RADIUS);//结束值（终点）\n        final ValueAnimator valueAnimator = ValueAnimator.ofObject(new PointSinEvaluator(), startP, endP);\n        valueAnimator.setRepeatCount(-1);\n        valueAnimator.setRepeatMode(ValueAnimator.REVERSE);\n        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                currentPoint = (Point) animation.getAnimatedValue();\n                postInvalidate();\n            }\n        });\n```\n这样我们就完成了动画轨迹的定义，现在只要调用valueAnimator.start() 方法，就会绘制出一个正弦曲线的轨迹。\n\n##### 颜色及半径动画实现\n\n之前我们说过，使用ObjectAnimator  可以对任意对象的任意属性进行动画操作，这句话是不太严谨的，这个任意属性还需要有get 和 set  方法。\n\n```\npublic class PointAnimView extends View {\n\n    /**\n     * 实现关于color 的属性动画\n     */\n    private int color;\n    private float radius = RADIUS;\n   \n\t.....\n\n}\n```\n这里在我们的自定义view中，定义了两个属性color 和 radius，并实现了他们各自的get set 方法，这样我们就可以使用属性动画的特点实现小球颜色变化的动画和半径变化的动画。\n\n```\n        ObjectAnimator animColor = ObjectAnimator.ofObject(this, \"color\", new ArgbEvaluator(), Color.GREEN,\n                Color.YELLOW, Color.BLUE, Color.WHITE, Color.RED);\n        animColor.setRepeatCount(-1);\n        animColor.setRepeatMode(ValueAnimator.REVERSE);\n\n\n        ValueAnimator animScale = ValueAnimator.ofFloat(20f, 80f, 60f, 10f, 35f,55f,10f);\n        animScale.setRepeatCount(-1);\n        animScale.setRepeatMode(ValueAnimator.REVERSE);\n        animScale.setDuration(5000);\n        animScale.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                radius = (float) animation.getAnimatedValue();\n            }\n        });\n\n```\n\n这里，我们使用ObjectAnimator  实现对color 属性的值按照ArgbEvaluator 这个类的规律在给定的颜色值之间变化，这个ArgbEvaluator 和我们之前定义的PointSinEvaluator一样，都是决定动画如何从初始值过渡到结束值的，只不过这个类是系统自带的，我们直接拿来用就可以，他可以实现各种颜色间的自由过渡。\n\n对radius 这个属性使用了ValueAnimator，使用了其ofFloat方法实现了一系列float值的变化；同时为其添加了动画变化的监听器，在属性值更新的过程中，我们可以将变化的结果赋给radius，这样就实现了半径动态的变化。\n\n**这里radius 也可以使用和color相同的方式，只需要把ArgbEvaluator 替换为FloatEvaluator，同时修改动画的变化值即可；使用添加监听器的方式，只是为了介绍监听器的使用方法而已**\n\n好了，到这里我们已经定义出了所有需要的动画，前面说过，属性动画也是可以组合使用的。因此，在动画启动的时候，同时播放这三个动画，就可以实现图中的效果了。\n\n```\n        animSet = new AnimatorSet();\n        animSet.play(valueAnimator).with(animColor).with(animScale);\n        animSet.setDuration(5000);\n        animSet.setInterpolator(interpolatorType);\n        animSet.start();\n```\n\nPointAnimView  源码\n\n```\npublic class PointAnimView extends View {\n\n    public static final float RADIUS = 20f;\n\n    private Point currentPoint;\n\n    private Paint mPaint;\n    private Paint linePaint;\n\n    private AnimatorSet animSet;\n    private TimeInterpolator interpolatorType = new LinearInterpolator();\n\n    /**\n     * 实现关于color 的属性动画\n     */\n    private int color;\n    private float radius = RADIUS;\n\n    public PointAnimView(Context context) {\n        super(context);\n        init();\n    }\n\n\n    public PointAnimView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n\n    public PointAnimView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n\n    public int getColor() {\n        return color;\n    }\n\n    public void setColor(int color) {\n        this.color = color;\n        mPaint.setColor(this.color);\n    }\n\n    public float getRadius() {\n        return radius;\n    }\n\n    public void setRadius(float radius) {\n        this.radius = radius;\n    }\n\n    private void init() {\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint.setColor(Color.TRANSPARENT);\n\n        linePaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        linePaint.setColor(Color.BLACK);\n        linePaint.setStrokeWidth(5);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        if (currentPoint == null) {\n            currentPoint = new Point(RADIUS, RADIUS);\n            drawCircle(canvas);\n//            StartAnimation();\n        } else {\n            drawCircle(canvas);\n        }\n\n        drawLine(canvas);\n    }\n\n    private void drawLine(Canvas canvas) {\n        canvas.drawLine(10, getHeight() / 2, getWidth(), getHeight() / 2, linePaint);\n        canvas.drawLine(10, getHeight() / 2 - 150, 10, getHeight() / 2 + 150, linePaint);\n        canvas.drawPoint(currentPoint.getX(), currentPoint.getY(), linePaint);\n\n    }\n\n    public void StartAnimation() {\n        Point startP = new Point(RADIUS, RADIUS);\n        Point endP = new Point(getWidth() - RADIUS, getHeight() - RADIUS);\n        final ValueAnimator valueAnimator = ValueAnimator.ofObject(new PointSinEvaluator(), startP, endP);\n        valueAnimator.setRepeatCount(-1);\n        valueAnimator.setRepeatMode(ValueAnimator.REVERSE);\n        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                currentPoint = (Point) animation.getAnimatedValue();\n                postInvalidate();\n            }\n        });\n\n//\n        ObjectAnimator animColor = ObjectAnimator.ofObject(this, \"color\", new ArgbEvaluator(), Color.GREEN,\n                Color.YELLOW, Color.BLUE, Color.WHITE, Color.RED);\n        animColor.setRepeatCount(-1);\n        animColor.setRepeatMode(ValueAnimator.REVERSE);\n\n\n        ValueAnimator animScale = ValueAnimator.ofFloat(20f, 80f, 60f, 10f, 35f,55f,10f);\n        animScale.setRepeatCount(-1);\n        animScale.setRepeatMode(ValueAnimator.REVERSE);\n        animScale.setDuration(5000);\n        animScale.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                radius = (float) animation.getAnimatedValue();\n            }\n        });\n\n\n        animSet = new AnimatorSet();\n        animSet.play(valueAnimator).with(animColor).with(animScale);\n        animSet.setDuration(5000);\n        animSet.setInterpolator(interpolatorType);\n        animSet.start();\n\n    }\n\n    private void drawCircle(Canvas canvas) {\n        float x = currentPoint.getX();\n        float y = currentPoint.getY();\n        canvas.drawCircle(x, y, radius, mPaint);\n    }\n\n\n    public void setInterpolatorType(int type ) {\n        switch (type) {\n            case 1:\n                interpolatorType = new BounceInterpolator();\n                break;\n            case 2:\n                interpolatorType = new AccelerateDecelerateInterpolator();\n                break;\n            case 3:\n                interpolatorType = new DecelerateInterpolator();\n                break;\n            case 4:\n                interpolatorType = new AnticipateInterpolator();\n                break;\n            case 5:\n                interpolatorType = new LinearInterpolator();\n                break;\n            case 6:\n                interpolatorType=new LinearOutSlowInInterpolator();\n                break;\n            case 7:\n                interpolatorType = new OvershootInterpolator();\n            default:\n                interpolatorType = new LinearInterpolator();\n                break;\n        }\n    }\n\n\n    @TargetApi(Build.VERSION_CODES.KITKAT)\n    public void pauseAnimation() {\n        if (animSet != null) {\n            animSet.pause();\n        }\n    }\n\n\n    public void stopAnimation() {\n        if (animSet != null) {\n            animSet.cancel();\n            this.clearAnimation();\n        }\n    }\n}\n```\n\n#### TimeInterpolator 介绍\n\nInterpolator的概念其实我们并不陌生，在补间动画中我们就使用到了。他就是用来控制动画快慢节奏的；而在属性动画中，TimeInterpolator 也是类似的作用；TimeInterpolator 继承自Interpolator。我们可以继承TimerInterpolator 以自己的方式控制动画变化的节奏，也可以使用Android 系统提供的Interpolator。\n\n下面都是系统帮我们定义好的一些Interpolator，我们可以通过setInterpolator 设置不同的Interpolator。\n\n\n![系统自带Interpolator](http://upload-images.jianshu.io/upload_images/1115031-9e26dde319ebaae7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里我们使用的Interpolator就决定了 前面我们提到的fraction。变化的节奏决定了动画所执行的百分比。不得不说，这么ValueAnimator的设计的确是很巧妙。\n\n#### XML 属性动画####\n\n这里提一下，属性动画当然也可以使用xml文件的方式实现，但是属性动画的属性值一般会牵扯到对象具体的属性，更多是通过代码动态获取，所以xml文件的实现会有些不方便。\n\n```\n<set android:ordering=\"sequentially\">\n    <set>\n        <objectAnimator\n            android:propertyName=\"x\"\n            android:duration=\"500\"\n            android:valueTo=\"400\"\n            android:valueType=\"intType\"/>\n        <objectAnimator\n            android:propertyName=\"y\"\n            android:duration=\"500\"\n            android:valueTo=\"300\"\n            android:valueType=\"intType\"/>\n    </set>\n    <objectAnimator\n        android:propertyName=\"alpha\"\n        android:duration=\"500\"\n        android:valueTo=\"1f\"/>\n</set>\n```\n使用方式：\n```\nAnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,\n    R.anim.property_animator);\nset.setTarget(myObject);\nset.start();\n```\nxml 文件中的标签也和属性动画的类相对应。\n```\n ValueAnimator --- <animator> \n ObjectAnimator --- <objectAnimator> \n AnimatorSet --- <set> \n```\n这些就是属性动画的核心内容。现在使用属性动画的特性自定义动画应该不是难事了。其余便签的含义，结合之前的内容应该不难理解了。\n\n## 传统动画 VS 属性动画 \n\n相较于传统动画，属性动画有很多优势。那是否意味着属性动画可以完全替代传统动画呢。其实不然，两种动画都有各自的优势，属性动画如此强大，也不是没有缺点。\n\n\n\n![补间动画点击事件](http://upload-images.jianshu.io/upload_images/1115031-6864a7fffbc80884.gif?imageMogr2/auto-orient/strip)\n\n\n\n![属性动画点击事件](http://upload-images.jianshu.io/upload_images/1115031-10bb818b5584da5e.gif?imageMogr2/auto-orient/strip)\n\n\n* 从上面两幅图比较可以发现，补间动画中，虽然使用translate将图片移动了，但是点击原来的位置，依旧可以发生点击事件，而属性动画却不是。因此我们可以确定，属性动画才是真正的实现了view的移动，补间动画对view的移动更像是在不同地方绘制了一个影子，实际的对象还是处于原来的地方。\n\n* 当我们把动画的repeatCount设置为无限循环时，如果在Activity退出时没有及时将动画停止，属性动画会导致Activity无法释放而导致内存泄漏，而补间动画却没有问题。因此，使用属性动画时切记在Activity执行 onStop 方法时顺便将动画停止。（对这个怀疑的同学可以自己通过在动画的Update  回调方法打印日志的方式进行验证）。\n\n* xml 文件实现的补间动画，复用率极高。在Activity切换，窗口弹出时等情景中有着很好的效果。\n\n* 使用帧动画时需要注意，不要使用过多特别大的图，容易导致内存不足。\n\n\n好了，关于Android 动画的总结就到这里。\n\n最后 有兴趣的同学可查看[github 源码](https://github.com/REBOOTERS/AndroidAnimationExercise)欢迎star & fork\n*********","tags":["自定义View"],"categories":["Android 进阶"]},{"title":"理解Android中的注解与反射","url":"%2F2016%2F09%2F24%2F%E7%90%86%E8%A7%A3Android%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84%2F","content":"\n## 前言##\n\n最近一段时间在研究EventBus和Retrofit 的过程中，都遇到了**注解**这个概念。由于在学习Java的时候对这方面没有深入了解过，所以看起相关的代码来，总会有点不知其所以然，这里就注解和反射的使用做一下总结。\n\n*这里我们先从反射说起，了解了反射的意义及用法后，我们在看看注解的使用，最后叙述一下在Android开发中是怎样结合使用注解与反射。*\n\n<!--more-->\n\n## 反射##\n\n\n### Java反射（Reflection）定义###\n\nJava反射机制是指在**运行状态**中\n\n**对于任意一个类，都能知道这个类的所有属性和方法；**\n**对于任何一个对象，都能够调用它的任何一个方法和属性；**\n\n这样动态获取新的以及动态调用对象方法的功能就叫做反射。\n\n比如像下面：\n\n```\n           //获取类\n        Class c = Class.forName(\"java.lang.String\");\n        // 获取所有的属性\n        Field[] fields = c.getDeclaredFields();\n        StringBuffer sb = new StringBuffer();\n        sb.append(Modifier.toString(c.getModifiers()) + \" class \" + c.getSimpleName() + \"{\\n\");\n        // 遍历每一个属性\n        for (Field field : fields) {\n            sb.append(\"\\t\");// 空格\n            sb.append(Modifier.toString(field.getModifiers()) + \" \");// 获得属性的修饰符，例如public，static等等\n            sb.append(field.getType().getSimpleName() + \" \");// 属性的类型的名字\n            sb.append(field.getName() + \";\\n\");// 属性的名字+回车\n        }\n        sb.append(\"}\\n\");\n        System.out.println(sb);\n```\n就可以获得 **String** ，这个我们常用类的所有属性：\n\n\n ![string_property](http://img.blog.csdn.net/20160902224548933)\n\n再比如：\n\n```\n       //获取类\n        Class c = Class.forName(\"java.lang.String\");\n        // 获取所有的方法\n        Method[] ms = c.getDeclaredMethods();\n        //遍历输出所有方法\n        for (Method method : ms) {\n            //获取方法所有参数\n            Parameter[] parameters = method.getParameters();\n            String params = \"\";\n            if (parameters.length > 0) {\n                StringBuffer stringBuffer = new StringBuffer();\n                for (Parameter parameter : parameters) {\n                    stringBuffer.append(parameter.getType().getSimpleName() + \" \" + parameter.getName() + \",\");\n                }\n                //去掉最后一个逗号\n                params = stringBuffer.substring(0, stringBuffer.length() - 1);\n            }\n            System.err.println(Modifier.toString(method.getModifiers())\n                    + \" \" + method.getReturnType().getSimpleName()\n                    + \" \" + method.getName()\n                    + \" (\" +params  + \")\");\n        }\n```\n\n可以获得String 类的所有方法（图片只截取了部分方法，实际有很多就不占篇幅了）：\n\n![string_method](http://img.blog.csdn.net/20160902224713217)\n\n \n### Java反射机制API###\n\n\n\n#### 主要的几个类####\n\nJava中有关反射的类有以下这几个：\n\n|类|用途|\n|--|:--:|\n|java.lang.Class|编译后的class文件的对象|\n|java.lang.reflect.Constructor|构造方法|\n|java.lang.reflect.Field|类的成员变量（属性）|\n|java.lang.reflect.Method|类的成员方法|\n|java.lang.reflect.Modifier|判断方法类型|\n|**java.lang.annotation.Annotation**|**类的注解**|\n\n#### 具体实现####\n\n为了方便描述，这里我们创建一个类 TestClass\n\n```\npublic class TestClass {\n    private String address;\n    private String port;\n    private int number;\n\n   public void printInfo() {\n        System.out.println(\"info is \" + address + \":\" + port);\n    }        \n    private void myMethod(int number,String sex) {\n\n    }\n\n    public String getPort() {\n        return port;\n    }\n\n    public void setPort(String port) {\n        this.port = port;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public int getNumber() {\n        return number;\n    }\n\n    public void setNumber(int number) {\n        this.number = number;\n    }\n\n\n}\n```\n\n这个类很简单，包含三个成员变量address，port和number，以及它们各自的get,set方法。\n两个自定义的方法printInfo()和myMethod()。\n\n下面我们就看一下如何通过反射，获取这个TestClass的所有**“信息”**\n\n* 1.获取Class\n关于Class的获取有三种写法：\n```\n//获取类的三种方法:\nClass c = Class.forName(\"java.lang.String\");  //这里一定要用完整的包名\nClass c1=String.class;\nString str = new String();\nClass c2=str.getClass();\n```\n这里获取的c,c1以及c2都是相等的。一般在反射中会用第一种写法。\n\n* 2.获取类的属性（成员变量）\n\n```\nField[] fields = c.getDeclaredFields();\n```\n这里返回的是一个数组 ，包含所有的属性。获取到的每一个属性Filed，包含一系列的方法可以获取及修改他的内容。\n如下所示：\n```\n// 遍历每一个属性\n        for (Field field : fields) {\n            sb.append(\"\\t\");// 空格\n            sb.append(Modifier.toString(field.getModifiers()) + \" \");// 获得属性的修饰符，例如public，static等等\n            sb.append(field.getType().getSimpleName() + \" \");// 属性的类型的名字\n            sb.append(field.getName() + \";\\n\");// 属性的名字+回车\n        }\n```\n这里我们可以得到TestClass的所有属性：\n\n![test_p](http://img.blog.csdn.net/20160902225142207)\n \n\n* 3.获取类的方法\n```\n// 获取所有的方法\nMethod[] ms = c.getDeclaredMethods();\n```\n和属性类似，我们依然可以通过一系列的方法获取到方法的**返回值类型，名称以及参数**。下面的表格中总结了一些关键方法：\n\n![reflection](http://img.blog.csdn.net/20160902225331083)\n\n 类似的获取到TestClass的所有方法：\n\n![test_method](http://img.blog.csdn.net/20160902225358568)\n  \n  这里可以看到，获取的TestClass的属性和方法同我们定义的是完全一致的。\n\n这里我们顺便调用一下TestClass的printInfo方法：\n```\nnew TestClass().printInfo();\n```\n用于所有属性没有做初始化，所以得到如下输出：\n\n![null](http://img.blog.csdn.net/20160902225523803)\n \n\n可以看到，利用反射我们可以很方便的去“反编译”一个class。那么我们用反射这么做的意义是什么呢？不要着急，下面我们先来了解一下注解\n\n## Java 注解（Annotation）##\n### 什么是注解###\n> 关于注解的定义网上有很多说法，就不再赘述。这里我们就说两点\n\n\n**Annotation（注解）就是Java提供了一种源程序中的元素关联任何信息或者任何元数据（metadata）的途径和方法。**\n\n**Annotation是被动的元数据，永远不会有主动行为**\n\n既然是被动数据，对于那些已经存在的注解，比如Override,我们只能看看而已，并不知道它具体的工作机制是什么；所以想要理解注解，就直接从自定义注解开始。\n\n### 自定义注解###\n\n```\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.FIELD})\n@Documented\n@Inherited\npublic @interface Bind {\n    int value() default 1;\n    boolean canBeNull() default false;\n}\n```\n这就是自定义注解的形式，我们用@interface 表明这是一个注解，Annotation只有成员变量，没有方法。Annotation的成员变量在Annotation定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。比如上面的value和canBeNull。\n\n### 元注解###\n\n可以看到自定义注解里也会有注解存在，给自定义注解使用的注解就是元注解。\n\n#### @Rentention Rentention####\n\n@Rentention Rentention用来标记自定义注解的有效范围，他的取值有以下三种：\n\n**RetentionPolicy.SOURCE: ** 只在源代码中保留 一般都是用来增加代码的理解性或者帮助代码检查之类的，比如我们的Override;\n\n**RetentionPolicy.CLASS: ** 默认的选择，能把注解保留到编译后的字节码class文件中，仅仅到字节码文件中，运行时是无法得到的；\n\n**RetentionPolicy.RUNTIME: **，注解不仅 能保留到class字节码文件中，还能在运行通过反射获取到，这也是我们最常用的。\n\n#### @Target####\n@Target指定Annotation用于修饰哪些程序元素。\n@Target也包含一个名为”value“的成员变量，该value成员变量类型为ElementType[ ]，ElementType为枚举类型，值有如下几个：\n\n* ElementType.TYPE：能修饰类、接口或枚举类型\n* ElementType.FIELD：能修饰成员变量\n* ElementType.METHOD：能修饰方法\n* ElementType.PARAMETER：能修饰参数\n* ElementType.CONSTRUCTOR：能修饰构造器\n* ElementType.LOCAL_VARIABLE：能修饰局部变量\n* ElementType.ANNOTATION_TYPE：能修饰注解\n* ElementType.PACKAGE：能修饰包\n\n*使用了@Documented的可以在javadoc中找到*\n*使用了@Interited表示注解里的内容可以被子类继承，比如父类中某个成员使用了上述@From(value)，From中的value能给子类使用到。*\n\n好了，关于注解就说这么多。\n\n## 反射&注解的使用##\n\n\n### 属性值使用注解###\n\n下面我们首先自定义两个注解：BindPort 和 BindAddress\n\n```\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface BindPort {\n    String value() default \"8080\";\n}\n```\n指定BindPort 可以保留到**运行时**，并且可以修饰成员变量，包含一个成员变量默认值为”8080“。\n```\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface BindAddress {\n    String value() default \"127.0.0.0\";\n}\n```\n这个和上面类似，只是默认值为\"127.0.0.0\"。\n\n同时，我们修改之前的TestClass \n\n```\npublic class TestClass {\n    @BindAddress()\n    String address;\n    @BindPort()\n    private String port;\n\n    private int number;\n\n    public void printInfo() {\n        System.out.println(\"info is \" + address + \":\" + port);\n    }\n   \n   ........\n\n\n}\n```\n这里我们将原先的address 和 port 两个变量分别用这里定义的注解进行修饰，由于我们在定义注解时有默认值，所以这里的注解可以不写参数。\n\n#### 使用反射获取注解信息####\n\n前面已经说了，**Annotation是被动的元数据，永远不会有主动行为**，所以我们需要通过使用反射，才能让我们的注解产生意义。\n\n通过反射可以获取Class的所有属性和方法，因此获取注解信息也不在话下。我们看代码：\n\n```\n\t    //获取类\n        Class c = Class.forName(className);\n        //实例化一个TestClass对象\n        TestClass tc= (TestClass) c.newInstance();\n\n        // 获取所有的属性\n        Field[] fields = c.getDeclaredFields();\n\n        for (Field field : fields) {\n            if(field.isAnnotationPresent(BindPort.class)){\n                BindPort port = field.getAnnotation(BindPort.class);\n                field.setAccessible(true);\n                field.set(tc,port.value());\n            }\n\n            if (field.isAnnotationPresent(BindAddress.class)) {\n                BindAddress address = field.getAnnotation(BindAddress.class);\n                field.setAccessible(true);        \n                field.set(tc,address.value());\n            }\n\n        }\n\n        tc.printInfo();\n```\n我们运行程序得到如下输出：\n\n![output](http://img.blog.csdn.net/20160902230814464)\n \n\n上面代码的逻辑很简单：\n\n**首先遍历循环所有的属性，如果当前属性被指定的注解所修饰，那么就将当前属性的值修改为注解中成员变量的值。**\n\n上面的代码中，找到被BindPort修饰的属性，然后将BindPort中value的值赋给该属性。\n\n这里setAccessible(true)的使用时因为，我们在声明port变量时，其类型为private，为了确保可以访问这个变量，防止程序出现异常。\n\n>理论上来说，这样做是不安全的，不符合面向对象的思想，这里只是为了说明注解和反射举例。\n>\n>但是，你也会发现，反射给我们提供了一种在运行时改变对象的方法。\n\n好了，下面我们继续修改TestClass \n```\npublic class TestClass {\n    @BindAddress(\"http://www.google.com.cn\")\n    String address;\n    @BindPort(\"8888\")\n    private String port;\n\n    private int number;\n\n    public void printInfo() {\n        System.out.println(\"info is \" + address + \":\" + port);\n    }\n    .......\n}\n```\n\n我们为注解设定了参数，再次运行，相信你已经猜到结果了。\n\n![output1](http://img.blog.csdn.net/20160902231316528)\n \n这时候由于我们在给成员变量设定注解时，写了参数，反射时也取到了相应的值。\n\n\n\n### 方法使用注解###\n\n上面对于类属性（成员变量）设定注解，可能还不能让感受到注解&反射的优势，我们再来看一下类的方法使用注解会怎样。\n\n我们还是先定义一个注解\n\n```\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface BindGet {\n    String value() default \"\";\n}\n```\n有效范围至运行时，适用于方法。\n\n再次修改TestClass 如下：\n\n```\npublic class TestClass {\n    @BindAddress(\"http://www.google.com.cn\")\n    String address;\n    @BindPort(\"8888\")\n    private String port;\n\n    private int number;\n\n    @BindGet(\"mike\")\n    void getHttp(String param){\n        String url=\"http://www.baidu.com/?username\"+param;\n        System.err.println(\"get------->\"+url);\n    }\n\n    ...........\n}\n```\n\n我们添加了一个名为getHttp的方法，而且这个方法由@BindGet注解。\n\n然后看反射的使用：\n\n```\n\t//获取类\n        Class c = Class.forName(className);\n        TestClass tc= (TestClass) c.newInstance();\n\t\n\t// 获取所有的方法\n        Method[] ms = c.getDeclaredMethods();\n\n        for (Method method : ms) {\n           if(method.isAnnotationPresent(BindGet.class)){\n               BindGet bindGet = method.getAnnotation(BindGet.class);\n               String param=bindGet.value();\n               method.invoke(tc, param);\n           }\n        }\n```\n\n这里的逻辑和对属性的解析相似，依旧是判断当前方法是否被指定的注解（BindGet）所修饰，\n如果是的话，就使用**注解中的参数**作为**当前方法的参数**去调用他自己。\n\n这样，我们在运行程序时，通过反射就回去主动调用get方法，得到如下输出：\n\n![output2](http://img.blog.csdn.net/20160902231615406)\n\n \n这里我们就可以通过注解动态的实现username参数的修改，甚至get方法整个http url地址的修改。\n(假设我们这里的get 方法是做网络请求）\n\n\n到这里，你应该已经明白了如何使用反射获取注解的信息，但你一定会困惑这么做有什么用呢？\n\n**”动态“**，**”动态“**，**”动态“**\n\n这就是使用注解和反射最大的意义，我们可以动态的访问对象。\n\n说了这么多，下面我们看看，在Android开发中，我们遇到的注解和反射。\n \n## Android 中的注解&反射##\n\n### Butterknife###\n\n如果你是一个Android开发者，相信在使用Butterknife插件之前，你一定写了无数次的findViewById。\n\n然而，如果使用了Butterknife 插件，我们就可以很方便的完成findViewById的工作，甚至是setOnClickListener 的工作。\n```\npublic class ButtferknifeDemoActivity extends AppCompatActivity {\n    @BindView(R.id.textView)\n    TextView textView;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_buttferknife);\n        ButterKnife.bind(this);\n        textView.setText(\"I'm not null\");\n\n    }\n}\n```\n\n上面的代码，应该不陌生。试想如果你的activity_bufferknife 布局文件中有很多控件时，这样做不知道可以省多少时间了\n\n我们看一下BindView的注解定义：\n\n```\n@Retention(CLASS) @Target(FIELD)\npublic @interface BindView {\n  /** View ID to which the field will be bound. */\n  @IdRes int value();\n}\n```\n这个注解用于修饰变量，有效范围也是限定到了CLASS(即编译阶段），并没有到运行时。\n我们在Butterknife（8.4.0）的部分源码中可以看到：\n```\n /** Simpler version of {@link View#findViewById(int)} which infers the target type. */\n  @SuppressWarnings({ \"unchecked\", \"UnusedDeclaration\" }) // Checked by runtime cast. Public API.\n  @CheckResult\n  public static <T extends View> T findById(@NonNull View view, @IdRes int id) {\n    return (T) view.findViewById(id);\n  }\n```\n我们可以猜到的，编译时最终的实现必然是到这里，实现view.findViewById(id)。\n\n**在这里，注解和反射的结合，使我们可以避免做很多重复的工作。**\n\n### Retrofit 2.0 ###\n\n第一次使用Retrofit的时候，完全被接口定义的方式搞蒙圈了，完全搞不懂啊。\n\n```\npublic interface UserBasicService {\n\n    @GET(\"users/{user}\")\n    Call<ResponseBody> getUsers(@Path(\"user\") String uses);\n}\n```\n\n为什么要这么写？参数是怎么传递的？@ 是什么意思？带着曾经的这些疑问，我们首先看看这里的两个注解。\n\n这里使用了两个注解GET 和Path ,我们看一下：\n\n**GET**\n\n```\n/** Make a GET request. */\n@Documented\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface GET {\n  /**\n   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first\n   * parameter of the method is annotated with {@link Url @Url}.\n   * <p>\n   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how\n   * this is resolved against a base URL to create the full endpoint URL.\n   */\n  String value() default \"\";\n}\n```\n\n**Path**\n```\n@Documented\n@Retention(RUNTIME)\n@Target(PARAMETER)\npublic @interface Path {\n  String value();\n\n  /**\n   * Specifies whether the argument value to the annotated method parameter is already URL encoded.\n   */\n  boolean encoded() default false;\n}\n```\n\n这两个注解的生命周期都延续到了 RUNTIME，即运行时。GET用于方法，Path用于参数。这点和我们定义getUsers（）方法是一致的。\n\n关于Retrofit中反射和注解的使用，涉及到动态代理的相关概念，这里就不展开来说。总的思路就是通过注解中使用的参数，动态的生成Request有OKHttp去调用。这个以后会做深入分析，这里只是了解注解和反射用法。\n\n好了，关于注解和反射的使用方法及意义就暂时总结到这里。\n\n## 后话##\n\n以合适的方式使用反射，会让我们写代码的方式更加灵活。反射使用不当，反而会适得其反，会对性能造成影响。\n\n但是EventBus，Retrofit 的如此火爆，让我们有理由相信，对性能的影响也许没那么大，或者说面对现如今硬件配置堪比电脑的手机，这点影响也许可以忽略不计。\n\n所以关于反射的使用还是仁者见仁智者见智吧。\n\n***\n\n\n\n","tags":["反射"],"categories":["Android 进阶"]},{"title":"EventBus 3.0 相见恨晚","url":"%2F2016%2F07%2F23%2FEventBus%203.0%20%E7%9B%B8%E8%A7%81%E6%81%A8%E6%99%9A%2F","content":"\n## 为什么要用EventBus？它是干什么用的？##\n\n### EventBus是什么###\n\nEventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。\n\n这样一个简单的概念，可能让你不足以感受到EventBus的魅力。我们来思考一下下面这些情况。\n\n<!--more-->\n\n*  使用购物类APP时，我们在商品详情页将商品加入购物车时，底部tab栏的购物车tab右上角的小数字也同步发生了变化。\n\n面对这样的需求，一般情况下都是在详情页中提供一个接口，在tab栏所在的Activity（或者是Fragment）中注册这个接口，当点击事件发生是，回调这个接口，更新tab栏的内容。甚至有时候，由于Activity+多个fragment 的组合，可能需要多个接口经过层层传递才能实现某些在产品经理看来很简单的UI更新。\n\n*  大部分APP在用户完成用户登录操作后，需要在返回界面同步更新用户信息。\n\n这个时候，我们一般会在返回界面的onActivityResult方法中，通过requestCode及resultCode做出种种判断，最后在确认用户登录成功的情况下，请求用户信息完成UI的更新，这种体验其实是非常不好，作为一个用户希望的是登录成功的同时完成用户信息的更新。\n\n当然上面两种情况，用BroadcastReceiver实现，也是完全可以的，肯能会相对简单一些，但是从整体性能来说，这样是不好的。\n\n而EventBus的出现，很好的解决了这些让我们头疼的问题。首先就用一个简单的列子来实现一下用户登录信息**异步**更新的情况。\n\n\n## EventBus 3.0 使用Demo##\n\n这里用两个Activity简单的模拟常见的用户登录。\n\n\n### 用户信息界面###\n\n\n```\npublic class FirstActivity extends AppCompatActivity {\n    private Button btn;\n    private Context mContext;\n    //User Info\n    private TextView userName;\n    private ImageView usreImg;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mContext = this;\n        EventBus.getDefault().register(mContext);\n        InitView();\n\n\n    }\n\n    private void InitView() {\n        setContentView(R.layout.activity_first);\n        userName = (TextView) findViewById(R.id.userName);\n        usreImg = (ImageView) findViewById(R.id.userImg);\n        btn = (Button) findViewById(R.id.button);\n        btn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                startActivity(new Intent(mContext, SecondActivity.class));\n            }\n        });\n    }\n\n\n    @Subscribe\n    public void onUserEvent(UserEvent event) {\n        userName.setText(\"用户名:\" + event.nameStr);\n        Glide.with(mContext).load(event.imgUrl).into(usreImg);\n\n    }\n\n    @Override\n    protected void onDestroy() {\n        EventBus.getDefault().unregister(mContext);\n        super.onDestroy();\n    }\n}\n```\n### 用户登录界面###\n\n```\npublic class SecondActivity extends AppCompatActivity {\n    private Context mContext;\n    private Button btn;\n    private EditText name;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mContext=this;\n        setContentView(R.layout.activity_second);\n        name = (EditText) findViewById(R.id.name);\n        findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                //测试数据\n                String userImg = \"http://img5.imgtn.bdimg.com/it/u=3774008831,1558972780&fm=21&gp=0.jpg\";\n                //这里只是为了方便测试,随便写的登录逻辑\n                String userName=\"\";\n                if(!TextUtils.isEmpty(name.getText().toString())){\n                    userName = name.getText().toString();\n                    UserEvent userEvent = new UserEvent(userName, userImg);\n                    EventBus.getDefault().post(userEvent);\n                }else {\n                    //不再发送事件Event\n                    Toast.makeText(mContext,\"登录失败\",Toast.LENGTH_SHORT).show();\n                }\n\n                finish();\n            }\n        });\n\n    }\n}\n```\n### UserEvent 类###\n\n```\npublic class UserEvent {\n    public final String nameStr;\n    public final String imgUrl;\n\n    public UserEvent(String nameStr, String imgUrl) {\n        this.nameStr = nameStr;\n        this.imgUrl = imgUrl;\n    }\n}\n```\n\n这里可以看到没有Handler，没有onActivityResult的判断，没有没有任何接口。就实现了如gif图中所示效果。\n\n接下来，就总结一下如何使用EventBus3.0 。\n\n## EventBus 3.0 使用步骤##\n\n1.首先我们需要将EventBus添加到我们的项目中。在AndroidStudio中我们可以在gradle里面直接配置即可。\n\n```\ncompile 'org.greenrobot:eventbus:3.0.0'\n```\n\n2.创建一个事件类（这个类似于JavaBean)，就是上面的UserEvent类。\n\n这里的Demo只是举例说明简单用法，实际中可以根据需要创建不同的事件类\n\n3.注册\n\n```\n  EventBus.getDefault().register(mContext);\n```\n\n4.订阅（响应事件方法）\n\n```\n@Subscribe\n    public void onUserEvent(UserEvent event) {\n        userName.setText(\"用户名:\" + event.nameStr);\n        Glide.with(mContext).load(event.imgUrl).into(usreImg);\n\n    }\n```\n\n这里的注解@Subscribe 很关键，表明这个方法为订阅者，这个方法的名字也已经不在重要了（相对于以前的版本来说），在这个方法里，我们实现了UI更新。\n\n5.分发事件\n\n```\nUserEvent userEvent = new UserEvent(userName, userImg);\n                    EventBus.getDefault().post(userEvent);\n```\n\n6.解除注册\n\n```\nEventBus.getDefault().unregister(mContext);\n```\n\n\n\n\n\n\n\n\n\n\n","tags":["设计模式"],"categories":["Android 三方框架"]},{"title":"我的少年时代","url":"%2F2016%2F06%2F06%2F%E6%88%91%E7%9A%84%E5%B0%91%E5%B9%B4%E6%97%B6%E4%BB%A3%2F","content":"\n#### 蝉鸣的夏季 我想遇见你####\n     \n2006年的夏天，郭然读高一。\n\n在后来许许多多的日子里，回忆起那个夏天，郭然总是笑着说，那是最最快乐的青春时光。\n\n二中是县里的重点高中，每年初中毕业后能踏进二中校门的人，在内心深处总有着几分悲壮与莫名的骄傲。而一上高中，就直接进入实验班的人，更是许多人眼里神一样的存在，就像郭然，初中三年，始终是那个全年级考第一的人，没有人去嫉妒，就像你不会嫉妒马云赚的比你多一样。所以呢，他能进入实验班在我们一群初中同学眼中是理所当然，反倒是亦安没能进实验班让我们一群人很是诧异，因为亦安虽然不如郭然一样那么稳定的始终待在全年级第一的宝座上，但初中三年下来也没跌出过年纪前五。\n\n那个时候，刚住校的我们，每周五都会一起坐车回家；每次在车上和亦安同属六班的“狗圣”都会说，一定是哪个有钱人家给学校塞了钱把自己家的孩子硬塞进了实验班，挤掉了原本属于亦安的名额，对此，我们几个人都是义愤填膺。反倒是亦安自己觉得没什么，按照她的话就是，只要自己努力，还怕考不上自己心目中的大学，在哪里都无所谓。\n\n\n\n![](http://upload-images.jianshu.io/upload_images/1115031-8a3ae7cb4ba9086f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n<!--more-->\n\n“狗圣”是跟我从小一块用尿和稀泥玩过家家的发小，我们从小学开始就一直在一个班，每天一起上学，一起放学，夏天一起到河里游泳，冬天一起到山上追野兔，在学校里一起打架，当然有时候也是一起被打。直到高中，我们被分到了不同的班里。“狗圣”并不姓狗，学生证上姓名那一栏写的是李鸿盛。小学的时候，有一次放学后去河边游泳，小伙伴们聊天，不知为何就聊到了嘘嘘的话题上，大家都在自己说可以嘘的多远多高，甚至有些人都开始比划上了，狗圣也是其中之一。一场小小的较量慢慢开始，最终狗圣以微弱的劣势的败给了另外一位嘘的比他更远的小伙伴。也许是心有不甘，狗圣忽然问大家说，你们知道狗是怎么嘘嘘的吗？那个时候，宠物不像现在这么的流行，一般人很少能看见小狗小猫，街坊领居家里养猫狗的人也不多，所以真的是没吃过狗肉，也没怎么见过狗跑。\n\n在大部分人的世界观里，对于嘘嘘这件事，基本上都停留在站着还是蹲着的区别上，脑袋里完全没有另外一种姿势。当然，也是有人看到过的，我经常去狗圣家玩，有时候就会看见他们家那条看门的哈巴狗对着南墙嘘嘘时的样子。我们几个小伙伴彼此看了一眼，怀揣着好奇的心情心照不宣的摇了摇头。狗圣还特意看了我一眼，然后微微一笑，仿佛是在感谢我很识时务的没有破坏他想要表演的欲望。只是接下来他所做的一切，彻底成为了他此生最不愿回首的事情。他单脚站立，另一只脚耷拉的半空，弯着腰很有节奏的哆嗦了两下，此刻的你可以脑补一下那个画面，完全就是一条狗的姿态。那一瞬间，我们所有的小伙伴都笑喷了，而明白过来的狗圣在河边气愤却又无可奈何的追打着我们。李鸿盛因为一出真实版的《人与自然》就成了小伙伴们口中的狗，而后来为了叫着顺溜，狗圣就成了伴随他多年的外号。\n\n\n![](http://upload-images.jianshu.io/upload_images/1115031-414d7c5dde950ba4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n那个夏天，过的很快。我们几个一起踏入二中校门的同学和能联系上的初中同班同学以及老师一起进行了一次野炊。男同学负责生火捕鱼，在小树林搭起帐篷，女同学负责洗菜，做饭。在那个蝉鸣的夏季，我们谈着理想，憧憬着美好的未来。所有同学和老师都一致认为，郭然只要加把劲，将来考进清华或者北大是没有问题的，况且二中每年都会有学生进这两所名校，师资力量完全不是问题。郭然特意的感谢了大家的支持，并且说一定会不负众望。我们几个二中的同学也是彼此约定，这三年也要互相帮助，资源共享。在后来日子里，参加过很多大大小小各种形式的聚会，却再也没有过当年的那份快乐，再也没有过像当年那般让自己充满力量的时刻。\n\n#### 枫叶将故事染色 结局我看透####\n\n高中的课程，比起以往，从质和量上都有了很大的跨越。尤其是物理，变得更加的抽象和难以理解。更神奇的是，我遇上了一位奇葩的物理老师，而且与他结下了不解之缘。这位老师第一次给全班做自我介绍的时候，有两件事给我留下了深刻的印象，一件事是他的名字，张发财。在我们那个地方，每个小孩的名字都显得很“通俗”，比如我有个表弟的名字叫做赵长寿，小学的音乐老师叫李雪莲，总之都是父母用心良苦，希望儿女们以后可以活的精彩，活的漂亮，活的有滋有味。\n\n\n一件事是他的着装，尽管从小爸妈和老师都告诉我们不应该随意的对别人的穿着相貌评头论足，可是张发财老师那时的着装在后来很长的日子里深深地影响了我的审美观。那时的张老师其实也很年轻，也许是刚刚从哪个师范院校毕业没几年，讲课很有激情。但是他上的第一堂课结束后，全班同学都在讨论他为什么梳着一个中分的发型，上身穿着一款很有型的小西装，下身却穿着一件洗的发白的牛仔裤和一双布鞋。对他身上这些东西，没有任何的鄙视，因为那时候班里大部分人穿的都是妈妈做的布鞋，很多人穿的牛仔裤甚至是在屁股上打了好几层补丁的。我们诧异的仅仅是他这种搭配，当时还有同学说，也许可能是老师今天皮鞋刚好坏了，裤子洗了没干，所以只能暂时凑合。只是，在后来将近整整一学期这样的装扮后，我们彻底被打败了。\n\n是的，这就是张老师，永远的中分小西装，牛仔裤和布鞋。这样的装扮，直到十年后的今天，我依旧无法理解那是时尚还是别的什么。他的课也是如同他的衣品一样糟糕，虽然每次总是很有激情的讲着，从他每次准备的那么多资料，可以想象课下的他是多么努力的想把一个人民教师的工作做好，只是每次都是让我们坐在前排的这些同学淹没在无用的唾沫和无尽的粉笔灰里。\n\n\n![](http://upload-images.jianshu.io/upload_images/1115031-3143dba1686d2da8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n高二时文理科分班，想着终于可以解脱了，只是命运再一次安排我们相遇，高中三年物理课始终都是他带，幸好有亦安，分班后刚好和我在一个班，所以平时就会对我加以辅导，才使我的物理考试成绩总能维持在一个能让自己满意的水平。我不知道后来的日子里张老师的衣品会不会有所提升，但是有一件事我敢确定，他的课会越讲约好，因为他是一个努力想把这件事做好的人。\n\n分班后，所有人似乎一下子就进入了备战高考的状态。大家都没有了玩的心思，把不得把所有的时间都用在学习这件事情上。周末回家的公交车上也只剩下我和亦安了，我俩都是特别恋家的孩子，纵然时间宝贵也想回家看一眼爸妈，吃一口妈妈做的饭。其他人美其名曰要抓紧时间复习，但是真正把时间花在学习上的可能也只有郭然了，狗圣自从高二的时候找了个女朋友，在加上分了班的缘故，就慢慢从我们的视线里消失了。当然，我们的友谊依旧地久天长，偶尔在厕所里遇见了，也会调侃他几句重色轻友，而作为文科生的他，总能引经据典的让我哑口无言，而我也只能回敬几句他永远都不会理解的生物学专有术语。\n\n天外有天，人上有人，郭然虽然不能像初中那般稳坐全年级第一的宝座，但每次模拟考试从来是没有跌出过前十名。依旧像神一样存在于几个小伙伴的内心当中。他总会把实验班老师发的复习资料分享给我们，每次有不懂的问题找他，也会毫不犹豫的帮我们解答，一如从前，你在他的脸上看不到沮丧的表情，他总是像个孩子一样，整天都很开心。\n\n07年冬天，正式的进入了高考倒计时，每个高三毕业班教室后面黑板报上都会有用红色的粉笔描绘的距离高考还有XX天的大字，并且由班长负责每天进行更新。那是一段很特别的时光，只有经历的那样一段岁月，你才可能真正地明白所谓的考场如战场意味着什么。后来上大学包括工作时，每次和别人聊到高三时为高考奋战的日子，每个人眼里总会显现出无尽的自豪，那是带着汗水与艰辛的青春岁月。许多人说那是一段你再也无法体验的日子，在漫长的人生道路上，也许你要考研，为了出国要考GRE,考托福……，要面对新的挑战，但再也不能像高三那年那么的投入，那么的心无旁骛。因为随着年龄和阅历的增长，我们明白很多事的选择不是唯一，我们是有退路的。而且，在活着这件事情上，永远都没有一劳永逸。\n\n那时候开始，我和亦安回家的次数也从每周一次，变成了每月回一次。这也是各自父母的要求。按照亦安她爸的说法就是，起跑线上有没有输，已经不重要了，但是一定不能输在最后冲刺的阶段。月末回家的那天是我们俩每个月最开心的日子，不仅是因为可以回家吃到妈妈做的饭，更是因为回家的路上可以去音像店里听歌，那时虽然MP3已经很普及，但是对于那个时候我们，那依然是奢侈品。所以听歌的唯一途径就是去路边的音像店里打着挑选磁带的幌子在那里赖一个小时，听听最新的流行歌曲。\n\n\n![](http://upload-images.jianshu.io/upload_images/1115031-4c743623cf910440.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我和亦安到现在都可以把《青花瓷》的歌词完完整整的写下来，那是我们在那段时间听得最多的歌。在作为周杰伦歌迷的这么多年里，觉得《青花瓷》是他中国风类型歌曲的巅峰之作，同时也是方文山歌词创作的巅峰之作。从小到大学了那么被强迫背诵全文而如今早已忘得一干二净的所谓的经典之作，也没有让我感受到任何古诗词作品的美妙，没有激发对语文学习的兴趣，反而是一篇歌词。\n\n#### 时间被安排，演一场意外####\n\n08年的元旦，学校破天荒的决定放假，这对于憋了一整个冬天的所有高三党来说完全就是一个惊喜，包括老师。我和亦安决定还是回家，因为觉得反正在家里也能学习，在学校学三天反而不会有什么效果。郭然本来就是那种喜欢安静的人，学校放假人少了刚好可以放松一下身心，所以决定不回家。狗圣也决定不回家，虽然和我们一再强调要安心复习，争取下次模拟考能进年纪前十，但我和亦安都知道他留在学校不过是为了陪他的女朋友，亦安更是无情的嘲笑狗圣这是媳妇还没娶呢，就忘了娘。\n\n*如果时光能够倒流，真的想回到08年的元旦，把郭然和狗圣想尽一切办法的拉回家，免得他们承受之后的一切*\n\n放完假回来的那天下午，带着郭然很喜欢吃葱花油饼去他们宿舍找他，这是过元旦时每家都会做的好东西，想让没回家的他解解馋，可却没有找到他，同宿舍的室友告诉我说他回家了，让我很是诧异。再去找狗圣，也是同样的结果，让我在内心隐隐有一丝的不安。晚自习课间休息的时候，我开玩笑的问亦安，“你说郭然和狗圣不会是私奔了吧”。亦安鄙视的看了我一眼说，怎么可能。可我们俩心里都有些不安，尤其是对郭然。第二天我特意去实验班找郭然，结果被告知一整天都没来上课，去狗圣宿舍也是被告知一直没回来，两个人就像突然失踪了一样。\n\n\n![](http://upload-images.jianshu.io/upload_images/1115031-c57d1886a18687a3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n就像暴风雨来临之前，天空会变得阴云密布，当我们内心烦躁时，真的会有事情发生。到了第三天早上整个高三党都在说一件事，实验班的学生把年级主任打了。那段时间大约有一个星期，都没有看到郭然和狗圣。再次看到他俩的时候，完全都认不出了，不知道一个人经历了什么才会变成那个样子，狗圣变得真像一条狗一样，蓬头垢面。而郭然呢，更是像一下子老了十岁似的，看不到那熟悉的笑容。直到那年高考结束，我始终不知道具体发生了什么，只知道一群学生把年纪主任打伤了，还住了院，这群学生里包括郭然和狗圣。\n\n后来，高考前的那段日子里发生很多事，郭然和狗圣的父母来过学校好几次，每次都是直接去行政楼，也不知道具体说了些什么。想必以往，他们俩都变得异常的沉默，脸上很少再有笑容。大家偶尔在路上碰见，一起聊天的时候，亦安讲笑话，他们俩也是强颜欢笑。郭然在后来的两次模拟考试中，成绩一落千丈，直接被其他班里成绩比他好的顶替了他在实验班的位置，被分到了一个普通班。狗圣呢，也变成了单身狗。对于郭然的急速陨落，我和亦安都是看在眼里，急在心里，而他总是刻意躲避我们，想要找他好好聊聊很困难。而狗圣也是像在校园里消失了似得，很难看见他的身影。去宿舍找他，不是在睡觉就是人不在宿舍。人在忙碌的时候，时间总是会过的特别快，过完年回来一百多天的日子转瞬即逝，高考终于来临。我清楚的记得，当年考完最后一门英语，交卷后从教室里出来的那一刻，并没有一种解脱的感觉，内心反而显得特别的平静，恍然间有点不知所措罢了。\n\n\n\n亦安说，高考结束后一定要回家好好睡上一星期，把这半年缺的觉都要补回来。\n\n\n![](http://upload-images.jianshu.io/upload_images/1115031-aa37e8820139a681.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n高考结束后，等分数的那段日子也是充满煎熬，尤其是对于狗圣，最后两次模拟考的分数跳跃挺大，让他对自己的状态也是有些怀疑，而且文科考试不像理科，有太多的不确定。那时候的我们都没有手机，更别提上网了。所以查成绩的唯一途径就是打有线电话。\n\n成绩公布的那天，我和狗圣早早的来到了镇上的小超市，想用那里的唯一的公用电话查成绩，去的路上狗圣还跟我说，要让他先查，不许跟他抢，结果到了那又开始犹豫，让我先查；我的成绩比几次模拟考试还高点，所以我还是有点庆幸自己有点小小的超常发挥。轮到狗圣的时候，始终在那里磨磨唧唧，最后还是我帮他查，当我按下免提键分数从电话机里报出来的那一刻，我在狗圣脸上再次看到了那份久违的纯真笑容。\n\n\n\n我和亦安很多次都问过狗圣和郭然那次到底发生了什么，只是他们俩永远都是转移话题，避而不谈。那天回去的路上，狗圣终于把一切都告诉了我。事情其实很简单，几个男生在宿舍里看黄色杂志被恰好查寝的年级主任发现，年纪主任要没收书，几个人碍于面子不愿意把书交出来，主任一开始不知道是色情杂志，想没收没成功，反而激发他的好奇心，死活都要让几个人把书交出来，几个男生不愿意。一来二去便发生了肢体冲突，其实谁都没有想着动手去打人，毕竟是老师。只是在混乱中不知谁推了一把，年纪主任头撞在了窗户的棱角上流了血，几个人赶紧扶着年级主任去了校医院，而这次意外就慢慢发酵成了几个学生把年纪主任打伤了这样一件事情。出事之后，几个学生的家长都被叫到了学校，校方对于这件事很是愤怒，一开始说是要开除这几个学生，后来几个家长各种求情，最终才决定留校察看。狗圣说，这件事最对不起的人是自己的父母，在出事的那段时间父母似乎一下子老了许多，所以，这次高考自己一定要考好，再也不能让他们失望。\n\n08年秋天，我和亦安去了北京上大学，狗圣选择去了西安，郭然去了南方一座不知名的院校。我们所有人对为他感到惋惜，这本不该是属于他的命运，他可是当年我们心中的神啊。南美洲的蝴蝶煽一下翅膀，通过种种因素，就可能引起亚洲地区的一阵台风，有些小事，会给我们原本平静的生活带来一些波折。\n\n![](http://upload-images.jianshu.io/upload_images/1115031-971f7671a9f30df9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在后来很多的日子里，我总会去幻想，如果当年的一切都没有发生，现在的郭然会是什么样子。很多时候，都觉得这就是命运，生活中总有些我们无能为力的事情。从《那些年，我们一起追过的女孩》到《致我们终将逝去的青春》，再到后来的《匆匆那年》，任何一个故事，但凡涉及到青春，总会或多或少的给我们带来些许共鸣。但总是少一些感同身受的成分，直到《我的少女时代》的出现。当林真心为了让徐太宇变回从前的徐太宇，不顾疼痛的穿着旱冰鞋跑向终点时，我瞬间就想到了郭然。那时的郭然没有徐太宇幸运，没有遇见他的“林真心”。年少的我们，总会犯错，总会在成长的道路上误入歧途，有时候我们只是不小心迷失了方向，丧失了信心，这个时候我们真的需要有个人能让我们重新回到正确的轨道。\n\n2016年的夏天，郭然来北京玩，晚上我们在簋街吃小龙虾，聊起即将到来的高考，郭然说，当年高考失利真的以为这辈子就这么完了，到了大学慢慢发现，人生不止眼前的苟且，还有诗与远方的苟且。我说，靠，你是不是喝醉了。我们俩一起开始哈哈大笑。\n\n\n***\n\n\n\n\n\n\n","tags":["理想"],"categories":["诗与远方"]},{"title":"Android View 事件分发记录","url":"%2F2016%2F05%2F07%2FAndroid%20View%E4%BA%8B%E4%BB%B6%E8%AE%B0%E5%BD%95%2F","content":"\n# View初探 #\n\n\n> 一直以来对View的事件分发机制很晕，今天就在这里梳理一下\n\n\n<!--more-->\n\n## MyView ##\n\n### 首先继承View类，自定义一个MyView。并在初始化时打印View类是否可点击，这里从View点击事件分发的角度出发，所以不考虑绘制，测量相关方法的实现。 ###\n\n    public class MyView extends View {\n    String TAG = \"Activity\";\n\n    public MyView(Context context) {\n        super(context);\n        init();\n    }\n\n\n    public MyView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n\n    public MyView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n    private void init() {\n        Log.e(TAG, \"the View clickable is \" + isClickable());\n    }\n\n}\n\n将整个MyView放置到布局文件中，看Log日志。\n\n    <engineer.test.MyView\n        android:id=\"@+id/myview\"\n        android:layout_width=\"150dp\"\n        android:layout_height=\"150dp\"\n        android:layout_centerInParent=\"true\"\n        android:background=\"#ff00ff\" />\n\n\n**可以看到，View类默认是不可点击的。**\n\n## 监听View的Touch事件 ##\n\n> 这里首先明确MotionEvent中事件所对应的值\n\n    public static final int ACTION_DOWN= 0;\n    public static final int ACTION_UP= 1;\n    public static final int ACTION_MOVE= 2\n\n\n> 给MyView设置OnTouchListener，并打印事件日志\n\n    myView = (MyView) findViewById(R.id.myview);\n        myView.setOnTouchListener(new View.OnTouchListener() {\n            @Override\n            public boolean onTouch(View v, MotionEvent event) {\n                Log.e(TAG, \"myview_onTouch---->\"+event.getAction());\n                return false;\n            }\n        });\n\n点击一下MyView看日志：\n\n\n\n**可以看到，这里只有ACTION_DOWN事件发生**\n\n> 给MyView设置OnClickListener，并打印日志\n\n    myView.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Log.e(TAG, \"the View clickable is \" + myView.isClickable());\n                Log.e(TAG, \"myview_onClick\");\n            }\n        });\n\n点击一下MyView看日志：\n\n**可以看到，设置ClickListener之后：**\n\n*  MyView直接由一个不可点击的控件变成了可点击控件，isClickable返回true。\n*  ACTION_DOWN和ACTION_UP事件都发生了。\n*  Touch事件先于Click事件发生。\n\n\n我们看到TouchListener的onTouch方法是有返回值，而且默认返回为false，我们将其改为true，然后点击MyView看日志：\n\n\n**可以看到，多次点击MyView后，Click方法没有执行，即onTouch事件返回true时，相当于屏蔽了click事件的发生**\n\n## View源码分析 ##\n\n根据上面所获得的一系列结论，我们去看View中关于事件分发的两个方法dispatchTouchEvent和onTouchEvent。\n\n\n\n> 首先看dispatchTouchEvent，因为首先执行的也是这个方法\n\n### API 注释 ###\n\n> /**\n     * Pass the touch screen motion event down to the target view, or this\n     * view if it is the target.\n     *\n     * @param event The motion event to be dispatched.\n     * \n     * @return True if the event was handled by the view, false otherwise.\n     */\n\n从注释可以看到，这个方法返回true就是当前view要处理此次事件。\n\n### dispatchTouchEvent源码（截取主要内容） ###\n\n    public boolean dispatchTouchEvent(MotionEvent event) {      \n        boolean result = false;        \n        if (onFilterTouchEventForSecurity(event)) {\n            //noinspection SimplifiableIfStatement\n            ListenerInfo li = mListenerInfo;\n            if (li != null && li.mOnTouchListener != null\n                    && (mViewFlags & ENABLED_MASK) == ENABLED\n                    && li.mOnTouchListener.onTouch(this, event)) {\n                result = true;\n            }\n\n            if (!result && onTouchEvent(event)) {\n                result = true;\n            }\n        }\n\n        \n        return result;\n    }\n\n**可以看到，这里默认的返回值默认是false**\n\n* 首先，onFilterTouchEventForSecurity方法检测，点击事件是否确实发生在当前view上，如果是的话，view就会处理当前点击事件，否则的话就直接返回false不去处理此次事件。\n* 接着，当view的touchListener不为null,且View是enable，并且touchListener的onTouch方法返回true时，result=true,这样下面的if语句中onTouchEvent方法就不会执行，这样onClick方法就不会调用了，这也和之前测试的结果一致。\n\n但是**正常情况下，onTouch方法是返回false**的，所以下面就会执行到onTouEvent方法中去了。\n\n\n### onTouchEvent源码（截取） ###\n\n    public boolean onTouchEvent(MotionEvent event) {\n        final float x = event.getX();\n        final float y = event.getY();\n        final int viewFlags = mViewFlags;\n        final int action = event.getAction();\n\n\n        //view不是enable时，也会消耗touch事件，只是就此返回，不会进入\n        //到performClick()方法中\n        if ((viewFlags & ENABLED_MASK) == DISABLED) {\n            if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {\n                setPressed(false);\n            }\n            // A disabled view that is clickable still consumes the touch\n            // events, it just doesn't respond to them.\n            return (((viewFlags & CLICKABLE) == CLICKABLE\n                    || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)\n                    || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);\n        }\n\n        if (mTouchDelegate != null) {\n            if (mTouchDelegate.onTouchEvent(event)) {\n                return true;\n            }\n        }\n\n        if (((viewFlags & CLICKABLE) == CLICKABLE ||\n                (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) ||\n                (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {\n            switch (action) {\n                case MotionEvent.ACTION_UP:\n                    boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;\n                    if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {\n                        // take focus if we don't have it already and we should in\n                        // touch mode.\n                        boolean focusTaken = false;\n                        if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {\n                            focusTaken = requestFocus();\n                        }\n                            // Only perform take click actions if we were in the pressed state\n                            if (!focusTaken) {\n                                // Use a Runnable and post this rather than calling\n                                // performClick directly. This lets other visual state\n                                // of the view update before click actions start.\n                                if (mPerformClick == null) {\n                                    mPerformClick = new PerformClick();\n                                }\n                                if (!post(mPerformClick)) {\n                                    performClick();\n                                }\n                            }\n                    }\n                    break;\n            }\n            //switch完毕后，最终会返回true\n            return true;\n        }\n        //如果click，longclick以及contextClickable都为false时，返回false\n        return false;\n    }\n\n\n\n**可以看到，一个正常的veiw（即enable时），存在点击事件时，在ACTION_UP的时候，最终会进入performclick()这个方法中去**\n\n可以再看一下，performanceclick方法的实现\n\n    public boolean performClick() {\n        final boolean result;\n        final ListenerInfo li = mListenerInfo;\n        if (li != null && li.mOnClickListener != null) {\n            playSoundEffect(SoundEffectConstants.CLICK);\n            li.mOnClickListener.onClick(this);\n            result = true;\n        } else {\n            result = false;\n        }\n\n        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);\n        return result;\n    }\n\n最终会执行onClickListener中的onClick方法，也就是平常我们去实现的那个方法。\n\n**同时，也可以看到可以clickable,longclickable以及contextclickable中只要有一个为true，那么在switch最后也会返回true，这样返回到上面的dispatchTouchEvent方法，返回result也为true，即完整的消耗（处理）了此次touch事件**。\n\n这里可以自己去看一下源码，整体结构上就是一旦进入if语句内部，switch执行完毕后，return true；\n\n***当然，如果clickable,longclickable以及contextclickable这三个都为false时，就不会进入if语句，直接返回为false，dispatchTouchEvent方法的返回也为false，即表示没有处理此次touch事件***\n\n\n好了，这样终于理清了View(不包括ViewGroup)的事件分发机制。\n\n> 最终得出下面结论：\n\n**View接收到Touch事件时各个方法执行顺序**\n\nonTouch-->onTouchEvent-->onClick  \n\n**onTouch默认返回false，返回true时后续事件无法执行**\n\n**dispatchTouchEvent返回true表示处理了touch事件，返回结果受onTouchEvent方法影响**\n\n**onTouchEvent返回true表示已消耗touch事件，否则的话不消耗。**\n\n**view enable属性的true和false，不能完全决定touch事件的传递，还得考虑其listener**\n\n\n\n***","tags":["Android Touch 事件分发"],"categories":["Android 基础"]},{"title":"2016 booklist","url":"%2F2016%2F03%2F01%2F2016-booklist%2F","content":"\n- 大仲马-基督山伯爵 Done\n- 韩寒-One 系列 Done\n- 郭敬明-夏至未至 Done\n- 吴承恩-西游记 Done","tags":["读书"]},{"title":"你的生活会变成什么样子","url":"%2F2013%2F08%2F19%2F%E4%BD%A0%E7%9A%84%E7%94%9F%E6%B4%BB%E4%BC%9A%E5%8F%98%E6%88%90%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%2F","content":"\n\n在北京上学四年，毕业后才发现，原来这里真的很热。\n\n那天在微博上看到一个段子，感觉挺搞笑。说是某市高考状元填报志愿，所填的第一志愿是“北京有空调大学”，其后依次才是xx大学（传说中的国内名牌大学）。这当然只是调侃北京的天气，故事的真假倒是其次。但北京的热真是快到让人无法忍受的地步了。\n\n<!--more-->\n\n夜里实在是太热，蚊子又多，所以决定放弃早睡，23:00爬起来，打开电脑开始继续看《nikita》。MaggieQ打架的身影依旧那么性感，虽然鱼尾纹已经爬上了眼角，只是情节的发展真是让我又有了睡意，可是我躺下之后在汗水和蚊子的摧残下又一次爬了起来。点开新浪体育，时间才是六月份，欧洲五大联赛正在休息，也没啥球赛可看。继续瞎点，打开了好久没上的人人，决定去看看那些好久没见的同学们现在都是什么样子了。看到的第一条状态是关于小时代吐槽的日志，我点进去大概看了几眼就叉掉了，都是一些车轱辘话，无非是对电影里各种炫富的不满与嫉妒。只是，我不明白当初《折纸时代》出版的时候，没有人出来说小说炫富，而一部电影的却引起了那么针锋相对的网络骂战。第一次看《小时代》是大三那年的国庆节，那时候找了一个兼职，每天差不多要坐三个小时的地铁，趁着无聊就用手机开始看这部在手机SD卡里放了快半年的电子书。其实，第一次看到我几乎没怎么记住故事情节，只是深刻的记住了四个女主人公的名字“顾里，林萧，南湘，唐宛如”。还有如如那句剽悍的“看看看！我的奶有什么好看的！”。曾经一度以为，在上海，人们过得就是那样的生活。LV,GUCCI,哈根达斯……这些东西在他们的生活中，就如我们每天要卖的一次性塑料袋，雪糕一般平凡。后来，我明白其实不是那样，小说里的那些东西叫做奢侈品。大四毕业的时候，终于等到了《刺金时代》，作为结局小四再次延续了以往的风格，除了林萧之外的所有人竟然在上海那场著名的静安区大火中丧生了。死亡总是能引起人们无限的遐想和追忆，我时常在想如果小说里的那些主人公们没有死，后来会怎样。我喜欢小时代里的那些人不记仇，无论今天说了什么或做了什么，到了明天，依旧会开着玩笑做彼此最好的依靠。\n\n \n\n鼠标继续滚动，看到的一条状态让我停了下来。倒不是内容有多么的吸引人，而是下面的定位信息“在北纬40.44° 西经79.92°”。而发这条状态的人我认识，大一时我们曾是同一个社团的。我们社团叫“真爱行动部”，其实就是志愿者社团的别称。现在想来，那时的她真的毫无特别之处，没有倾国倾城的容貌，也没有可以倾倒众生的气质，只知道她学习很好，是他们专业的第一名。在后来多次的共事中也没发现什么特别之处。只是此刻的她，身处大洋彼岸的Carnegie Mellon University里拍下来一张张在我看来完全可以秒杀国内二流女明星的写真照，完全一副女神的姿态。点到她的主页继续看，她来到这个国度已然有一年的时间了。个人相册里是各种各样她在异国的生活学习记录。看着那些在她灿烂笑脸下映衬的国外大学风光，我有那么一丝的羡慕嫉妒没有恨。那一刻我突然在想，为什么彼此的生活相差这么大。倒不是真的想像她那样留学在外，体验异国的生活。从小到大在我的梦想里从来没有出国这个字眼。我只是对自己现在的状态有些不满。突然觉得一件事情，做了，失败了，总比懒得去做或懒得去想强！“懒”是比“怕”更糟糕的一种状态。\n\n有段时间，我一直有一种矛盾的想法。上学时，老师教育说要通过自己的努力改变命运，于是我们听老师的话，努力学习，决定用知识改变命运。我们不怕艰辛，不抛弃，不放弃，为了所谓的梦想奋斗。只是，在某一个瞬间我会想，我们这么拼命到底是在改变命运，还是说一切早已命中注定，我们所做的一切，无论是不怕失败的尝试，还是大彻大悟的重头再来……，都只不过是按照命运早已安排好的轨迹在前行。\n\n每当无聊的时候我都会到她的人人主页上看看，除了欣赏一下女神在异国的风采之外。还会提醒自己，其实生活中的很多事情是我们无法控制的，付出了不一定有收获，但是不付出，就什么都没有。在我们成长的道路上，机遇是一件很要的事情。\n\n看不清远方模糊的事，就做好手边清楚的事。这是我早就明白的道理，只是在纷纷扰扰的杂乱生活中被我遗忘了。所以，无论生活怎样，总应该有一些不会被抛弃的原则和信念一直被铭记着。就像女神一样，不是用来娶回家当老婆的，当然也不一定娶得到，但依旧会被怀念很久很久，因为，在这个世界上有一种姑娘是用来励志的，比如女神！那不是YY，是一种可以让我们在迷茫或无奈时依旧能够勇往直前的信念和力量。\n\n \n\n \n\n上面的内容是我在三个月之前写的。现在想来，那真是一段无法形容的日子。\n\n在过去的这个夏天最炎热的时候，不知怎的，我误以为自己得了抑郁症。对生活有一些消极。我用了一个没有答案的问题把QQ空间加密了。我怕自己会说一些疯狂的话。免得造成一些大家的误解。开始逃避许多东西。现在想来，那完全是对安于现状的烦躁与不安。我不是崔永元，抑郁症是一种高级的病，像我这种凡人得不起。\n\n九月初开学的时候，我接了两个电话。一个是那个睡神打来的，他开始新的大学生活。一想到在大学里留了那么多的遗憾，对现在的他完全是嫉妒啊。一个是和我小时候撒了尿和泥玩的发小打来的。他说他离婚了，打算来北京打工，问我干啥好。我尽我所能的给他讲了一些北京的现状和需要面对的压力以及一些建议。然后在他的感激不尽中挂了电话。10年大二寒假回家的时候，还喝了他们的喜酒，当初看着那么幸福的一对怎么就离了呢。原来，有些人在一起了，却没走到最后。真心希望所有天下有情人生生世世相亲相爱。\n\n好奇心就像魔法一样，我用了一个周末两天的时间看完了被网友们褒贬不一的两部《小时代》。想看看到底有多烂或者说多好。除去别的不说，就单从小说翻拍电影来说，值得一看。比《奋斗》电影版拍的好。觉得《青木时代》里最后打雪仗的情景是那么的温馨，无论彼此间有怎样的深仇大恨或阴谋算计，那一刻的他们是那么的单纯，单纯的玩闹。一想到后来，他们要面对的一切，感觉小四挺残忍的。\n\n这里的秋天是一年中风景最好的时刻。大街上到处都是戴着墨镜、穿着风衣和紧身牛仔裤的姑娘们，风一吹，看着那在风中凌乱的长发各个都是女王的范儿。比起夏天那让人无法直视的小短裙……，现在的风景是多么的好。这个季节的天气不冷不热，时而还刮点儿大风，然后在某个早晨一觉醒来，发现树上的叶子都没有了。\n\n那些曾经在QQ空间很活跃的朋友们，都不知不觉的消失了。只剩下那么几个人偶尔上来喘口气，证明自己还活着。这样也好，每个人的内心深处总是渴望有一片宁静地方，现在的这里很好。\n\n我依旧喜欢看《奋斗》，无论是小说还是电视剧。总觉得那个故事是那么的有意思，总觉得米莱是这个世界上最好的姑娘！\n\n “年轻的时候，不该什么都不想，也不能想太多。想得太多会毁了你，我相信这话……成功路上最心酸的是要耐得住寂寞、熬得住孤独，总有那么一段路是你一个人在走，一个人坚强和勇敢。也许这个过程要持续很久，但如果你挺过去了，最后的成功就属于你。”《中国合伙人》里这句话真是说的太好了。\n\n时间，从不曾给予我们毫无顾忌的任性，生活，也从不曾带给我们满是绝望的恐惧，回忆，更是从不曾留给我们颓废茫然的理由。人不能总是活在回忆里。我们所经历所有事情都是有意义的。\n\n \n\n生活，会变成我们想象的样子！\n\n\n","tags":["理想"],"categories":["诗与远方"]}]