[{"title":"关于《绿皮书》的一些感想","url":"%2F2019%2F03%2F10%2F%E5%85%B3%E4%BA%8E%E3%80%8A%E7%BB%BF%E7%9A%AE%E4%B9%A6%E3%80%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3%2F","content":"\n\n<img src=\"关于《绿皮书》的一些感想/p2549177902.webp\" />\n\n很久没有看到这样的电影了，看完的时候，内心真的很舒服。好久没有这样的感受了，太多的台词太经典了，尤其是那句 **世界上有太多孤独的人害怕先踏出第一步（the world's full of lonely people afraid to make the first move ）** ,心真的颤了一下，这么些年真不就是最真实的自己吗？\n\n\n\n<!--more-->\n\n想写的东西太多，却又不知从何写起，就用这些剧照(图源自豆瓣电影)表达我的心情吧。\n\n- 让我看的时候停下来沉思了十分钟的电影台词\n\n<img src=\"关于《绿皮书》的一些感想/p2548973932.webp\" />\n\n- 也许这应该是我们做事时最该有的态度\n\n<img src=\"关于《绿皮书》的一些感想/p2545880063.webp\" />\n\n- 有多少类似这样的话，却从来没有听人说起过\n\n<img src=\"关于《绿皮书》的一些感想/p2549106335.webp\" />\n\n- 我们应该怎样活着\n\n<img src=\"https://img1.doubanio.com/view/photo/l/public/p2548991669.webp\" />\n\n- 最后，两张好看的电影剧照\n\n<img src=\"关于《绿皮书》的一些感想/p2548719163.webp\" />\n\n<img src=\"https://img1.doubanio.com/view/photo/l/public/p2548719157.webp\" />\n\n\n\n[更多剧照](https://movie.douban.com/subject/27060077/photos?type=S)\n\n\n","tags":["读书"]},{"title":"读《曾国藩 又笨又慢平天下》的一些感想","url":"%2F2019%2F03%2F03%2F%E3%80%8A%E6%9B%BE%E5%9B%BD%E8%97%A9-%E5%8F%88%E7%AC%A8%E5%8F%88%E6%85%A2%E5%B9%B3%E5%A4%A9%E4%B8%8B%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F","content":"\n对曾国藩一直不是很了解，只是在近代历史故事里，总能听到他的名字。尤其这两年曾国藩似乎成为励志人物，曾国藩家书，曾国藩各种事迹被翻出，各种名家大师都会推荐我们去读曾国藩，了解他这一生的故事。因此，就从这本从国家图书馆借来的书，了解一下这位历史名人的一些故事。\n\n<!--more-->\n\n<img src=\"《曾国藩-又笨又慢平天下》读后感/s28787066.jpg\" width=30% height=20%/>\n\n\n### 关于作者\n\n首先简单说下这本书的作者吧，**度阴山**，百科上有关于他的介绍，就不多说了。读完这本书感觉作者的文风还是比较风趣，人物对话和内心活动的语言描述都比较**平民化**，有种和好友聊天的感觉。\n\n全书中关于曾国藩出生和去世时的描述挺有意思。\n\n*说曾国藩出生的前一天，几只蚰蜒(youyan)爬上了房梁，俯瞰下面昏昏欲睡的他的曾祖父曾竟希。\n曾竟希也老眼昏花的看着它们，当确信没有看错时，他用尽全身的力气喊道：“龙，龙，有龙！”*\n\n*曾国藩晚年（61岁）去世的时候，房间里一片死寂，有忍耐不住这死一般的沉寂，似乎受到了神灵的启示，偷偷望向房梁。几只蚰蜒正在房梁上快乐的玩耍，突然“砰”的一声，蚰蜒如爆竹似的爆开，刺鼻的烟气袅袅绕梁。*\n\n这一前一后的呼应，不知真假，但在整部书读完的一瞬间，还是感觉这作者挺有意思。\n\n### 曾国藩是一个怎样的人\n\n按照现在的条件，曾国藩完全是一屌丝，而且是那种智商特别低的屌丝，简直就是一个反向爱因斯坦。说是有一日一小偷进到曾国藩房里想偷东西，结果临要走了，曾国藩突然回来，小偷无奈只得藏在曾国藩床底，曾国藩一进屋便开始在屋里背一篇文章，结果过去好几个时辰，还没背会；小偷在床底下偷听都背会了，最后小偷实在受不了了，就从床底下爬出来，狠狠吐槽了一顿曾国藩有多么笨之后扬长而去，曾国藩很无奈，接着继续背文章，直到第二天凌晨才背会。\n\n读书考取功名，考了 N 多次才考上，而且也考得不是很好。\n\n后来在京城做官，虽然做到了很高的品级，算是给曾家光宗耀祖了，但最终还是离开了北京。\n\n后来，在湖南任职期间创建了大名鼎鼎的湘军，并一举消灭了太平天国的叛乱。\n\n曾国藩秉承的自己的做人的原则，深知自身的缺点与毛病，坚守着自己内心的”忠“与”诚“，竭尽全力的为国效力。感觉有点生不逢时，遇到了清末洋人入侵，慈禧夺权等一系列悲剧的事情。全篇通读下来，感觉曾国藩的一生非常的不容易。**”打脱牙和血吞“**的就像是笼罩在他头顶的阴影，在他人生的弯弯角角里不断的锤炼着他。\n\n### 感想\n\n如今，在我们身边还是有想曾国藩这般的人，天赋一般，但就是非常努力的人。但不得不说很多时候机遇很重要，遇见对的人，在那个正确的时间做了正确的事，真的非常重要。有句话说，机会是留给有准备的人，所以如果普通人想要打破阶级到达另一个阶层，一定要练好自己的内功，时刻准备好不期而遇的机会，有些机会转瞬即逝，莫要留下终生遗憾。\n\n","tags":["读书"]},{"title":"2019-Book&Movie List","url":"%2F2019%2F01%2F06%2F2019-Book%26Movie%20List%2F","content":"\n## Book\n\n- [x] **人类简史 ❤️❤️❤️❤️❤️** \n- [x] 曾国藩 又笨又慢平天下 ❤️❤️❤️❤️\n- [ ] 基督山伯爵（重读）\n- [ ] **原则**\n- [x] **美国简史** ❤️❤️❤️❤️\n- [x] 士兵突击\n- [ ] Android 设计模式\n- [ ] **软技能(reading)**\n- [ ] **算法（第4版）**\n- [ ] Think in Java\n- [ ] 并发编程之美\n\n## Movie\n\n- [x] **无名之辈 ❤️❤️❤️❤️❤️**  \n- [x] 狗十三 ❤️❤️❤️\n- [x] **流浪地球 ❤️❤️❤️❤️**\n- [x] 来电狂响 \n- [x] 绿皮书 ❤️❤️❤️❤️❤️\n- [x] 白蛇缘起 ❤️❤️❤️❤️❤️  \n- [x] 掠食城市 ❤️\n- [x] 新喜剧之王 ❤️❤️\n- [x] 疯狂外星人 ❤️❤️❤️❤️\n- [x] **飞驰人生** ❤️❤️❤️❤️❤️ \n- [x] **复仇者联盟4** ❤️❤️❤️❤️❤️ \n- [ ] **X 战警 火凤凰**\n- [x] **辛德勒的名单** ❤️❤️❤️❤️❤️ \n- [ ] **拯救大兵瑞恩**\n- [x] 调音师 ❤️❤️❤️❤️\n- [x] 三傻大闹宝莱坞 ❤️❤️❤️❤️❤️ \n- [ ] 江湖儿女\n- [ ] 海市蜃楼\n- [ ] 过春天\n- [ ] 楚门的世界\n- [ ] 嗝嗝老师\n- [ ] 冠军\n- [ ] 黑客帝国\n\n## Tv\n\n- [x] 铁齿铜牙纪晓岚 第三部 \n- [x] 铁齿铜牙纪晓岚 第四部 \n- [x] 士兵突击 \n- [x] **王朝** ❤️❤️❤️❤️\n- [ ] **越南战争**\n- [ ] **第三帝国最后的秘密**\n- [x] **触及真心**\n- [ ] 我们与恶的距离 （watching)\n- [ ] 真探\n- [ ] 天空之城\n- [ ] 生活大爆炸最终季\n- [x] **无耻之徒第九季**\n\n\n\n\n","tags":["诗与远方"]},{"title":"RxJava2 是如何实现线程切换的（下）","url":"%2F2018%2F05%2F08%2FRxJava2%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%EF%BC%88%E4%B8%8B%EF%BC%89%2F","content":"\n\n## 前言\n\n通过前一篇的[RxJava2 是如何实现线程切换的 (上)](https://juejin.im/post/5a6751af6fb9a01cb2571794)我们已经知道了在RxJava中，subscribeOn 将上游线程切换到**指定的子线程**是如何实现的。这里就接着来看，observeOn 是如何将下游线程切换到指定线程的。\n\n<!--more-->\n\n## RxJava - subscribeOn\n\n这里可以通过UML图简单回顾一下subscribeOn的原理。\n\n\n![](https://user-gold-cdn.xitu.io/2018/1/23/16123a868c390ac1?w=1127&h=525&f=png&s=51911)\n\n通过 subscribeOn 我们完成了以下操作：\n\n - 创建了一个 ObservableSubscribeOn 对象，本质上来说他就是一个Observable，他同时实现了 AbstractObservableWithUpstream（HasUpstreamObservableSource ）这样一个接口，是他变了一个**拥有上游**的Observeable。\n - 在 ObservableSubscribeOn 的 subscribeActual 方法中\n\n```java\nparent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));\n```\n将真正的 subscribe 操作安置在了SubscribeTask这样个一个Runnable当中，这个 Runnable 将由scheduler 这个调度器负责启动，因此就把上游操作放到了 scheduler 所在的线程中。\n\n- Schedulers.newThread()或者Schedulers.io() 都是通过工厂方法的模式创建了某种**指定类型**的线程， 当这个特定的线程执行是，就是执行真实的 subscribe 方法，这样就把上游操作放到了一个特定的线程中去执行。\n\n## RxJava - observeOn\n\n简单回顾完 subscribeOn 之后，我们就来看看 observeOn 是如何工作的。\n\n**其实，了解 subscribeOn 的原理之后，再来看 observeOn 就简单多了，类的命名及实现思路都有很多相似之处，可以对照着理解**。\n\n![ObserveOn](https://user-gold-cdn.xitu.io/2018/6/4/163cb392e2328470?w=1280&h=616&f=png&s=215509)\n\nRxJava的代码写的非常巧妙，可以说是百读不厌，可以学习的地方特别多。为了避免陷入只见树木不见森林的噩梦，我们就带着以下问题去探索 observeOn 的奥秘。\n\n1. 在 Android 中线程间传递消息会使用 Handler，这里是否使用？又是如何使用的？\n2. AndroidSchedulers.mainThread() 做了什么 ？ \n3. 下游任务是如何保证被分配到指定线程的。\n\n#### 示例 \n\n```java\n\n    private void multiThread() {\n        Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"This msg from work thread :\" + Thread.currentThread().getName());\n                sb.append(\"\\nsubscribe: currentThreadName==\" + Thread.currentThread().getName());\n            }\n        })\n                .subscribeOn(Schedulers.newThread())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Consumer<String>() {\n                    @Override\n                    public void accept(String s) throws Exception {\n                        Log.e(TAG, \"accept: s= \" + s);\n                    }\n                });\n    }\n\n```\n\n我们还是以这段代码为例，来看看 observeOn 的工作原理。这里通过observeOn(AndroidSchedulers.mainThread())将下游线程切换到了我们非常熟悉的 Android UI 线程。这样就可以确保我们在下游所有的操作都是在 UI 线程中完成。这里和讨论 subscribeOn 一样，我们就从这句代码出发，看看这背后到底发生了什么。\n\n有了上一篇的经验，我们知道 AndroidSchedulers.mainThread() 一定去创建了某种类型的调度器，为了方便后面的叙述，这一次我们先从调度器的创建说起，后面再看 observeOn() 的具体实现。\n\n\n**需要注意的是 AndroidSchedulers 并不是 RxJava 的一部分，是为了在 Android 中方便的使用 RxJava 而专门设计的一个调度器实现，源码[RxAndroid](https://github.com/ReactiveX/RxAndroid) 设计非常巧妙；使用前记得在gradle文件中配置依赖。**\n\n\n### AndroidSchedulers.mainThread()\n\n下面就来看看 AndroidSchedulers.mainThread() 这个我们非常熟悉的 Scheduler 是如何创建的。\n\n```java\npublic final class AndroidSchedulers {\n\n    private static final class MainHolder {\n\n        static final Scheduler DEFAULT = new HandlerScheduler(new Handler(Looper.getMainLooper()));\n    }\n\n    private static final Scheduler MAIN_THREAD = RxAndroidPlugins.initMainThreadScheduler(\n            new Callable<Scheduler>() {\n                @Override public Scheduler call() throws Exception {\n                    return MainHolder.DEFAULT;\n                }\n            });\n\n    public static Scheduler mainThread() {\n        return RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);\n    }\n}\n```\n\n这里我们可以认为，当调用AndroidSchedulers.mainThread() 时，返回了一个HandlerScheduler 的实例，而这个实例使用到了我们非常熟悉的 Handler。那么重点就来到HandlerScheduler 了。\n\n\n```java\nfinal class HandlerScheduler extends Scheduler {\n    private final Handler handler;\n\n    HandlerScheduler(Handler handler) {\n        this.handler = handler;\n    }\n\n    @Override\n    public Disposable scheduleDirect(Runnable run, long delay, TimeUnit unit) {\n        if (run == null) throw new NullPointerException(\"run == null\");\n        if (unit == null) throw new NullPointerException(\"unit == null\");\n\n        run = RxJavaPlugins.onSchedule(run);\n        ScheduledRunnable scheduled = new ScheduledRunnable(handler, run);\n        handler.postDelayed(scheduled, Math.max(0L, unit.toMillis(delay)));\n        return scheduled;\n    }\n\n    @Override\n    public Worker createWorker() {\n        return new HandlerWorker(handler);\n    }\n\n    private static final class HandlerWorker extends Worker {\n        private final Handler handler;\n\n        private volatile boolean disposed;\n\n        HandlerWorker(Handler handler) {\n            this.handler = handler;\n        }\n\n        @Override\n        public Disposable schedule(Runnable run, long delay, TimeUnit unit) {\n            if (run == null) throw new NullPointerException(\"run == null\");\n            if (unit == null) throw new NullPointerException(\"unit == null\");\n\n            if (disposed) {\n                return Disposables.disposed();\n            }\n\n            run = RxJavaPlugins.onSchedule(run);\n\n            ScheduledRunnable scheduled = new ScheduledRunnable(handler, run);\n\n            Message message = Message.obtain(handler, scheduled);\n            message.obj = this; // Used as token for batch disposal of this worker's runnables.\n\n            handler.sendMessageDelayed(message, Math.max(0L, unit.toMillis(delay)));\n\n            // Re-check disposed state for removing in case we were racing a call to dispose().\n            if (disposed) {\n                handler.removeCallbacks(scheduled);\n                return Disposables.disposed();\n            }\n\n            return scheduled;\n        }\n\n        @Override\n        public void dispose() {\n            disposed = true;\n            handler.removeCallbacksAndMessages(this /* token */);\n        }\n\n        @Override\n        public boolean isDisposed() {\n            return disposed;\n        }\n    }\n\n    private static final class ScheduledRunnable implements Runnable, Disposable {\n        private final Handler handler;\n        private final Runnable delegate;\n\n        private volatile boolean disposed;\n\n        ScheduledRunnable(Handler handler, Runnable delegate) {\n            this.handler = handler;\n            this.delegate = delegate;\n        }\n\n        @Override\n        public void run() {\n            try {\n                delegate.run();\n            } catch (Throwable t) {\n                IllegalStateException ie =\n                    new IllegalStateException(\"Fatal Exception thrown on Scheduler.\", t);\n                RxJavaPlugins.onError(ie);\n                Thread thread = Thread.currentThread();\n                thread.getUncaughtExceptionHandler().uncaughtException(thread, ie);\n            }\n        }\n\n        @Override\n        public void dispose() {\n            disposed = true;\n            handler.removeCallbacks(this);\n        }\n\n        @Override\n        public boolean isDisposed() {\n            return disposed;\n        }\n    }\n}\n```\n这个类虽然很简单，但是设计非常巧妙。\n\n- **首先 HandlerScheduler 是一个 Scheduler ，通过构造函数他获取到了主线程所在的 Handler实例。而在他的 createWorker() 方法中，他又通过这个 Handler 实例创建了一个HandlerWorker 的实例，这个HandlerWorker 本质上就是一个 Worker。在他的 schedule 方法中，创建了一个 ScheduleRunnable 对象，并会把这个Runnable对象通过 handler 的 sendMessageDelayed 方法发送出去，而我们知道这个 Handler 是主线程，这样在下游中，就把任务从某个子线程转移到了UI线程。**\n\n\n- ScheduleRunnable 不但实现了 Runnable ，而且实现了我们看到过无数次的 Disposable 。\n\n```java\n        @Override\n        public void run() {\n            try {\n                delegate.run();\n            } catch (Throwable t) {\n\n            }\n        }\n\n        @Override\n        public void dispose() {\n            disposed = true;\n            handler.removeCallbacks(this);\n        }\n```\n这样，正确情况下 run 方法会正常执行线程中的任务，而一旦 disposable  对象执行了dispose()方法，那么 handler.removeCallbacks(this),就可确保在 handler 的 dispatchMessage 方法中，不会在执行任何操作，从而达到了 dispose 的效果。\n\n\n\n### observeOn\n \n下面就来看看 Observable 中的 observeOn 方法\n\n**Observable.java --- observeOn**\n\n```java\n\n    public final Observable<T> observeOn(Scheduler scheduler) {\n        return observeOn(scheduler, false, bufferSize());\n    }\n\n    public final Observable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");\n        return RxJavaPlugins.onAssembly(new ObservableObserveOn<T>(this, scheduler, delayError, bufferSize));\n    }\n```\n\n这个方法的实现和 subscribeOn 的实现非常相似，多了两个参数 delayError 和 buffersize 。 buffersize 可以认为是RxJava内部的一个静态变量，默认情况下他的值是128。通过我们之前的经验，这里可以把 observeOn 的过程简化如下：\n\n```java\nnew ObservableObserveOn<T>(this, scheduler, delayError, bufferSize)\n```\n也就是说 observeOn 这个操作符给我们返回了一个 ObservableObserveOn 对象。很容易想到他也是一个 Observeable。那么我们就去看看这个 ObservableObserveOn 到底是什么？我们最关心的 subscribeActual 方法他又是怎样实现的。\n\n\n\n#### ObservableObserveOn\n\n```java\npublic final class ObservableObserveOn<T> extends AbstractObservableWithUpstream<T, T> {\n    final Scheduler scheduler;\n    final boolean delayError;\n    final int bufferSize;\n    public ObservableObserveOn(ObservableSource<T> source, Scheduler scheduler, boolean delayError, int bufferSize) {\n        super(source);\n        this.scheduler = scheduler;\n        this.delayError = delayError;\n        this.bufferSize = bufferSize;\n    }\n\n    @Override\n    protected void subscribeActual(Observer<? super T> observer) {\n        if (scheduler instanceof TrampolineScheduler) {\n            source.subscribe(observer);\n        } else {\n            Scheduler.Worker w = scheduler.createWorker();\n\n            source.subscribe(new ObserveOnObserver<T>(observer, w, delayError, bufferSize));\n        }\n    }\n}\n\n```\n\n和 ObservableSubscribeOn 一样，他也继承了 AbstractObservableWithUpstream ，这样他也是一个拥有上游的 Observeable，他的构造函数很简单，没什么可以说。这里我们重点关注一下 subscribeActual 方法的实现。这里我们的使用的**Scheduler 实例是 AndroidSchedulers.mainThread()**，因此就按 else的逻辑分析。\n\n```java\n\n            Scheduler.Worker w = scheduler.createWorker();\n\n            source.subscribe(new ObserveOnObserver<T>(observer, w, delayError, bufferSize));\n```\n\n通过 scheduler.createWorker() 创建了 Worker 这个对象。这里结合之前对 AndroidSchedulers.mainThread() 的分析，此处的 worker 对象是就是一个持有主线程 handler 引用的 Worker。\n\n\n接着用这个worker又创建了一个ObserveOnObserver对象。看看这个类的实现。\n\n\n```java\n    static final class ObserveOnObserver<T> extends BasicIntQueueDisposable<T>\n    implements Observer<T>, Runnable { ....}\n```\n\n这个类功能非常强大，首先是一个 Observer ，同时也是一个Runnable，并且还继承了 BasicIntQueueDisposable(保证原子性、拥有操作队列功能和 Disposable功能)。\n\n```java\nsource.subscribe(new ObserveOnObserver<T>(observer, w, delayError, bufferSize));\n```\n\n我们关注一下这行代码，根据之前的说法这里的 source 是其父类(AbstractObservableWithUpstream)中的成员变量，也就是说是上游，那么当前ObservableObserveOn 的上游是谁呢？ 就是我们上一篇所说的 ObservableSubscribeOn 。\n\n因此，当这里开始执行订阅方法 subscribe() 后，将以如下顺序响应：\n\n\n>**Observable.subscribe--->Observable.subscribeActual---> ObservableObserveOn.subscribeActual---> ObservableSubscribeOn.subscribeActual--->ObservableCreate.subscribeActual**\n\n这些方法的参数均为 observer,通过层层回调，最后的 subscribeActual(Observer<? super T> observer) 执行时，这个 observer 持有之前几个 observer 的引用。\n\n我们再看一下 **ObservableCreate.subscribeActual**\n\n```java\n    @Override\n    protected void subscribeActual(Observer<? super T> observer) {\n        CreateEmitter<T> parent = new CreateEmitter<T>(observer);\n        observer.onSubscribe(parent);\n\n        try {\n            source.subscribe(parent);\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            parent.onError(ex);\n        }\n    }\n```\n\n可以看到，这里首先会触发 observer.onSubscribe ，我们再看一下 **ObservableSubscribeOn.subscribeActual**\n\n```java\n    @Override\n    public void subscribeActual(final Observer<? super T> s) {\n        final SubscribeOnObserver<T> parent = new SubscribeOnObserver<T>(s);\n\n        s.onSubscribe(parent);\n\n        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));\n    }\n```\n\n好了，这样我们又回到了原点：\n\n```java\nsource.subscribe(new ObserveOnObserver<T>(observer, w, delayError, bufferSize));\n```\n\n回到了最初的 Observer：**ObserveOnObserver**\n\n\n这个 ObserveOnObserver 持有我们一开始创建的observer，也就是一个Consumer对象。\n\n下面就来看看这个 ObserveOnObserver\n\n- 构造函数\n\n```java\n        ObserveOnObserver(Observer<? super T> actual, Scheduler.Worker worker, boolean delayError, int bufferSize) {\n            this.actual = actual;\n            this.worker = worker;\n            this.delayError = delayError;\n            this.bufferSize = bufferSize;\n        }\n```\n\n这里指的注意的一点 ，actual 其实就是observer\n\n- onSubscribe\n\n```java\n@Override\n        public void onSubscribe(Disposable s) {\n            if (DisposableHelper.validate(this.s, s)) {\n                this.s = s;\n\t\t\t\t// 现阶段，我们用到的Disposable 都是单个的，暂时不讨论其\n\t\t\t\t//为QueueDisposable的情况\n\n                queue = new SpscLinkedArrayQueue<T>(bufferSize);\n\n                actual.onSubscribe(this);\n            }\n        }\n```\n\n在**ObservableCreate.subscribeActual** 中我们知道，当执行subscribe 方法后，首先会执行 observer的 onSubscribe 方法。这里的实现非常简单，就是创建了一个queue,并触发了这个 observer 自己的 onSubscribe 方法。\n\n- onNext\n\n```java\n        @Override\n        public void onNext(T t) {\n            if (done) {\n                return;\n            }\n\n            if (sourceMode != QueueDisposable.ASYNC) {\n                queue.offer(t);\n            }\n            schedule();\n        }\n```\n\n在 onNext 中会执行 scheule() 方法。\n\n```java\n        void schedule() {\n            if (getAndIncrement() == 0) {\n                worker.schedule(this);\n            }\n        }\n```\n\n**这个地方就有意思了，前面说过这里的 worker 是一个持有主线程handler 的Worker对象，当他的 schedule 执行时，就会把特定的线程任务通过Handler.postDelay 方法转移到主线中去执行** 。\n\n那么这里的this 又是什么呢？前面我们说过，ObserveOnObserver 这个类功能非常强大，他是一个Runnable，那么这里就是执行他自己的run方法喽，我们赶紧看看。\n\n```java\n        @Override\n        public void run() {\n            if (outputFused) {\n                drainFused();\n            } else {\n                drainNormal();\n            }\n        }\n```\n\n这里有一个参数 outputFused 他默认是false，至于他什么时候为true，不作为这里讨论的重点。\n\n```java\nvoid drainNormal() {\n            int missed = 1;\n\n            final SimpleQueue<T> q = queue;\n            final Observer<? super T> a = actual;\n\n            for (;;) {\n                if (checkTerminated(done, q.isEmpty(), a)) {\n                    return;\n                }\n\n                for (;;) {\n                    boolean d = done;\n                    T v;\n\n                    try {\n                        v = q.poll();\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        s.dispose();\n                        q.clear();\n                        a.onError(ex);\n                        worker.dispose();\n                        return;\n                    }\n                    boolean empty = v == null;\n\n                    if (checkTerminated(d, empty, a)) {\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    a.onNext(v);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n```\n\n这里大概就是通过一个死循环，不断从 onSubscribe 方法中创建的队列中取出事件，执行observer 的 onNext方法。而当为例为空时，就会执行worker.dispose 取消整个事件流，同时从Handler中移除所有消息。\n\n最后在看一眼 onComplete ,onError 和整个类似\n\n```java\n        @Override\n        public void onComplete() {\n            if (done) {\n                return;\n            }\n            done = true;\n            schedule();\n        }\n```\n可以看到这里的处理也很简单，done 设置为 true .这样最后便完成了下游事件的执行。\n\n## 最后\n\n好了，由于一些无以诉说的原因，经历了很久终于把 RxJava 线程切换的下篇给完成了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["RxJava2"],"categories":["Android 进阶"]},{"title":"2018-Book&Movie List","url":"%2F2018%2F03%2F01%2F2018-Book%26Movie%20List%2F","content":"\n## Book\n\n- [x] 大数据时代[维克托.迈尔]\n- [x] 半小时漫画世界史[二混子]\n- [x] 我长得丑，你们都得让着我[唐梓严]\n- [x] 枪炮细菌与钢铁\n- [x] 三体 [刘慈欣]\n- [x] 爵迹 [郭敬明]\n- [x] 时间简史 （霍金）\n- [x] 人间失格 \n\n\n- [x] Java 8 实战\n- [x] Android Gradle 实战\n- [x] Clean Code\n\n## Movie\n\n- [x] 三块广告牌\n- [x] 西游记-女儿国\n- [x] 复仇者联盟3\n- [x] 红海行动\n- [x] 宫崎骏-起风了\n- [x] 至暗时刻\n- [x] 魔女宅急便\n- [x] 老男孩（美版）\n- [x] 黑豹\n- [x] 瞒天过海：美人计\n- [x] 无问西东\n- [x] 红高粱\n- [x] 蚁人2\n- [x] 詹妮弗的肉体\n- [x] 爵迹\n- [x] 我不是药神\n- [x] 一出好戏\n- [x] 边境杀手2\n- [x] 蜘蛛侠：平行宇宙\n- [x] 闪光少女\n- [x] 名侦探柯南剧场版- 零的执行人\n- [x] 无双\n\n## Tv\n\n- [x] 白夜追凶\n- [x] 足球小将 100 集\n- [x] 生活大爆炸 season-11\n- [x] 摩登家庭 season-01\n- [x] 中国好声音 2018\n- [x] 铁齿铜牙纪晓岚 第一部 + 第二部\n\n","tags":["读书"]},{"title":"RxJava2 是如何实现线程切换的 (上)","url":"%2F2018%2F01%2F23%2FRxJava2%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%EF%BC%88%E4%B8%8A%EF%BC%89%2F","content":"\n\n## 前言\n\n\n\n通过前一篇的[从观察者模式出发，聊聊RxJava](https://juejin.im/post/5a521d68f265da3e4e25750e),我们大致理解了RxJava的实现原理，在RxJava中可以非常方便的实现不同线程间的切换。subscribeOn 用于指定上游线程，observeOn 用于指定下游线程，多次用 subscribeOn 指定上游线程只有第一次有效，多次用 observeOn 指定下次线程，每次都有效；简直太方便了，比直接使用Handler省了不少力气，同时也不用去关注内存泄漏的问题了。本篇就来看看在RxJava中上游是如何实现线程切换。\n\n\n<!--more-->\n\n## RxJava 基础原理\n\n为了方便后面的叙述，这里通过下面的UML图简单回顾一下上一篇的内容。\n\n\n![](https://user-gold-cdn.xitu.io/2018/1/23/161239920cc6b9d9?w=910&h=525&f=png&s=42043)\n\n*此图并没有完整的展现图中各个接口和类之间的各种关系，因为那样会导致整个图错综复杂，不便于查看，这里只绘制出了RxJava各个类之间核心关系网络*\n\n\n\n从上面的UML图中可以看出，具体的实现类只有ObservableCreate和CreateEmitter。CreateEmitter是ObservableCreate的内部类（PlantUML 怎么绘制内部类，没搞懂，玩的转的同学请赐教呀(*^▽^*)）。\n\n上篇说过Observable创建的过程，可以简化如下：\n\n```java\n  Observable mObservable=new ObservableCreate(new ObservableOnSubscribe())\n```\n结合图可以更直观的体现出这一点。ObservableCreate 内部持有ObservableOnSubscribe的引用。\n\n当观察者订阅主题后：\n\n```java\nmObservable.subscribe(mObserver);\n```\nObservableCreate 中的subscribeActual()方法就会执行，\n\n\n```java\n    protected void subscribeActual(Observer<? super T> observer) {\n        CreateEmitter<T> parent = new CreateEmitter<T>(observer);\n        observer.onSubscribe(parent);\n\n        try {\n            source.subscribe(parent);\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            parent.onError(ex);\n        }\n    }\n\n```\n\n在这个过程中会创建CreateEmitter 的实例，而这个CreateEmitter实现了Emitter和Disposable接口，同时又持有Observer的引用（当然这个引用是ObservableCreate传递给他的）。**接着就会执行ObservableOnSubscribe的subscribe 方法**，方法的参数即为刚刚创建的CreateEmitter 的实例，接着一系列连锁反应，Emitter 接口中的方法（onNext,onComplete等）开始执行，在CreateEmitter内部，Observer接口中对应的方法依次执行，这样就实现了一次从主题（上游）到观察者（下游）的事件传递。\n\n\n**source.subscribe(parent)** \n\n这里的 source 是ObservableOnSubscribe的实例，parent是CreateEmitter的实例。上面加粗文本叙述的内容，就是这行代码，可以说这是整个订阅过程最核心的实现。\n\n好了，回顾完基础知识后，马上进入正题，看看RxJava是如何实现线程切换的。\n\n\n\n\n\n## RxJava 之 subscribeOn\n我们知道正常情况下，所有的内容都是在主线程执行，既然这里提到了线程切换，那么必然是切换到了子线程，因此，这里需要关注线程的问题，我们就带着下面这几个问题去阅读代码。\n\n- 1.**是哪个对象在什么时候创建了子线程，是一种怎样的方式创建的？**\n- 2.**子线程又是如何启动的？**\n- 3.**上游事件是怎么跑到子线程里执行的？**\n- 4.**多次用 subscribeOn 指定上游线程为什么只有第一次有效 ?**\n\n\n### 示例 \n\n首先看一下，日常开发中实现线程切换的具体实现\n\n```java\n\n    private void multiThread() {\n        Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"This msg from work thread :\" + Thread.currentThread().getName());\n                sb.append(\"\\nsubscribe: currentThreadName==\" + Thread.currentThread().getName());\n            }\n        })\n                .subscribeOn(Schedulers.newThread())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Consumer<String>() {\n                    @Override\n                    public void accept(String s) throws Exception {\n                        Log.e(TAG, \"accept: s= \" + s);\n                    }\n                });\n    }\n\n```\n这段代码，使用过RxJava的同学再熟悉不过了，上游事件会在一个名为 RxNewThreadScheduler-1 的线程执行，下游线程会切换回我们熟悉的Android UI线程。\n\n我们就从subscribeOn(Schedulers.newThread()) 出发，看看这个代码的背后，到底发生了什么。\n\n![](https://user-gold-cdn.xitu.io/2018/1/23/161239e8d8af610b?w=1280&h=610&f=png&s=218709)\n### subscribeOn\n\n这里我们先不管Schedulers.newThread() 是什么鬼，首先看看这个subscribeOn()方法。\n\n\n**Observable.java---  subscribeOn(Scheduler scheduler)**\n\n```java\n    public final Observable<T> subscribeOn(Scheduler scheduler) {\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaPlugins.onAssembly(new ObservableSubscribeOn<T>(this, scheduler));\n    }\n```\n\n可以看到，这个方法需要一个Scheduler 类型的参数。\n\n**RxJavaPlugins.java--- onAssembly(@NonNull Observable<T> source)**\n\n```java\n    public static <T> Observable<T> onAssembly(@NonNull Observable<T> source) {\n        Function<? super Observable, ? extends Observable> f = onObservableAssembly;\n        if (f != null) {\n            return apply(f, source);\n        }\n        return source;\n    }\n```\n\nO(∩_∩)O哈哈~，是不是觉得似曾相识，和create操作符一个套路呀。因此，observeOn也可以简化如下：\n\n```java\nnew ObservableSubscribeOn<T>(this, Schedulers.newThread());\n```\n这里你也许会有疑问，这个this是什么呢？其实这个this就是Observable，具体到上面的代码来说就是ObservableCreate，总之就是一个具体的Observable。\n\n接着看ObservableSubscribeOn 这个类\n\n```java\npublic final class ObservableSubscribeOn<T> extends AbstractObservableWithUpstream<T, T> {\n}\n\n```\n\n看一下 **AbstractObservableWithUpstream.java**\n\n```java\n\nabstract class AbstractObservableWithUpstream<T, U> extends Observable<U> implements HasUpstreamObservableSource<T> {\n\n    /** The source consumable Observable. */\n    protected final ObservableSource<T> source;\n\n    AbstractObservableWithUpstream(ObservableSource<T> source) {\n        this.source = source;\n    }\n\n    @Override\n    public final ObservableSource<T> source() {\n        return source;\n    }\n\n}\n```\n\n再看一下 **HasUpstreamObservableSource.java**\n\n```java\n/**\n * Interface indicating the implementor has an upstream ObservableSource-like source available\n * via {@link #source()} method.\n *\n * @param <T> the value type\n */\npublic interface HasUpstreamObservableSource<T> {\n    /**\n     * Returns the upstream source of this Observable.\n     * <p>Allows discovering the chain of observables.\n     * @return the source ObservableSource\n     */\n    ObservableSource<T> source();\n}\n```\n\n饶了半天，ObservableSubscribeOn 原来和上一篇说的ObservableCreate一样，也是Observable的一个子类。只不过比ObservableCreate多实现了一个接口HasUpstreamObservableSource，这个接口很有意思，他的source()方法返回类型是ObservableSource（还记得这个类的角色吗？）。也就是说ObservableSubscribeOn这个Observable是一个拥有上游的Observable。他有一个非常关键的方法source()，这个方法的返回值就是ObservableSource，也就是说通过调用实现source方法，可以获取到上游的Observeable。**AbstractObservableWithUpstream类继承HasUpstreamObservableSource 并实现了这个source方法，返回结果为ObservableSource，是通过其构造函数获取。**，那么AbstractObservableWithUpstream的构造函数又是在哪里调用的呢？\n\n我们接着看ObservableSubscribeOn的具体实现。\n\n```java\npublic final class ObservableSubscribeOn<T> extends AbstractObservableWithUpstream<T, T> {\n    final Scheduler scheduler;\n\n    public ObservableSubscribeOn(ObservableSource<T> source, Scheduler scheduler) {\n        super(source);\n        this.scheduler = scheduler;\n    }\n\n    @Override\n    public void subscribeActual(final Observer<? super T> s) {\n        final SubscribeOnObserver<T> parent = new SubscribeOnObserver<T>(s);\n\t\t// observer 调用onSubscribe方法，获取上游的控制权\n        s.onSubscribe(parent);\n\n        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));\n    }\n}\n```\n\n- 首先看他的构造函数，参数source就是我们之前提到过的this，scheduler就是Schedulers.newThread()。同时调用了父类AbstractObservableWithUpstream的构造函数，这里结合之前的结论，我们可以确定通过这个构造函数，就创建出来了一个包含上游的ObservableSubscribeOn实例。\n- 再看实现订阅关系的关键方法subscribeActual()，在这里创建了一个SubscribeOnObserver的实例，SubscribeOnObserver 是AtomicReference的子类(保证原子性)，同时实现了 Observer接口 和 Disposable 接口；你可以把他理解成一个Observer。\n\n我们之前说过，subscribeActual()是实现上下游之间订阅关系的重要方法。因为只有真正实现了订阅关系，上下游之间才能连接起来。我们看这个方法的最后一句代码。\n\n```java\n parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));\n```\n这句代码，可以说就是非常关键，因为从这里开始了一系列的连锁反应。首先看一下SubscribeTask\n\n\n```java\n    final class SubscribeTask implements Runnable {\n        private final SubscribeOnObserver<T> parent;\n\n        SubscribeTask(SubscribeOnObserver<T> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void run() {\n            source.subscribe(parent);\n        }\n    }\n```\n\n看到这句 **source.subscribe(parent)**，是不是觉得似曾相识呢？\n\n\nSubscribeTask 实现了是Runnable接口，在其run方法中，定义了一个需要在线程中执行的任务。按照类的继承关系，很明显source 就是ObservableSubscribeOn 的上游Observable，parent是一个Observer。也就是说这个run方法要执行的内容就是实现ObservableSubscribeOn的上游和Observer的订阅。**一旦某个线程执行了这个Runnable（SubscribeTask），就会触发了这个run方法，从而实现订阅**，而一旦这个订阅实现，那么后面的流程就是上节所说的事情了。\n\n**这里可以解答第三个问题了，上游事件是怎么给弄到子线程里去的，这里很明显了，就是直接把订阅方法放在了一个Runnable中去执行，这样就一旦这个Runnable在某个子线程执行，那么上游所有事件只能在这个子线程中执行了。**\n \n好了，线程要执行的任务**似乎**创建完了，下面就接着找看看子线程是怎么创建的。回过头继续看刚才的方法，\n\n```java\nscheduler.scheduleDirect(new SubscribeTask(parent))\n```\n\n**Scheduler.java----scheduleDirect**\n\n```java\n\n    public Disposable scheduleDirect(@NonNull Runnable run) {\n        return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);\n    }\n\n\n    public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {\n        final Worker w = createWorker();\n\t\t// 对run进行了一次装饰\n        final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\n\n        DisposeTask task = new DisposeTask(decoratedRun, w);\n\n        w.schedule(task, delay, unit);\n\n        return task;\n    }\n\n\t@NonNull\n\t// 抽象方法\n    public abstract Worker createWorker();\n```\n\n首先看一下Worker类\n\n```java\n    /**\n     * Sequential Scheduler for executing actions on a single thread or event loop.\n     * <p>\n     * Disposing the {@link Worker} cancels all outstanding work and allows resource cleanup.\n     */\n    public abstract static class Worker implements Disposable {\n  \n        @NonNull\n        public Disposable schedule(@NonNull Runnable run) {\n            return schedule(run, 0L, TimeUnit.NANOSECONDS);\n        }\n\n  \n        @NonNull\n        public abstract Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit);\n\n        \n    }\n\n```\n\nWorker是Scheduler内部的一个静态抽象类，实现了Disposable接口，其schedule()方法也是抽象的。\n\n\n再看一下DisposeTask \n\n\n```java\nstatic final class DisposeTask implements Runnable, Disposable {\n        final Runnable decoratedRun;\n        final Worker w;\n\n        Thread runner;\n\n        DisposeTask(Runnable decoratedRun, Worker w) {\n            this.decoratedRun = decoratedRun;\n            this.w = w;\n        }\n\n        @Override\n        public void run() {\n            runner = Thread.currentThread();\n            try {\n                decoratedRun.run();\n            } finally {\n                dispose();\n                runner = null;\n            }\n        }\n\n        @Override\n        public void dispose() {\n            if (runner == Thread.currentThread() && w instanceof NewThreadWorker) {\n                ((NewThreadWorker)w).shutdown();\n            } else {\n                w.dispose();\n            }\n        }\n\n        @Override\n        public boolean isDisposed() {\n            return w.isDisposed();\n        }\n    }\n\n```\nDisposeTask 又是一个Runnable，同时也实现了Disposable接口。可以看到在他的run方法中会执行decoratedRun的run方法，这个decoratedRun其实就是参数中传递进来的run，**也就是说，执行了这个DisposeTask的run方法，就会触发SubscribeTask中的run方法**，因此，我们就要关注是谁执行了这个DisposeTask。\n\n\n\n回到scheduleDirect()方法\n\n\n```java\n    public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {\n        final Worker w = createWorker();\n\t\t// 对run进行了一次装饰\n        final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\n\n        DisposeTask task = new DisposeTask(decoratedRun, w);\n\n        w.schedule(task, delay, unit);\n\n        return task;\n    }\n```\n\n\nscheduleDirect()方法的实现我们总结一下：\n\n1. 创建一个Worker对象w,而在Scheduler类中createWorker()方法被定义为抽象方法，因此我们需要去Scheduler的具体实现中了解这个Worker的具体实现。\n2. 对参数run通过RxJavaPlugins进行一次装饰，生成一个decoratedRun的Runnable（通过源码可以发现，其实什么也没干，就是原样返回）\n3. 通过decoratedRun和w生成一个DisposeTask对象task\n4. **通过Worker的schedule方法开始执行这个task。**\n\n\nε=(´ο｀*)))唉，说了这么久，子线程是如何创建的依然不清楚，无论是SubscribeTask还是DisposeTask只是定义会在某个子线程中执行的任务，并不代表子线程已被创建。但是通过以上代码，我们也可以收获一些有价值的结论：\n\n- 最终的Runnable任务，将由某个具体的Worker对象的scheduler()方法执行。\n- 这个scheduleDirect会返回一个Disposable对象，这样我们就可以通过Observer去控制整个上游的执行了。\n\n好了，到这里对于subscribeOn()方法的分析已经到了尽头，我们找了最终需要运行子任务的对象Worker,而这个Worker是个抽象类，因此我们需要关注Worker的具体实现了。\n\n下面我们就从刚才丢下的Schedulers.newThread() 换个角度来分析，看看能不能找到这个Worker的具体实现。\n\n\n## Schedulers.newThread()\n\n前面说了subscribeOn()方法需要一个Scheduler 类型的参数，然而通过前面的分析我们知道Scheduler是个抽象类，是无法被实例化的。因此，这里就从Schedulers类出发。\n\n\n```java\n/**\n * Static factory methods for returning standard Scheduler instances.\n */\npublic final class Schedulers {\n}\n```\n\n注释很清楚，这个Schedulers就是一个用于生成Scheduler实例的静态工厂。\n\n下面我们就来看看，在这个工厂中newThread() 生成了一个什么样的Scheduler实例。\n\n```java\n    @NonNull\n    public static Scheduler newThread() {\n        return RxJavaPlugins.onNewThreadScheduler(NEW_THREAD);\n    }\n\n\tNEW_THREAD = RxJavaPlugins.initNewThreadScheduler(new NewThreadTask());\n\n    static final class NewThreadTask implements Callable<Scheduler> {\n        @Override\n        public Scheduler call() throws Exception {\n            return NewThreadHolder.DEFAULT;\n        }\n    }\n\n    static final class NewThreadHolder {\n        static final Scheduler DEFAULT = new NewThreadScheduler();\n    }\n```\n\nnewThread() 方法经过层层委托处理(最终的创建方式，有点单例模式的意味)，最终我们需要的就是一个NewThreadScheduler的实例。\n\n**NewThreadScheduler.java**\n\n```java\npublic final class NewThreadScheduler extends Scheduler {\n\n    final ThreadFactory threadFactory;\n\n    private static final String THREAD_NAME_PREFIX = \"RxNewThreadScheduler\";\n    private static final RxThreadFactory THREAD_FACTORY;\n\n    /** The name of the system property for setting the thread priority for this Scheduler. */\n    private static final String KEY_NEWTHREAD_PRIORITY = \"rx2.newthread-priority\";\n\n    static {\n        int priority = Math.max(Thread.MIN_PRIORITY, Math.min(Thread.MAX_PRIORITY,\n                Integer.getInteger(KEY_NEWTHREAD_PRIORITY, Thread.NORM_PRIORITY)));\n\n        THREAD_FACTORY = new RxThreadFactory(THREAD_NAME_PREFIX, priority);\n    }\n\n    public NewThreadScheduler() {\n        this(THREAD_FACTORY);\n    }\n\n    public NewThreadScheduler(ThreadFactory threadFactory) {\n        this.threadFactory = threadFactory;\n    }\n\n    @NonNull\n    @Override\n    public Worker createWorker() {\n        return new NewThreadWorker(threadFactory);\n    }\n}\n```\n不出所料NewThreadScheduler 是Scheduler的一个子类，在他的静态代码块中构造了一个Priority=5的线程工厂。而在我们最最关注的**createWorker()方法中他又用这个线程工厂创建了一个NewThreadWorker 的实例**。下面就让我们看看最终的NewThreadWorker 做了些什么工作。\n\n**NewThreadWorker.java**(节选关键内容)\n\n```java\n\npublic class NewThreadWorker extends Scheduler.Worker implements Disposable {\n    private final ScheduledExecutorService executor;\n\n    volatile boolean disposed;\n\n    public NewThreadWorker(ThreadFactory threadFactory) {\n        executor = SchedulerPoolFactory.create(threadFactory);\n    }\n\n    @NonNull\n    @Override\n    public Disposable schedule(@NonNull final Runnable run) {\n        return schedule(run, 0, null);\n    }\n\n    \n\n    @Override\n    public void dispose() {\n        if (!disposed) {\n            disposed = true;\n            executor.shutdownNow();\n        }\n    }\n\n}\n```\n\n众里寻他千百度，终于找到了Worker的实现了，同时再一次不出所料的又一次实现了Disposable接口，o(╥﹏╥)o。\n\n\n在其构造函数中，通过NewThreadScheduler中提供的线程工厂threadFactory创建了一个ScheduledExecutorService。\n\n\n**ScheduledExecutorService.java ---create**\n\n```java\n\n    public static ScheduledExecutorService create(ThreadFactory factory) {\n        final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory);\n        if (PURGE_ENABLED && exec instanceof ScheduledThreadPoolExecutor) {\n            ScheduledThreadPoolExecutor e = (ScheduledThreadPoolExecutor) exec;\n            POOLS.put(e, exec);\n        }\n        return exec;\n    }\n```\n\n用大名鼎鼎的Executors(Executor的工具类)，创建了一个核心线程为1的线程。 \n\n**至此，我们终于找到了第一个问题的答案，子线程是谁如何创建的；在NewThreadScheduler的createWorker()方法中，通过其构建好的线程工厂，在Worker实现类的构造函数中创建了一个ScheduledExecutorService的实例，是通过SchedulerPoolFactory创建的。**\n\n同时可以看到，通过执行dispose 方法，可以使用ScheduledExecutorService的shutdown()方法，停止线程的执行。\n\n线程已经创建好了，下面就来看看到底是谁启动了这个线程。前面我们说过，Worker的schedule()方法如果执行了，就会执行我们定义好的Runnable，通过这个Runnable中run方法的执行，就可以实现上下游订阅关系。下面就来看看这个scheduler()方法。\n\n```java\n@NonNull\n    @Override\n    public Disposable schedule(@NonNull final Runnable action, long delayTime, @NonNull TimeUnit unit) {\n        if (disposed) {\n            return EmptyDisposable.INSTANCE;\n        }\n        return scheduleActual(action, delayTime, unit, null);\n    }\n\n    @NonNull\n    public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) {\n        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);\n\n        ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent);\n\n        if (parent != null) {\n            if (!parent.add(sr)) {\n                return sr;\n            }\n        }\n\n        Future<?> f;\n        try {\n            if (delayTime <= 0) {\n                f = executor.submit((Callable<Object>)sr);\n            } else {\n                f = executor.schedule((Callable<Object>)sr, delayTime, unit);\n            }\n            sr.setFuture(f);\n        } catch (RejectedExecutionException ex) {\n            if (parent != null) {\n                parent.remove(sr);\n            }\n            RxJavaPlugins.onError(ex);\n        }\n\n        return sr;\n    }\n```\n\n到这里，已经很明显了，在schedulerActual方法中，会通过刚才创建好的子线程对象executor通过submit或schedule执行一个Runnable任务（虽然这个Runnable对象再一次经过了各种装饰和包装，但其本质没有发生变化），并将执行结果封装后返回。而这个Runnable对象追根溯源来说，就是我们在ObservableSubscribeOn类中创建的一个SubscribeTask对象。因此，当这个子线程开始运行的时候就是执行SubscribeTask中run()方法的时机；一旦这个run方法执行，那么\n\n```java\nsource.subscribe(parent)\n```\n这句最关键的代码就开始执行了，一切的一切又回到了我们上一篇那熟悉的流程了。\n\n好了，按照上面的流程捋下来，感觉还是有点分散，那么就用UML图看看整体的结构。\n\n\n![](https://user-gold-cdn.xitu.io/2018/1/23/16123a868c390ac1?w=1127&h=525&f=png&s=51911)\n\n\n\n我们看最下面的ObservableSubscribeOn，**他是subscribeOn 返回的Observable对象，他持有一个Scheduler 实例的引用，而这个Scheduler实例就是NewThreadScheduler(即Schedulers.newThreade())的一个实例。ObservableSubscribeOn 的subscribeActual方法，会触发NewThreadScheduler去执行SubscribeTask中定义的任务，而这个具体的任务又将由Worker类创建的子线程去执行。这样就把上游事件放到了一个子线程中实现。**\n\n\n至于最后一个问题，**多次用 subscribeOn 指定上游线程为什么只有第一次有效?**，看完通篇其实也很好理解了，因为上游Observable只有一个任务，就是subscribe(准确的来说是subscribeActual()），而subscribeOn 要做的事情就是把上游任务切换到一个指定线程里，那么一旦被切换到了某个指定的线程里，后面的切换不就是没有意义了吗。\n\n好了，至此上游事件切换到子线程的过程我们就明白了。下游事件又是如何切换的且听下回分解，本来想一篇写完的，结果发现越写越多，只能分成两篇了！！！o(╯□╰)o。\n\n\n## 写在后面的话\n\n\n####  关于Disposable\n\n在RxJava的分析中，我们经常会遇到Disposable这个单词，确切的说是接口，这里简单说一说这个接口。\n\n```java\n/**\n * Represents a disposable resource.\n */\npublic interface Disposable {\n    void dispose();\n    boolean isDisposed();\n}\n```\n\n我们知道，在Java中，类实现某个接口，通俗来说就是代表这个类多了一项功能，比如一个类实现Serializable接口，代表这个类是可以序列化的。这里Disposable也是代表一种能力，这个能力就是Disposable，就是代表一次性的，用后就丢弃的，比如一次性筷子，还有那啥。\n\n在RxJava中很多类都实现了这个接口，这个接口有两个方法，isDisposed()顾名思义返回当前类是否被抛弃，dispose()就是主动抛弃。因此，所有实现了这个接口的类，都拥有了这样一种能力，就是可以判断自己是否被抛弃，同时也可以主动抛弃自己。\n\n上一篇我们说了，Observer通过onSubscribe(@NonNull Disposable d)，会获得一个Disposable，这样就有能力控制上游的事件发送了。这样，我们就不难理解，为什么那么多类实现了这个接口，因为下游获取到的是一个拥有Disposable的对象，而一旦拥有了一个这样的对象，那么就可以通过下游控制上游了。可以说，这是RxJava对常规的观察者模式所做的最给力的改变。\n\n\n#### 关于各种ObservableXXX ,subscribeXXX,ObserverXXX \n\n在查看RxJava的源码时，可能很多人都和我一样，有一个巨大的困扰，就是这些类的名字好他妈难记，感觉长得都差不多，关键念起来好像也差不多。但其实本质上来说，RxJava对类的命名还是非常规范的，只是我们不太习惯而已。按照英文单词翻译：\n\n- Observable 可观察的（主题 ，上游）\n- Observer   观察者 （订阅者，下游）\n- Subscribe  订阅\n\n其实就这么三个主语，其他的什么ObservableCreate，ObservableSubscribeOn，AbstractObservableWithUpstream，还有上面提到的Disposable，都是对各种各样的Observable和Observer的变形和修饰结果，只要理解这个类的核心含义是什么，就不会被这些名字搞晕了。\n\n\nRxJava 可以说是博大精深，以上所有分析完全是个人平时使用时的总结与感悟，有任何错误之处，还望各位读者提出，共同进步。\n\n关于RxJava 这里墙裂推荐一篇文章[一篇不太一样的RxJava介绍](https://juejin.im/post/5a2549576fb9a04519696d45)，感觉是自扔物线那篇之后，对RxJava思想感悟最深的一篇了。对RxJava 有兴趣的同学，可以多度几遍，每次都会有收获！！\n\n***\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["RxJava2"],"categories":["Android 进阶"]},{"title":"从观察者模式出发，聊聊RxJava2","url":"%2F2018%2F01%2F12%2F%E4%BB%8E%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%87%BA%E5%8F%91%EF%BC%8C%E8%81%8A%E8%81%8ARxJava%2F","content":"\n\n## 前言\n\n### RxJava 是什么\n\n>RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.\n\n以上是RxJava在[Github](https://github.com/ReactiveX/RxJava)上的介绍，大概意思是，**针对于JVM(Java虚拟机）的响应式扩展实现，一个在Java VM上使用可观察的序列来组合实现异步的、基于事件编程的库。**\n\n<!--more-->\n\nRxJava现在大家用的都应该已经很溜了，用法这里就不再多说了。我们都知道RxJava是对**观察者模式**的扩展，下面就从观察者模式的实现机制出发，了解一下RxJava2的实现逻辑。只有真正了解了RxJava 的实现原理，我们才能在遇到问题的时候，更快速更准确的定位的到问题。\n\n> 此次源码分析基于 [RxJava Release 2.1.7](https://github.com/ReactiveX/RxJava/releases/tag/v2.1.7)\n\n\n### 观察者模式\n\n这里简单回顾一下观察者模式的组成及使用方式，通过之前[观察者模式](https://www.jianshu.com/p/6fcce09cc1ce)一文中的分析，我们知道观察者模式中有四个重要的角色：\n\n- 抽象主题：**定义添加和删除观察者的功能，也就是注册和解除注册的功能**\n- 抽象观察者：**定义观察者收到主题通知后要做什么事情**\n- 具体主题：**抽象主题的实现**\n- 具体观察者：**抽象观察者的实现**\n\n当我们创建好了具体主题和观察者类，就可以使用观察者模式了，下面是一个最简单的测试demo。\n\n```java\npublic class TestObservePattern {\n\n    public static void main(String[] args) {\n\t\t// 创建主题(被观察者)\n        ConcreteSubject concreteSubject = new ConcreteSubject();\n\t\t// 创建观察者\n        ObserverOne observerOne=new ObserverOne();\n        // 为主题添加观察者\n        concreteSubject.addObserver(observerOne);        \n        //主题通知所有的观察者\n        concreteSubject.notifyAllObserver(\"wake up,wake up\");\n    }\n\n}\n```\n\n以上就是观察者模式的使用方式，很简单是吧。现在就让我们带着以下几个问题，看看RxJava是如何使用观察者模式的。\n\n用RxJava这么久了，你可以思考一下如下几个问题：\n\n1. RxJava 中上面提到的四个重要角色是如何定义的？\n2. RxJava 中具体的主题，具体的观察者是如何实例化的？\n3. RxJava 中观察者和主题是如何实现订阅的？\n4. RxJava 中上游是怎么发送事件的，下游又是怎样接收到的?\n5. RxJava 中对常规的观察者模式做了怎样调整，带来了什么好处？\n\n*如果对以上几个问题，你有明确的答案，恭喜你，以下内容你就不用再看了，O(∩_∩)O哈哈~。*\n\n>很多开发者对RxJava的学习可能是从**上游**和**下游**的角度开始，这里可以认为这样的叙述更偏重RxJava 事件序列的特征。本文从**被观察者（主题）**和**观察者**的角度出发，可以说是更偏向于RxJava 观察者模式的特征。这里的主题就是上游，观察者就是下游。无论从哪个角度出发去理解，源码就那么一份，无所谓对错，只是每个人的认知角度不同而已，选择一种自己更容易了解的方式即可。\n\n好了，如果你看到了这里，说明你对以上几个问题，还有些许疑问，那么我们就从这几个问题出发，了解一下RxJava的源码实现。\n\n## RxJava2 的观察者模式实现\n\n我们就带着上述几个问题，依次来看看RxJava到底是怎么一回事儿。为了方便叙述和记忆，我们首先看一段RxJava2 最最基础的使用方式。\n\n\n```java\nprivate void basicRxjava2() {\n        Observable mObservable = Observable.create(new ObservableOnSubscribe() {\n            @Override\n            public void subscribe(ObservableEmitter e) throws Exception {\n                e.onNext(\"1\");\n                e.onNext(\"2\");\n                e.onNext(\"3\");\n                e.onNext(\"4\");\n                e.onComplete();\n            }\n        });\n\n        Observer mObserver = new Observer() {\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.e(TAG, \"onSubscribe: d=\" + d);\n                sb.append(\"\\nonSubcribe: d=\" + d);\n            }\n\n            @Override\n            public void onNext(Object s) {\n                Log.e(TAG, \"onNext: \" + s);\n                sb.append(\"\\nonNext: \" + s);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                Log.e(TAG, \"onError: \" + e);\n                sb.append(\"\\nonError: \" + e.toString());\n                logContent.setText(sb.toString());\n            }\n\n            @Override\n            public void onComplete() {\n                Log.e(TAG, \"onComplete\");\n                sb.append(\"\\nonComplete: \");\n                logContent.setText(sb.toString());\n            }\n        };\n\n        mObservable.subscribe(mObserver);\n    }\n```\n\n上面这段代码，应该很容易理解了，输出结果大家闭着眼睛也能想出来吧。我们就以这段代码为基础，结合上面提到的问题依次展开对RxJava的分析。\n\n#### 四个重要的角色\n\n首先看看RxJava 中四个重要的角色是如何定义的。\n\n- 抽象主题\n\n首先可以看看这个Observable类。\n\n```java\npublic abstract class Observable<T> implements ObservableSource<T> {\n……\n}\n```\n他实现了ObservableSource接口，接着看ObservableSource\n\n```java\npublic interface ObservableSource<T> {\n\n    /**\n     * Subscribes the given Observer to this ObservableSource instance.\n     * @param observer the Observer, not null\n     * @throws NullPointerException if {@code observer} is null\n     */\n    void subscribe(@NonNull Observer<? super T> observer);\n}\n```\n\n这里很明显了，ObservableSource 就是抽象主题（被观察者）的角色。按照之前观察者模式中约定的职责，subscribe 方法就是用来实现订阅观察者（Observer）角色的功能。从这里我们也可以看出，抽象观察者的角色就是Observer了。\n\n这里，你也许会有疑问，这么简单？抽象主题（上游）不是需要发送事件吗？onNext(),onComplete()以及onError()跑哪儿去了？别着急，我们后面慢慢看。\n\n- 具体主题\n\n回过头来继续看Observable，他实现了ObservableSource接口，并且实现了其subscribe方法，但是它并没有真正的去完成**主题**和**观察者**之间的订阅关系，而是把这个功能，转接给了另一个抽象方法subscribeActual（具体细节后面分析）。\n\n因此，Observable依旧是一个抽象类，我们知道**抽象类是不能被实例化的**，因此从理论上来说，他好像不能作为具体主题的角色。其实不然，Observable内部提供了create,defer,fromXXX,repeat,just等一系列**创建型操作符**， 用来创建各种Observable。\n```java\n    public static <T> Observable<T> create(ObservableOnSubscribe<T> source) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        return RxJavaPlugins.onAssembly(new ObservableCreate<T>(source));\n    }\n```\n\n\n在RxJava内有很多他的子类。\n\n\n![Observable子类](https://user-gold-cdn.xitu.io/2018/1/7/160d0dafe04868f6?w=669&h=509&f=png&s=53479)\n\n诚然，你可以认为，这些子类其实才是真正的具体主题。但是，换一个角度，从[代理模式](https://juejin.im/post/5a4e4725f265da3e2c37e36e)的角度出发，我们可以把Observable当做是一个代理类，客户端你只管调用create 方法，想要什么样的\nObservable告诉我一声就可以，不同Observable之间的差异你不用管，包在我身上，保证给你返回你想要的Observable实例。\n\n同时，Observable另一个巨大的贡献，就是定义了很多的操作符，我们平时常用的map,flatMap,distinct等，也是在这里定义。并且这些方法都是final类型的，因此他的所有子类都会继承同时也无法改变这些操作符的实现。\n\n因此，Observable 就是具体主题。\n\n- 抽象观察者\n\n在抽象主题里已经提过了，Observer就是抽象观察者的角色。\n\n```java\npublic interface Observer<T> {\n\n    void onSubscribe(@NonNull Disposable d);\n\n    void onNext(@NonNull T t);\n\n    void onError(@NonNull Throwable e);\n\n    void onComplete();\n\n}\n\n```\n\n非常符合观察者模式中抽象观察者的职责描述，Observer 定义了观察者（下游）收到主题（上游）通知后该做什么事情。这里需要注意的是onSubscribe 也是定义在这里的。\n\n\n- 具体的观察者\n\n这个具体的观察者，o(╯□╰)oo(╯□╰)o，就不多说了吧。大家平时使用应该都是直接用new一个Observer的实例。RxJava内部有很多Observer的子类，有兴趣的同学可以具体了解一下。这里其实可以引申出一个有意思的问题，同样是抽象类，为什么接口可以直接实例化，而用abstract修饰过的类就不可以？\n\n#### 具体的观察者是如何实例化的\n\n我们看一下这段代码：\n\n```java\n    Observable mObservable = Observable.create(new ObservableOnSubscribe() {\n            @Override\n            public void subscribe(ObservableEmitter e) throws Exception {\n            }\n        });\n\n    public static <T> Observable<T> create(ObservableOnSubscribe<T> source) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        return RxJavaPlugins.onAssembly(new ObservableCreate<T>(source));\n    }\n\t\n\t\n    public static <T> Observable<T> onAssembly(@NonNull Observable<T> source) {\n        Function<? super Observable, ? extends Observable> f = onObservableAssembly;\n\t\t// 是否有别的其他操作符运算，有的话，在此Observable上执行一遍\n        if (f != null) {\n            return apply(f, source);\n        }\n        return source;\n    }\n\n```\n\n**RxJava的代码里，很多时候会有ObjectHelper.requireNonNull这种空检查的地方，一律都是为了最大程度的防止NPE的出现，后面出现就不再赘述了**.\n\n我们使用create操作符创建Observable的过程中，看似经历了很多方法，**在不考虑任何其他操作符的前提下**，整个过程简化一下的话就这么一句代码\n\n```java\n  Observable mObservable=new ObservableCreate(new ObservableOnSubscribe())\n```\n从之前的分析，我们也看到了ObservableCreate 就是Observeable抽象类的一个子类。我们简单看一下他的实现。\n\n```java\npublic final class ObservableCreate<T> extends Observable<T> {\n    final ObservableOnSubscribe<T> source;\n\n    public ObservableCreate(ObservableOnSubscribe<T> source) {\n        this.source = source;\n    }\n\n    @Override\n    protected void subscribeActual(Observer<? super T> observer) {\n        ……\n    }\n}\n\n```\n\n可以看到，他唯一的构造函数需要一个ObservableOnSubscribe实例，同时他实现subscribeActual方法，说明他真正处理**主题**和**观察者**之间实现订阅的逻辑。\n\n看了半天，你可能一直很好奇，这个ObservableOnSubscribe是个什么东西呢？他其实很简单。\n\n```java\n/**\n * A functional interface that has a {@code subscribe()} method that receives\n * an instance of an {@link ObservableEmitter} instance that allows pushing\n * events in a cancellation-safe manner.\n *\n * @param <T> the value type pushed\n */\npublic interface ObservableOnSubscribe<T> {\n\n    /**\n     * Called for each Observer that subscribes.\n     * @param e the safe emitter instance, never null\n     * @throws Exception on error\n     */\n    void subscribe(@NonNull ObservableEmitter<T> e) throws Exception;\n}\n```\n\nε=(´ο｀*)))唉，怎么又一个subscribe，这又是啥？不要慌，看注释。意思是说，这里的subscribe 接收到一个ObservableEmitter实例后，就会允许他以一种可以安全取消（也就是一定能取消）的形式发送事件。\n\n**就是说会有某个对象，给他一个ObservableEmitte的实例，没给他之前他是不会主动发送事件的，会一直憋着。**，到这里，你是不是想到了什么，我们知道在RxJava 中只有观察者（下游）订阅(subscribe)了主题（上游），主题才会发送事件。这就是和普通的观察者模式有区别的地方之一。\n\n好了，最后再来看看这个神秘的ObservableEmitter是个什么鬼？\n\n```java\npublic interface ObservableEmitter<T> extends Emitter<T> {\n\n    void setDisposable(@Nullable Disposable d);\n\n\n    void setCancellable(@Nullable Cancellable c);\n\n\n    boolean isDisposed();\n\n    ObservableEmitter<T> serialize();\n\n      /**\n     * Attempts to emit the specified {@code Throwable} error if the downstream\n     * hasn't cancelled the sequence or is otherwise terminated, returning false\n     * if the emission is not allowed to happen due to lifecycle restrictions.\n     * <p>\n     * Unlike {@link #onError(Throwable)}, the {@code RxJavaPlugins.onError} is not called\n     * if the error could not be delivered.\n     * @param t the throwable error to signal if possible\n     * @return true if successful, false if the downstream is not able to accept further\n     * events\n     * @since 2.1.1 - experimental\n     */\n    boolean tryOnError(@NonNull Throwable t);\n}\n```\n\n**这里可以关注一下tryOnError这个方法，可以看到他会把某些类型的error传递到下游。**\n\no(╥﹏╥)o，又是一个接口，而且还继承了另一个接口，什么情况？继续看\n\n```java\npublic interface Emitter<T> {\n\n    void onNext(@NonNull T value);\n\n  \n    void onError(@NonNull Throwable error);\n\n   \n    void onComplete();\n}\n```\n\n惊不惊喜，意不意外？ 哈哈，终于找到你了，熟悉的onNext，onError,onComplete.原来在这里。\n\n**这里有个问题可以思考一下，在抽象观察者中，定义了四个处理事件的方法，这里只有三个，按照对应关系来说似乎缺了一个onSubscribe，这又是怎么回事呢？后面会有分析，可以自己先想想**\n\n这两个接口的含义很明显了，总结一下：\n\n- Emitter 定义了可以发送的事件的三种机制\n- ObservableEmitter 在Emitter 做了扩展，添加了Disposable相关的方法，可以用来取消事件的发送。\n\n好了，绕了一大圈，就为了一行代码：\n\n\n```java\n  Observable mObservable=new ObservableCreate(new ObservableOnSubscribe())\n```\n\n总结一下具体主题（上游）的到底干了啥：\n\n- 创建了一个ObservableCreate 的实例对象\n- ObservableCreate 内持有ObservableOnSubscribe 对象的引用\n- ObservableOnSubscribe 是一个接口，内部有一个subscribe方法，调用他之后，会用其ObservableEmitter实例开始发送事件。\n- ObservableEmitter 继承自Emitte。\n\n#### 如何实现订阅、发送事件和接收事件\n\n为了方便叙述，把问题3和4连在一起说了。\n\n通过上面的叙述，现在具体主题和具体的观察者都创建好了，接下来就是实现二者的订阅关系。\n\n```\nmObservable.subscribe(mObserver);\n```\n\n>这里需要明确的一点是，是观察者（下游）订阅了主题（上游），虽然从代码上看好像了前者订阅了后者，不要搞混了。\n\n我们看Observable的subscribe() 方法：\n\n```java\n    public final void subscribe(Observer<? super T> observer) {\n        ObjectHelper.requireNonNull(observer, \"observer is null\");\n        try {\n            observer = RxJavaPlugins.onSubscribe(this, observer);\n\n            ObjectHelper.requireNonNull(observer, \"Plugin returned null Observer\");\n\n            subscribeActual(observer);\n        } catch (NullPointerException e) { // NOPMD\n            throw e;\n        } catch (Throwable e) {\n         ……\n        }\n    }\n```\n\n这个前面已经提到过了，Observable并没有真正的去实现subscribe,而是把他转接给了subscribeActual()方法。\n\n\n前面已经说过，Observable的实例是一个ObservableCreate对象，那么我们就到这个类里去看看subscribeActual()的实现。\n\n```java\n\t// 为了方便，顺便再看一眼构造函数\n    public ObservableCreate(ObservableOnSubscribe<T> source) {\n        this.source = source;\n    }\n    @Override\n    protected void subscribeActual(Observer<? super T> observer) {\n        CreateEmitter<T> parent = new CreateEmitter<T>(observer);\n        observer.onSubscribe(parent);\n\n        try {\n            source.subscribe(parent);\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            parent.onError(ex);\n        }\n    }\n```\n\nCreateEmitter 实现了之前提到的ObservableEmitter接口。这里有一句关键的代码：\n\n```java\nobserver.onSubscribe(parent);\n```\n\n之前在看到Emitter的定义时，我们说缺少了onSubscribe方法，到这里就明白了。**onSubscribe并不是由主题（上游）主动发送的事件，而是有观察者（下游）自己调用的一个事件，只是为了方便获取Emitter的实例对象，准确的说应该是Disposable的实例对象，这样下游就可以控制上游了。**\n\n接下来就更简单了，source 是ObservableOnSubscribe，按照之前的逻辑，调用其subscribe方法，给他一个ObservableEmitter对象实例，ObservableEmitter就会开始发送事件序列。这样，一旦开始订阅了，主题（上游）就开始发送事件了。也就是我们熟悉的onNext,onComplete,onError 方法真正的开始执行了。\n\n接着看看CreateEmitter的实现。\n\n```java\n\npublic final class ObservableCreate<T> extends Observable<T> {\n    final ObservableOnSubscribe<T> source;\n\n    public ObservableCreate(ObservableOnSubscribe<T> source) {\n        this.source = source;\n    }\n\n    @Override\n    protected void subscribeActual(Observer<? super T> observer) {\n        CreateEmitter<T> parent = new CreateEmitter<T>(observer);\n        observer.onSubscribe(parent);\n        ……\n    }\n\n    static final class CreateEmitter<T>\n    extends AtomicReference<Disposable>\n    implements ObservableEmitter<T>, Disposable {\n\n\n        private static final long serialVersionUID = -3434801548987643227L;\n\n        final Observer<? super T> observer;\n\n        CreateEmitter(Observer<? super T> observer) {\n            this.observer = observer;\n        }\n\n        @Override\n        public void onNext(T t) {\n            if (t == null) {\n                onError(new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"));\n                return;\n            }\n            if (!isDisposed()) {\n                observer.onNext(t);\n            }\n        }\n\n        @Override\n        public void onError(Throwable t) {\n            if (!tryOnError(t)) {\n                RxJavaPlugins.onError(t);\n            }\n        }\n\n        @Override\n        public boolean tryOnError(Throwable t) {\n            if (t == null) {\n                t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\");\n            }\n            if (!isDisposed()) {\n                try {\n                    observer.onError(t);\n                } finally {\n                    dispose();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void onComplete() {\n            if (!isDisposed()) {\n                try {\n                    observer.onComplete();\n                } finally {\n                    dispose();\n                }\n            }\n        }\n\n        @Override\n        public void setDisposable(Disposable d) {\n            DisposableHelper.set(this, d);\n        }\n\n        @Override\n        public void setCancellable(Cancellable c) {\n            setDisposable(new CancellableDisposable(c));\n        }\n\n        @Override\n        public ObservableEmitter<T> serialize() {\n            return new SerializedEmitter<T>(this);\n        }\n\n        @Override\n        public void dispose() {\n            DisposableHelper.dispose(this);\n        }\n\n        @Override\n        public boolean isDisposed() {\n            return DisposableHelper.isDisposed(get());\n        }\n    }\n}\n```\n\n- 他的构造函数，需要一个观察者的实例；\n- 他实现了ObservableEmitter接口，并依次实现他的三个方法；\n  - 在每一次的onNext事件中，他不再接受参数为null的类型，在事件序列没有中断的情况下会把主题（上游）发送的事件T原封不动的传递给观察者(下游）。\n  - onComplete事件发生时，他也会通知下游，如果发生异常，则中断事件序列\n  - onError 事件发生时，并没有直接传递到下游，而是在其内部处理\n  - tryOnError 事件发生时，才会把某些特定类型的错误传递到下游。\n- 他实现了Disposable接口，下游根据获取到的Emitter的实例对象，可以方便的获取事件序列的信息，甚至是可以主动关闭事件序列，及断开观察者模式中主题和观察者间的订阅关系。\n\n\n## RxJava 中对常规的观察者模式做了怎样调整，带来了什么好处？\n\n最后再来简单说一下，RxJava中对常规的观察者模式做了怎样的调整，有什么值得借鉴的地方。大部分优点在上面已经提及了，这里就来总结一下。\n\n- 观察者订阅主题后，主题才会开始发送事件\n- RxJava中Observer通过onSubscribe获取了发送事件中的Disposable对象，这样他就可以主动的获取订阅关系中二者的状态，甚至是控制或者是中断事件序列的发送。在常规的观察者模式中，主题有权利添加订阅者，但也能是由他移除特定的订阅者，因为只有他持有所有订阅者的集合\n- 抽象主题（上游）并没有直接控制onNext，onComplete,onError事件的发送，而是只关注Emitter 实例的发送，ObservableOnSubscribe接口监听ObservableEmitter对象的发送，一旦接受到此对象就会通过他开始发送具体的事件，这里可以有点观察者模式嵌套的意味。\n\n\n****\n\n好了，以上就是从观察者模式的角度出发，对RxJava的一次解读，有什么疏漏或理解错误的地方，欢迎读者指出，共同进步！\n\n","tags":["RxJava2"],"categories":["Android 进阶"]},{"title":"代理模式","url":"%2F2018%2F01%2F07%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F","content":"\n## 介绍\n\n代理模式也称为委托模式，是一种**结构性**设计模式。\n\n说到代理，可能大部分人都会有一种陌生又熟悉的感觉，日常生活中好像都能遇到，比如代理上网，招商代理，商务代理等；但又说不出个具体的一二三来；代理这个事情如果我们换个角度，从委托者的角色出发，我们找代理上网，是因为我们在访问某些网站时存在困难，需要有个角色来间接的帮我们实现这个功能；我们找商务代理，可能是因为许多事我们不在行或者其他原因，需要找专业的中间人来帮我们做事。因为，日常生活中我们更多扮演的是委托人的角色，代理以一种中间人的角色，帮我们是处理我们无能为力的事情。\n\n<!--more-->\n\n因此，从写代码的角度出发，当我们遇到以下场景：\n\n- 无法直接访问某个对象\n- 不想直接访问某个对象\n- 访问某个对象存在困难\n\n这个时候，我们就可以通过一个代理，通过它来间接访问真正的对象。\n\n\n\n## 定义及UML图\n\n### 定义： \n\n**为目标对象提供一种代理，客户端通过代理去访问目标对象。**\n\n\n### UML 图\n\n\n\n![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1514862791977&di=a2474587175e0bb92b0178421e86d125&imgtype=jpg&src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D3669500640%2C1002167682%26fm%3D214%26gp%3D0.jpg)\n\n\n从代理模式的UML 类图中，我们可以得到如下结论：\n\n- 代理对象和委托对象需要实现相同的接口（抽象类）\n- 代理对象持有委托对象的引用\n\n可以看到，代理模式非常简洁，总共就三个角色，包括**抽象主题，委托者和代理者。**下面用代码简单实现一下基础的代理模式。\n\n```java\npublic interface Subject {\n    void doSomething();\n}\n\npublic class RealSubject implements Subject {\n    @Override\n    public void doSomething() {\n        System.out.println(\"This is real doSomeThing\");\n    }\n}\n\npublic class ProxySubject implements Subject {\n\n    private Subject mSubject;\n    // 代理类持有委托类的引用\n    public ProxySubject(Subject realSubject) {\n        mSubject = realSubject;\n    }\n\n    @Override\n    public void doSomething() {\n        mSubject.doSomething();\n    }\n}\n\npublic class Client {\n    public static void main(String[] args) {\n        //创建委托类\n        Subject mRealSubject=new RealSubject();\n        //创建代理类\n        ProxySubject mProxy = new ProxySubject(mRealSubject);\n        //由代理类去做具体的操作\n        mProxy.doSomething();\n    }\n}\n\n```\n\n可以看到RealSubject和ProxySubject都实现了接口Subject。在客户端使用ProxySubject的实例调用doSomething方法，而不是使用RealSubject的实例来实现。\n\n你可能会好奇，这么做的意义是什么呢？直接用RealSubject的实例来调用doSomething方法不也可以吗？何必多此一举。试想，如果现在有很多个委托类，他们各自的实现都不同，客户端只关心doSomething 的调用，而不关心具体的实现，这样代理类就可以在其内部屏蔽委托类之间的差异了。这么说可能有点晕，下面就通过Android源码中的实现来感受一下。\n\n## Android 中的代理模式\n\n\n平时写代码的时候，可能感觉代理模式没怎么遇到过。其实不然，甚至可以说代理模式是我们最常用到的一种设计模式。这里就来看看几乎天天都在使用的AppCompatActivity。\n\n最早的时候，我们创建自己的Activity都是直接继承android.app.Activity。后来随着Android版本的升级，我们创建的Activity会继承AppCompatActivity。这里的Compat其实就是Compatible(兼容)的缩写，那么他是怎么实现兼容的呢。\n\n#### onCreate\n\nonCreate()方法是整个Activity生命周期的开始。AppCompatActivity又是怎么实现他的呢。\n\n**AppCompatActivity-onCreate()**\n\n```java\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        final AppCompatDelegate delegate = getDelegate();\n        delegate.installViewFactory();\n        delegate.onCreate(savedInstanceState);\n\t\t……\n    }\n```\n\n可以看到这里他并没具体去实现onCreate,而是使用一个AppCompatDelegate实例的onCreate()方法去实现。继续看getDelegate 的实现。\n\n\n**AppCompatActivity-getDelegate()**\n\n```java\n    @NonNull\n    public AppCompatDelegate getDelegate() {\n        if (mDelegate == null) {\n            mDelegate = AppCompatDelegate.create(this, this);\n        }\n        return mDelegate;\n    }\n```\n\n可以看到这个实例创建是在AppCompatDelegate类中。接着看create的实现\n\n\n**AppCompatDelegate-create()**\n\n```java\n    public static AppCompatDelegate create(Activity activity, AppCompatCallback callback) {\n        return create(activity, activity.getWindow(), callback);\n    }\n\n    private static AppCompatDelegate create(Context context, Window window,\n            AppCompatCallback callback) {\n        if (Build.VERSION.SDK_INT >= 24) {\n            return new AppCompatDelegateImplN(context, window, callback);\n        } else if (Build.VERSION.SDK_INT >= 23) {\n            return new AppCompatDelegateImplV23(context, window, callback);\n        } else if (Build.VERSION.SDK_INT >= 14) {\n            return new AppCompatDelegateImplV14(context, window, callback);\n        } else if (Build.VERSION.SDK_INT >= 11) {\n            return new AppCompatDelegateImplV11(context, window, callback);\n        } else {\n            return new AppCompatDelegateImplV9(context, window, callback);\n        }\n    }\n```\n\n可以看到，这里就不同的Android版本，分别返回了不同的AppCompatDelegate。如果去看源码（这里的源码分析不是重点，就不贴出了，直接给出结论），我们会发现，从\nAppCompatDelegateImplN到AppCompatDelegateImplV9，是子类到父类的关系，之间是依次继承。而AppCompatDelegateImplV9又继承自AppCompatDelegateImplBase（抽象类），而这个AppCompatDelegateImplBase则是继承自AppCompatDelegate。\n\n到这里，结合一开始我们所说的代理模式的内容，我们很容易总结出以下结论：\n\n- AppCompatDelegate 同时兼顾了**抽象主题和代理类**的角色\n- AppCompatDelegateImplN，AppCompatDelegateImplV23等这些都是**委托类**，他们都继承自AppCompatDelegate方法。\n\n通过[AppCompatDelegate.java](https://www.androidos.net.cn/android/8.0.0_r4/xref/frameworks/support/v7/appcompat/src/android/support/v7/app/AppCompatDelegate.java)(点击可直接查看)的源码，我们可以发现，这个抽象类内部定义了一系列和 Activity 相关的抽象方法，包括Activity生命周期函数，setContentView，setSupportActionBar等。我们知道，**子类通过继承父类，可以扩展（spuer)或直接覆盖父类的方法实现。** AppCompatDelegateImplV9 这个类是AppCompatDelegate的具体实现，之后的版本，就可以通过继承AppCompatDelegateImplV9来扩展或修改一些方法实现，通过AppCompatDelegate 在create方法中创建不同的委托类来完成不同的实现，而我们原先写好的代码也不会被破坏，可以看到Android源码对Activity兼容这个事做的非常巧妙。AppCompatDelegate主要是对ActionBar的兼容及夜间模式的处理做了一些方便开发者实现的处理；这里就不再具体分析了。\n\n当然，代理模式这个几乎找不到缺点的设计模式，在Android源码中的应用也是比较广泛，基本上关于兼容性的实现，都会用到以上思路，比如NotificationCompatImpl几乎使用了和AppCompatDelegate同样的思路，实现了在手机通知栏中实现不同的通知样式。除了兼容性的处理，另外一个比较经典的实现就是Binder了，作为跨进程通信的核心理念，Binder巧妙的使用了代理模式，处理了我们无法在不同应用之间共享和传递数据的问题。关于Binder的分析，网上真的太多了，这里就不再赘述了，有兴趣的同学可以看看这篇[代理模式在Binder中的使用](http://blog.csdn.net/singwhatiwanna/article/details/44590179).\n\n## 动态代理\n\n以上的分析中，委托类是由我们直接创建好的；现实中可能还有这样一种场景，委托类并不是在程序编译的时候创建，而是在运行的过程中通过Java的反射机制动态的进行创建，这样的代理模式成为动态代理，对应的之前我们所说的就是静态代理了。\n\n其实，动态代理的实现没有什么可说的，说白了都是模板代码，Java为开发者提供了InvocationHandler,实现该接口重写其invoke 方法即可。\n\n还是以之前的Subject为例\n\n```java\npublic interface Subject {\n    void doSomething();\n}\n\npublic class RealSubject implements Subject {\n    @Override\n    public void doSomething() {\n        System.out.println(\"This is real doSomeThing\");\n    }\n}\n\n\npublic class DynamicProxyHandler implements InvocationHandler {\n    private Object mObject;\n\n\n    public DynamicProxyHandler(Object object) {\n        mObject = object;\n    }\n\n    @Override\n    public Object invoke(Object o, Method method, Object[] objects) throws Throwable {\n        return method.invoke(mObject, objects);\n    }\n}\n\n\npublic class MainClass {\n    public static void main(String[] args) {\n        // 委托类\n        Subject mRealSubject = new RealSubject();\n        // 委托类classLoader\n        ClassLoader mClassLoader = mRealSubject.getClass().getClassLoader();\n        // 委托类对应的ProxyHandler\n        DynamicProxyHandler mProxyHandler = new DynamicProxyHandler(mRealSubject);\n        Class[] mClasses = new Class[]{Subject.class};\n        // 代理类\n        Subject proxySubject = (Subject) Proxy.newProxyInstance(mClassLoader, mClasses, mProxyHandler);\n        // 代理类调用方法\n        proxySubject.doSomething();\n        \n    }\n}\n\n```\n\n这里可以看到，DynamicProxyHandler内部持有的并不是一个具体的对象，而是Object类，而在其invoke方法中，又会根据具体的Object对象及参数调用其对应的方法。这样当我们在客户端调用时，完全是根据委托类通过Proxy.newProxyInstance方法动态的创建代理类。在上面的代码中，我们是通过委托类RealSubject动态的创建了一个代理类，通过代理类调用抽象主题中定义好的方法，实际上就会调用委托类中的具体实现。而在Java中，我们可以通过反射机制，动态的创建类及其实例，因此，我们便可以在运行时通过不同的委托类，更灵活的创建代理类，从而实现不同的功能。\n\n关于动态代理，这篇[十分钟理解Java之动态代理](https://www.jianshu.com/p/cbd58642fc08)分析的非常好，有兴趣的同学可以再看看。\n\n\n在Android中，关于动态代理的使用，最经典的莫过于这几年最火热的Retrofit了。这里可以简单看一下。\n\n```java\n\npublic interface GitHubService {\n  @GET(\"users/{user}/repos\")\n  Call<List<Repo>> listRepos(@Path(\"user\") String user);\n}\n\nGitHubService service = retrofit.create(GitHubService.class);\nCall<List<Repo>> repos = service.listRepos(\"octocat\");\n``` \n\n上面的实现，现在大家应该很熟悉了，当我们用Retrofit实例，调用其create方法时，到底发生了什么呢？\n\n```java\n  public <T> T create(final Class<T> service) {\n    Utils.validateServiceInterface(service);\n    if (validateEagerly) {\n      eagerlyValidateMethods(service);\n    }\n    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n        new InvocationHandler() {\n          private final Platform platform = Platform.get();\n\n          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)\n              throws Throwable {\n            // If the method is a method from Object then defer to normal invocation.\n            if (method.getDeclaringClass() == Object.class) {\n              return method.invoke(this, args);\n            }\n            if (platform.isDefaultMethod(method)) {\n              return platform.invokeDefaultMethod(method, service, proxy, args);\n            }\n            ServiceMethod<Object, Object> serviceMethod =\n                (ServiceMethod<Object, Object>) loadServiceMethod(method);\n            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);\n            return serviceMethod.callAdapter.adapt(okHttpCall);\n          }\n        });\n  }\n```\n\n可以看到，这里就是一个典型的动态代理实现，**通过serviceMethod.callAdapter.adapt返回了一个service对象的代理对象，在上面的例子里，就是返回了一个GitHubService的代理对象，这样我们就可以通过这样一个对象去调用GitHubService中定义好的各种网络请求，而不用在使用的时候再去决定是POST请求还是GET请求,参数是放在Body里还是params里，因为Retrofit 通过把反射注解和动态代理的巧妙结合，屏蔽了复杂的参数拼接操作，把所有我们需要对OKHttp的进行传递的参数，动态的帮我们传递了**，一旦在接口中定义好了使用方式，就可以非常方便的获取到okhttp中最关键的Call了，有了Call我们就可以通过execute或者是enqueue发起网络请求了。\n\n## 总结\n\n以上就是对代理模式的分析，总的来说代理模式的结构非常简单；包括**抽象主题，委托类，代理类**三个核心角色，从大的方向上可以分为静态代理和动态代理两大类；通过静态代理的方式，在开发迭代的过程中，为实现兼容性提供了一种非常友好的实现思路；在日常开发中，如果我们使用的对象之间有着强烈的耦合，可是思考一下是否可以通过代理模式解耦；同时，当我们需要扩展某个类的部分功能时，但又不想去破坏原有的功能或者是根本无法修改时，我们可以考虑代理模式，但也要明白，通过代理模式我们能做的也只能是功能扩展，想要更新委托类中已经实现的内容我们是无能为力的。\n\n\n动态代理，可以根据运行时的委托类动态的生成代理类，这样就减轻了代理类的负担，避免在编码阶段就具体的委托类再做各种判断了。\n\n代理模式很简单，也很实用，但不要忘记**代理类**和**委托类**需要实现功能的接口或抽象类，不要忽略了这一点。\n\n****\n\n\n\n\n\n\n\n\n\n\n\n","categories":["设计模式"]},{"title":"Android 插件化和热修复的前生今世","url":"%2F2017%2F11%2F28%2FAndroid%20%E6%8F%92%E4%BB%B6%E5%8C%96%E5%92%8C%E7%83%AD%E4%BF%AE%E5%A4%8D%E7%9A%84%E5%89%8D%E7%94%9F%E4%BB%8A%E4%B8%96%2F","content":"\n## 概述\n\n在Android开发中，插件化和热修复的话题越来越多的被大家提及，同时随着技术的迭代，各种框架的发展更新，插件化和热修复的框架似乎已经日趋成熟，许多开发者也把这两项技术运用到实际开发协作和正式的产品当中。因此，我们势必需要了解一下这两门技术。\n\n\n## 插件化和热修复\n\n首先需要明确的一点，**插件化和热修复**不是同一个概念，虽然站在技术实现的角度来说，他们都是从系统加载器的角度出发，无论是采用hook方式，亦或是代理方式或者是其他底层实现，都是通过“**欺骗**”Android 系统的方式来让**宿主**正常的加载和运行**插件（补丁）**中的内容；但是二者的出发点是不同的。**插件化**顾名思义，更多是想把需要实现的模块或功能当做一个独立的提取出来，减少**宿主**的规模，当需要使用到相应的功能时再去加载相应的模块。**热修复**则往往是从修复bug的角度出发，强调的是在不需要二次安装应用的前提下修复已知的bug。\n\n<!--more-->\n\n为了方便叙述，做以下称谓约定：\n> 宿主： 就是当前运行的APP\n> 插件： 相对于插件化技术来说，就是要加载运行的apk类文件\n> 补丁： 相对于热修复技术来说，就是要加载运行的*.patch,*.dex,*.apk等一系列包含dex修复内容的文件。\n\n以下提到内容中的宿主和插件（补丁），均是上述含义，不再赘述。\n\n\n![Android插件化技术的典型应用](http://s1.knowsky.com/20170206/e4as0errukk22.png)\n\n上图就是对Android插件化和热修复之间关系的体现。据我所知，在某些开发团队中，会把热修复的技术，作为在APP端部署日常活动的功能来用。虽然，实际效果来看是没有问题的，但长期使用还是值得商榷的。\n\n早期很多应用的动态换肤功能，就是参考了Android 插件化的技术，最早的新浪微博夜间模式就是通过下载一个夜间模式的apk文件完成，当时做为开发者的自己，感觉很高级。关于动态加载的应用，其实有很多可以扩展的思路，比如特定节日的促销活动，逃避审核机制的动态广告加载都是Android插件化技术可以考虑的实现，更多内容可以参考[**Android动态加载技术 简单易懂的介绍方式**](https://segmentfault.com/a/1190000004062866)\n\n\n\n\n下面就从插件化技术的发展源头，逐步叙述一下二者的发展历程及现状，了解一下时至今日，热修复框架的发展到了各种地步，总体梳理一下热修复的原理，对现有的框架有一个了解。\n\n\n## 插件化\n\n### 发展历程及现状\n\n关于插件化技术的起源可以追溯到5年前\n- 2012年的 [AndroidDynamicLoader](https://github.com/mmin18/AndroidDynamicLoader) ，他的原理是动态加载不同的Fragment实现UI替换，可以说是开山鼻祖了，但是这种方案可扩展性不强。\n- 再到后来出现了23Code,他可以直接下载一个自定义控件的demo，并且运行起来。\n- 2014年一个里程碑式的年份，任玉刚（俗称主席）发布了[dynamic-load-apk](https://github.com/singwhatiwanna/dynamic-load-apk),也叫做DL。在这个框架里提供了两个很重要的思路：\n  - 如何管理插件内Activity的生命周期： 使用 DLProxyActivity 采用静态代理的方式去调用插件中Activity的生命周期方法。\n  - 如何加载插件内的资源文件：通过反射调用AssetManager 中到的addAssetPath方法就可以将特定路径的资源加载到系统内存中使用。\n\n  以上两点，可以说是非常有意义的，尤其是第二点关于插件资源的记载，是后期出现的许多框架的参考思路。这个框架也有一些局限，不支持插件内Service、BroadcastReceiver等需要注册才能使用的组件，同时插件apk也需要按照其开发规范来实现，总体来说还是有一定的成本，但无论怎样都是一个很有价值的框架。（话说这个框架貌似已经不再维护了，最近一次关于代码的更新都是2年前了，o(╥﹏╥)o）。\n- 2015年 [DroidPlugin](https://github.com/DroidPluginTeam/DroidPlugin) \n**[DroidPlugin 是Andy Zhang在Android系统上实现了一种新的 插件机制 :它可以在无需安装、修改的情况下运行APK文件,此机制对改进大型APP的架构，实现多团队协作开发具有一定的好处。](https://github.com/DroidPluginTeam/DroidPlugin/blob/master/readme_cn.md)** 这段话是DroidPlugin在Github README 文档中的介绍。这款来自360的插件化框架.\n- 2015年 [DynamicAPK](https://github.com/CtripMobile/DynamicAPK) 这个就……，貌似因为License的原因已经完全不更新了。\n\n- 2017 [RePlugin](https://github.com/Qihoo360/RePlugin) 这是360 开源的插件化框架，按照他自己的说法，相较于其他框架，他对系统的hook只有一处，那就是ClassLoader，这样从理论来说，貌似会有更好的稳定性。\n\n- 2017年 [atlas](https://github.com/alibaba/atlas)这个是阿里今年刚刚开源的插件化开发框架，可以说是非常强大；具体原理参考[详解 Atlas 框架原理](https://www.xttblog.com/?p=1141)；还没有用过。\n\n- [Small](https://github.com/wequick/Small)  最后再说一下Small，个人感觉Small 所提供了一种比插件化更高层次的概念，组件化；把一个完整的APP看成是由许多可以复用模块组件组成（这个有点像React Native的开发理念）；开发起来像是搭积木的感觉。有兴趣的可以去[Small官网](http://code.wequick.net/Small/cn/home)了解一下。\n\n\n## 热修复\n\n相较于插件化，热修复技术的使用更加的频繁，因为这项技术切实关切到我们实际开发的产品，能够更快速更便捷的修复线上bug，才能带来更好的用户体验。因此下面就结合热修复的原理了解一下热修复的使用及发展现状。\n\n> 以下所有分析源自热修复相关文章，这里只是把结论整理了出来。具体分析就不再拾人牙慧了，对实现细节有兴趣的同学可以查看相应的链接。\n\n\n### 类加载原理\n\n说起热修复就不得不提类的加载机制，和常规的JVM类似，在Android中类的加载也是通过ClassLoader来完成，具体来说就是PathClassLoader 和 DexClassLoader 这两个Android专用的类加载器，这两个类的区别如下：\n\n- PathClassLoader：只能加载已经安装到Android系统中的apk文件（/data/app目录），是Android默认使用的类加载器。\n- DexClassLoader：可以加载任意目录下的dex/jar/apk/zip文件，也就是我们一开始提到的补丁。\n\n这两个类都是继承自BaseDexClassLoader，我们可以看一下BaseDexClassLoader的构造函数。\n\n```java\n    public BaseDexClassLoader(String dexPath, File optimizedDirectory,\n            String libraryPath, ClassLoader parent) {\n        super(parent);\n        this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);\n    }\n```\n这个构造函数只做了一件事，就是通过传递进来的相关参数，初始化了一个DexPathList对象。**DexPathList的构造函数，就是将参数中传递进来的程序文件（就是补丁文件）封装成Element对象，并将这些对象添加到一个Element的数组集合dexElements中去**。\n\n\n>ClassLoaer 的加载机制是一种特别聪明的方式，**双亲委托机制**，在这种机制下，一个Class只会被加载一次。\n\n\n对于ClassLoader加载机制及双亲委托机制的分析可以参考[Android解析ClassLoader（一）Java中的ClassLoader](http://liuwangshu.cn/application/classloader/1-java-classloader-.html)。\n\n\n这里需要明白的一点是对于一个ClassLoader（类加载器）来说，将一个具体的类（class）加载到内存中其实是由虚拟机完成的，对于开发者来说，我们关注的重点应该是**如何去找到这个需要加载的类**。\n\n假设我们现在要去查找一个名为name的class，那么DexClassLoader将通过以下步骤实现：\n\n- 在DexClassLoader的findClass 方法中通过一个DexPathList对象findClass()方法来获取class\n- 在DexPathList的findClass 方法中，对之前构造好dexElements数组集合进行遍历，一旦找到类名与name相同的类时，就直接返回这个class，找不到则返回null。\n\n总的来说，**通过DexClassLoader查找一个类，最终就是就是在一个数组中查找特定值的操作。**\n\n综合以上所有的观点，我们很容易想到一种非常简单粗暴的热修复方案。假设现在代码中的某一个类或者是某几个类有bug，那么我们可以在修复完bug之后，可以**将这些个类打包成一个补丁文件，然后通过这个补丁文件封装出一个Element对象，并且将这个Element对象插到原有dexElements数组的最前端**，这样当DexClassLoader去加载类时，优先会从我们插入的这个Element中找到相应的类，虽然那个有bug的类还存在于数组中后面的Element中，但由于双亲加载机制的特点，这个有bug的类已经没有机会被加载了，这样一个bug就在没有重新安装应用的情况下修复了。\n\n有了上面的思路，其实我们就可以自己动手去实现一个简单的热修复框架了。这里推荐一篇\n[热修复——深入浅出原理与实现](https://juejin.im/post/5a0ad2b551882531ba1077a2)，文中作者深入分析了热修复原理，并基于以上原理实现了一个基础的热修复框架，实现过程分析的非常细致深入，非常适合做为热修复入门原理的了解。\n\n### QQ 空间超级补丁方案\n\n看完上面的原理，是不是觉得热修复很简单，没什么可研究的呢？其实不然，Java是一门面向对象的语言，我们使用的类会有继承关系，会相互依赖引用。同时Android虚拟机和常规的JVM 不同，加载的并不是.class而是dex(准确的来说是经过优化的odex)，在这样一个过程中，势必会有一些新的问题值得我们去关注。这个问题就是的CLASS_ISPREVERIFIED，什么意思呢。\n\n>- 在apk安装的时候系统会将dex文件优化成odex文件，在优化的过程中会涉及一个预校验的过程\n>- 如果一个类的static方法，private方法，override方法以及构造函数中引用了其他类，而且这些类都属于同一个dex文件，此时该类就会被打上CLASS_ISPREVERIFIED \n>- 如果在运行时被打上CLASS_ISPREVERIFIED的类引用了其他dex的类，就会报错\n>- 正常的分包方案会保证相关类被打入同一个dex文件\n>- 想要使得patch可以被正常加载，就必须保证类不会被打上CLASS_ISPREVERIFIED标记。而要实现这个目的就必须要在分完包后的class中植入对其他dex文件中类的引用\n \n*以上内容摘自[Android热修复技术——QQ空间补丁方案解析(2) ](https://yq.aliyun.com/articles/70321?spm=5176.100239.blogcont70320.23.Bhmli6)*\n\n**要在已经编译完成后的类中植入对其他类的引用，就需要操作字节码，惯用的方案是插桩。常见的工具有javaassist，asm等**\n\nQQ 空间补丁方案就是使用javaassist 插桩的方式解决了CLASS_ISPREVERIFIED的难题。\n\n\n### Tinker \n\nQQ空间超级补丁，**“超级补丁”**很多情况下意味着补丁文件很大，而将这样一个大文件夹加载在内存中构建一个Element对象，插入到数组最前端是需要耗费时间的,无疑会印象应用启动的速度。因此Tinker 提出了另外一种思路。\n\n![](https://raw.githubusercontent.com/Tencent/tinker/master/assets/tinker.png)\n\n图片源自https://github.com/Tencent/tinker\n\nTinker的思路是这样的，通过修复好的class.dex 和原有的class.dex比较差生差量包补丁文件patch.dex，在手机上这个patch.dex又会和原有的class.dex 合并生成新的文件fix_class.dex，用这个新的fix_class.dex 整体替换原有的dexPathList的中的内容，可以说是从根本上把bug给干掉了。\n\nTinker 提供的思路可以说是非常新奇，也非常值得我们去学习。上图中过程看似简单，但其实具体实现起来还真的不简单。你有想过两个.dex 是如何比较得出差异化文件patch.dex 的吗？有兴趣的同学可以看看鸿翔的这篇分析[Android 热修复 Tinker 源码分析之DexDiff / DexPatch](http://blog.csdn.net/lmj623565791/article/details/60874334)\n\n当然，需要注意的是，patch.dex和原先的class.dex 合并的时候需要新的进程去完成，同时考虑的现在大多数应用的规模，multidex已经是很常见的事情了，因此多个dex 之间的合并策略及成功率，都是在使用Tinker时需要考虑的问题。\n\n关于Tinker 更多细节可以参考 [微信Android热补丁实践演进之路](https://github.com/WeMobileDev/article/blob/master/微信Android热补丁实践演进之路.md)\n\n\n**Tinker 提供的文档及example非常完善，对于有兴趣接入的开发者可以说是非常友好了，但总体来说接入过程还是有些复杂，对整个项目的侵入还是较强，Tinker是个人唯一使用过的热修复的框架，总体来说还是不错的，通过接入到实际应用中，对gradle也有了新的认识，对gradle有兴趣的同学，其实可以看看tinker的gradle接入方式**\n### HotFix\n\n以上提到的两种方式，虽然策略有所不同，但总的来说都是从上层ClassLoader的角度出发，由于ClassLoader的特点，如果想要新的补丁文件再次生效，无论你是插桩还是提前合并，都需要重新启动应用来加载新的DexPathList。这样就无法在用户神不知鬼不觉的情况下把bug修复了，HotFix在这方面就有绝对的优势了。\n\n>HotFix(即AndFix），是在AndFix 的基础之上提供了补丁安全服务及版本管理等相关内容，方便广大的开发人员使用。\n\nAndFix 提供了一种运行时在Native修改Filed指针的方式，实现方法的替换，达到即时生效无需重启，对应用无性能消耗的目的。\n\n![AndFix原理图](https://github.com/alibaba/AndFix/raw/master/images/principle.png)\n\n更多细可以参考[https://github.com/alibaba/AndFix](https://github.com/alibaba/AndFix)，Native层不怎么理解，就不强行装逼了o(╯□╰)o。\n\n由于他是Native层操作，因此如果我们在Java层中新增字段，或者是修改类的方法，他是无能为力的。同时由于Android在国内变成了安卓，各大手机厂商定制了自己的ROM，所以很多底层实现的差异，导致AndFix的兼容性并不是很好。\n\n\n### Sophix\n\n**阿里推出业界首个非侵入式热修复方案Sophix，颠覆移动端传统发版更新流程！**\n\n这是我第一次了解到Sophix时看到的文章标题[原文链接](http://mp.weixin.qq.com/s/5KjSPvUflbg0pVRIjtLiRA?spm=5176.100239.blogcont102404.14.ARzI6c);对于技术类的文章来说，敢于使用**颠覆**这两个字，要么是标题党；要么就是真的很有货。\n\nSophix 可以说是博采众长，前面提到的Tinker及AndFix 都在某一方面存在缺陷。因此Sophix 便取长补短，采用**全量替换**的思路，从一种更高的层次实现了热修复。这貌似也是事物发展的一贯规律，后来的新生事物总结前人的经验教训，吸收好的思想，变得更好。\n\n关于Sophix 的原理看了很多篇文章，感觉这篇[干货满满，Android热修复方案介绍](https://yq.aliyun.com/articles/231111?utm_content=m_34179)分析的不错，有兴趣的可以看一下。\n\n总的来说，Sophix应该是现有最成熟的热修复方案了。\n\n### 其他及总结\n\n当然就热修复的实现，各个大厂还有各自的实现，比如饿了吗的[Amigo](https://github.com/eleme/Amigo),美团的[Robust](https://github.com/Meituan-Dianping/Robust),实现及优缺点各有差异，但总的来说就是两大类\n\n- ClassLoader 加载方案\n- Native层替换方案\n\n或者是参考Android Studio Instant Run 的思路实现代码整体的增量更新。但这样势必会带来性能的影响。\n\n综上所述，其实对于热修复很难有一种十分完美的解决方案。在Android开发中，四大组件使用前需要在AndroidManifest中提前声明，而如果需要使用热修复的方式，无论是提前占坑亦或是动态修改，都会带来很强的侵入性（因此，Sophix是不支持四大组件修复的，这也是其非侵入性设计理念无法避免的事情了，不知道以后会不会有新的办法）。再者Android碎片化的问题，对热修复方案的适配也是一个考验。通过查看几大以开源在Github上的热修复方案，在issue中可以看到提到最多的问题还是兼容性。\n\n因此，面对实际的开发，选择使用或者说选择哪种方案，必须符合实际的应用的场景，一句话，没有最好的，只有合适的。\n\n\n******\n\n好了，插件化和热修复知识就梳理到这里了。\n\n## 相关内容\n\n[Android动态加载技术 简单易懂的介绍方式](https://segmentfault.com/a/1190000004062866)\n[Android 插件化的 过去 现在 未来](https://www.kymjs.com/code/2016/05/04/01/)\n[ZeusPlugin: 掌阅APP插件补丁](http://www.jianshu.com/p/b1e7b6326330)\n[Android插件化：从入门到放弃](http://www.infoq.com/cn/articles/android-plug-ins-from-entry-to-give-up)\n[Android 全面插件化 RePlugin 流程与源码解析](https://juejin.im/post/59752eb1f265da6c3f70eed9)\n[《全面插件化——RePlugin的使命》](https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651113434&amp;idx=1&amp;sn=99a473c6fad2f7b366b2cba2afb96f7a&amp;chksm=844c6e07b33be7112222c0d78be23979912f12d6c99ad2c7bfac766e67e4be4619709f170b09&amp;mpshare=1&amp;scene=1&amp;)\n[详解 Atlas 框架原理](https://www.xttblog.com/?p=1141)\n[热修复——深入浅出原理与实现](https://juejin.im/post/5a0ad2b551882531ba1077a2)\n[Android解析ClassLoader（一）Java中的ClassLoader](http://liuwangshu.cn/application/classloader/1-java-classloader-.html)\n[Android热修复技术——QQ空间补丁方案解析(2) ](https://yq.aliyun.com/articles/70321?spm=5176.100239.blogcont70320.23.Bhmli6)\n[Android热修复技术——QQ空间补丁方案解析(3)](https://yq.aliyun.com/articles/70337?spm=5176.100239.blogcont70321.18.sDlCFI)\n[微信Android热补丁实践演进之路](https://github.com/WeMobileDev/article/blob/master/微信Android热补丁实践演进之路.md)\n[Android热修复技术总结 ](https://yq.aliyun.com/articles/184258?spm=5176.100239.blogcont70337.29.WSmFxM)\n[干货满满，Android热修复方案介绍](https://yq.aliyun.com/articles/231111?utm_content=m_34179)\n","tags":["热修复"],"categories":["Android 进阶"]},{"title":"自定义View高仿懂球帝我是教练效果","url":"%2F2017%2F07%2F23%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E9%AB%98%E4%BB%BF%E6%87%82%E7%90%83%E5%B8%9D%E6%88%91%E6%98%AF%E6%95%99%E7%BB%83%E6%95%88%E6%9E%9C%2F","content":"\n## 前言\n\n这几天很多欧洲球队来中国进行热身赛，不知道喜欢足球的各位小伙伴们有没有看球。喜欢足球的朋友可能知道懂球帝APP，鄙人也经常使用这个应用，里面有一个我是教练的功能挺好玩,就是可以模拟教练员的身份，排兵布阵；本着好奇心简单模仿了一下，在这里和大家分享。\n\n\n## 效果图\n\n老规矩，先上效果图看看模仿的像不。\n\n\n![add_player](https://user-gold-cdn.xitu.io/2017/7/23/68d1796a8b77eaee289378a8686b508f)\n\n\n![move_player](https://user-gold-cdn.xitu.io/2017/7/23/bd8a6abef46a6e25d06a447ec5e68c87)\n\n玩过我是教练这个功能的小伙伴可以对比一下。\n\n总的来说，这样的一个效果，其实很简单，就是一个view随着手指在屏幕上移动的效果，外加一个图片替换的动画。但就是这些看似简单的效果，在实现的过程中也是遇到了很多坑，涨了许多新姿势。好了，废话不说，代码走起(｡◕ˇ∀ˇ◕)。\n\n<!--more-->\n\n## 自定义View-BallGameView\n\n整个内容中最核心的就是一个自定义View-BallGameView，就是屏幕中绿色背景，有气泡和球员图片的整个view。\n\n*说到自定义View，老生常谈，大家一直都在学习，却永远都觉得自己没有学会，但是自定义View的知识本来就很多呀，想要熟练掌握，必须假以时日*。\n\n\n既然是自定View就从大家最关心的两个方法 onMeasure和onDraw 两个方法说起。这里由于是纯粹继承自View，就不考虑onLayout的实现了。\n\n#### 测量-onMeasure\n\n```java\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int viewW = screenW;\n        int viewH = (int) (screenW * 1.3);\n        setMeasuredDimension(viewW, viewH);\n    }\n```\n\n这里onMeasure()方法的实现很简单，简单的用屏幕的宽度规定了整个View 的宽高；至于1.3这个倍数，完全一个估算值，不必深究。\n\n#### 绘制-onDraw\n\nonDraw()方法是整个View中最核心的方法。\n\n```java\n@Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        //绘制背景\n        canvas.drawBitmap(backgroundBitmap, bitmapRect, mViewRect, mPaint);\n        //绘制提示文字透明背景\n        canvas.drawRoundRect(mRoundRect, 8, 8, mRectPaint);\n        //绘制底部提示文字 ( TextPiant 文字垂直居中实现 http://blog.csdn.net/hursing/article/details/18703599)\n        Paint.FontMetricsInt fontMetrics = mTipPaint.getFontMetricsInt();\n        float baseY=(mRoundRect.bottom+mRoundRect.top)/2-(fontMetrics.top+fontMetrics.bottom)/2;\n        canvas.drawText(tips, screenW / 2, baseY, mTipPaint);\n\n\n        //绘制初始的11个气泡\n        for (int i = 0; i < players.length; i++) {\n            //绘制当前选中的球员\n            if (i == currentPos) {\n\n                if (players[i].isSetReal()) {\n                    //绘制球员头像\n                    canvas.drawBitmap(players[i].getBitmap(), positions[i].x - playW / 2,\n                            positions[i].y - playW / 2, mPaint);\n                    //绘制选中球员金色底座\n                    canvas.drawBitmap(playSelectedBitmap, positions[i].x - goldW / 2,\n                            positions[i].y - goldH / 2, mPaint);\n\n                    //绘制球员姓名\n                    canvas.drawText(players[i].getName(), positions[i].x,\n                            positions[i].y + playW, mTextPaint);\n\n                } else {\n                    canvas.drawBitmap(selectedBitmap, positions[i].x - playW / 2,\n                            positions[i].y - playW / 2, mPaint);\n                }\n\n\n            } else {\n                canvas.drawBitmap(players[i].getBitmap(), positions[i].x - playW / 2,\n                        positions[i].y - playW / 2, mPaint);\n                if (players[i].isSetReal()) {\n\n                    //绘制球员姓名\n                    canvas.drawText(players[i].getName(), positions[i].x,\n                            positions[i].y + playW, mTextPaint);\n                    //绘制已设置正常图片球员背景\n                    canvas.drawBitmap(playeBgBitmap, positions[i].x - grayW / 2,\n                            positions[i].y + 200, mPaint);\n                }\n            }\n        }\n    }\n```\n\n可以看到，在onDraw方法里，我们主要使用了canvas.drawBitmap 方法，绘制了很多图片。下面就简单了解一下canvas.drawBitmap 里的两个重载方法。\n\n- drawBitmap(Bitmap bitmap,Rect src,Rect dst,Paint paint) \n\n```java\n/**\n     * Draw the specified bitmap, scaling/translating automatically to fill\n     * the destination rectangle. If the source rectangle is not null, it\n     * specifies the subset of the bitmap to draw.\n     *\n     *\n     * @param bitmap The bitmap to be drawn\n     * @param src    May be null. The subset of the bitmap to be drawn\n     * @param dst    The rectangle that the bitmap will be scaled/translated\n     *               to fit into\n     * @param paint  May be null. The paint used to draw the bitmap\n     */\n    public void drawBitmap(@NonNull Bitmap bitmap, @Nullable Rect src, @NonNull Rect dst,\n            @Nullable Paint paint) {\n       \n    }\n```\n\ndrawBitmap(Bitmap bitmap,Rect src,Rect dst,Paint paint),这个重载方法主要是通过两个Rectangle 决定了bitmap以怎样的形式绘制出来。**简单来说，src 这个长方形决定了“截取”bitmap的大小，dst 决定了最终绘制出来时Bitmap应该占有的大小。**。就拿上面的代码来说\n\n```java\n        backgroundBitmap = BitmapFactory.decodeResource(res, R.drawable.battle_bg);\n        //确保整张背景图，都能完整的显示出来\n        bitmapRect = new Rect(0, 0, backgroundBitmap.getWidth(), backgroundBitmap.getHeight());\n        //目标区域，在整个视图的大小中，绘制Bitmap\n        mViewRect = new Rect(0, 0, viewW, viewH);\n        //绘制背景\n        canvas.drawBitmap(backgroundBitmap, bitmapRect, mViewRect, mPaint);\n\n```\n\nbitmapRect 是整个backgroundBitmap的大小，mViewRect也就是我们在onMeasure里规定的整个视图的大小，这样相当于把battle_bg这张图片，以scaleType=\"fitXY\"的形式画在了视图大小的区域内。这样，你应该理解这个重载方法的含义了。\n\n- drawBitmap(Bitmap bitmap, float left, float top, Paint paint)\n\n```\n    /**\n     * Draw the specified bitmap, with its top/left corner at (x,y), using\n     * the specified paint, transformed by the current matrix.\n     *\n     *\n     * @param bitmap The bitmap to be drawn\n     * @param left   The position of the left side of the bitmap being drawn\n     * @param top    The position of the top side of the bitmap being drawn\n     * @param paint  The paint used to draw the bitmap (may be null)\n     */\n    public void drawBitmap(@NonNull Bitmap bitmap, float left, float top, @Nullable Paint paint) {\n\n    }\n```\n\n这个重载方法应该很容易理解了，left，top 规定了绘制Bitmap的左上角的坐标，然后按照其大小正常绘制即可。\n\n这里我们所有的气泡（球员位置）都是使用这个方法绘制的。足球场上有11个球员，因此我们通过数组预先定义了11个气泡的初始位置，然后通过其坐标位置，绘制他们。为了绘制精确，需要减去每张图片自身的宽高，这应该是很传统的做法了。\n\n\n同时，在之后的触摸反馈机制中，我们会根据手指的滑动，修改这些坐标值，这样就可以随意移动球员在场上的位置了；具体实现，结合代码中的注释应该很容易理解了，就不再赘述；可以查看完整源码[BallGameView](https://github.com/REBOOTERS/AndroidAnimationExercise/blob/dev/app/src/main/java/home/smart/fly/animations/customview/views/BallGameView.java)。\n\n\n##### 文字居中绘制\n\n这里再说一个在绘制过程中遇到一个小问题，可以看到在整个视图底部，绘制了一个半透明的圆角矩形，并在他上面绘制了一行黄色的文字，这行文字在水平和垂直方向都是居中的；使用TextPaint 绘制文字实现水平居中是很容易的事情，只需要设置mTipPaint.setTextAlign(Paint.Align.CENTER)即可，但是在垂直方向实现居中，就没那么简单了，这里需要考虑一个文本绘制时**基线**的问题，具体细节可以参考[这篇文章](http://blog.csdn.net/hursing/article/details/18703599)，分析的很详细。\n\n我们在这里为了使文字在圆角矩形中居中，如下实现。\n\n```\n        canvas.drawRoundRect(mRoundRect, 8, 8, mRectPaint);\n        Paint.FontMetricsInt fontMetrics = mTipPaint.getFontMetricsInt();\n        float baseY = (mRoundRect.bottom + mRoundRect.top) / 2 - (fontMetrics.top + fontMetrics.bottom) / 2;\n        canvas.drawText(tips, screenW / 2, baseY, mTipPaint);\n```\n\n圆角矩形的垂直中心点的基础上，再一次做修正，确保实现真正的垂直居中。\n\n\n\n好了，结合[扔物线](https://juejin.im/user/552f20a7e4b060d72a89d87f)大神所总结的自定义View关键步骤，以上两点算是完成了**绘制和布局**的工作,下面就看看**触摸反馈**的实现。\n\n\n\n#### 触摸反馈-onTouchEvent\n\n这里触摸反馈机制，使用到了GestureDetector这个类；这个类可以用来进行手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。内部提供了OnGestureListener、OnDoubleTapListener和OnContextClickListener三个接口，并提供了一系列的方法，比如常见的\n- onSingleTapUp ： 手指轻触屏幕离开\n- onScroll : 滑动\n- onLongPress： 长按\n- onFling： 按下后，快速滑动松开（类似切水果的手势）\n- onDoubleTap : 双击\n\n\n可以看到，使用这个类可以更加精确的处理手势操作。\n\n\n**这里引入GestureDetector的原因是这样的，单独在onTouchEvent处理所有事件时，在手指点击屏幕的瞬间，很容易触发MotionEvent.ACTION_MOVE事件，导致每次触碰气泡，被点击气泡的位置都会稍微颤抖一下，位置发生轻微的偏移，体验十分糟糕。采用GestureDetector对手指滑动的处理，对点击和滑动的检测显得更加精确**\n\n\n```java\n@Override\n    public boolean onTouchEvent(MotionEvent event) {\n        if (mValueAnimator != null) {\n            if (mValueAnimator.isRunning()) {\n                return false;\n            }\n        }\n        m_gestureDetector.onTouchEvent(event);\n        int lastX = (int) event.getX();\n        int lastY = (int) event.getY();\n\n\n        if (event.getAction() == MotionEvent.ACTION_DOWN) {\n            for (int i = 0; i < positions.length; i++) {\n                int deltaX = positions[i].x - lastX;\n                int deltaY = positions[i].y - lastY;\n\n                // 手指 -- ACTION_DOWN 时，落在了某一个气泡上时，刷新选中气泡（球员）的bitmap\n                if (Math.abs(deltaX) < playW / 2 && Math.abs(deltaY) < playW / 2) {\n                    position = i;\n                    currentPos = i;\n                    invalidate();\n                    moveEnable = true;\n                    Log.e(TAG, \"onTouchEvent: position= \" + position);\n                    return true;\n                }\n\n\n            }\n\n            //没有点击中任意一个气泡，点击在外部是，重置气泡（球员）状态\n            resetBubbleView();\n            moveEnable = false;\n            return false;\n        }\n\n\n        return super.onTouchEvent(event);\n\n    }\n```\n\n这里m_gestureDetector.onTouchEvent(event)，这样就可以让GestureDetector在他自己的回调方法OnGestureListener里，处理触摸事件。\n\n上面的逻辑很简单，动画正在进行是，直接返回。MotionEvent.ACTION_DOWN事件发生时的处理逻辑，通过注释很容易理解，就不再赘述。\n\n当我们点击到某个气泡时，就获取到了当前选中位置currentPos；下面看看GestureDetector的回调方法，是怎样处理滑动事件的。\n\n\n```\nGestureDetector.OnGestureListener onGestureListener = new GestureDetector.SimpleOnGestureListener() {\n        @Override\n        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n            if (moveEnable) {\n                positions[position].x -= distanceX;\n                positions[position].y -= distanceY;\n\n\n                //滑动时，考虑一下上下边界的问题，不要把球员移除场外\n                // 横向就不考虑了，因为底图是3D 摆放的，上窄下宽，无法计算\n                // 主要限制一下，纵向滑动值\n                if (positions[position].y < minY) {\n                    positions[position].y = minY;\n                } else if (positions[position].y > maxY) {\n                    positions[position].y = maxY;\n                }\n\n                Log.e(TAG, \"onScroll: y=\" + positions[position].y);\n\n                //跟随手指，移动气泡（球员）\n                invalidate();;\n            }\n            return true;\n        }\n    };\n```\nSimpleOnGestureListener 默认实现了OnGestureListener，OnDoubleTapListener, OnContextClickListener这三个接口中所有的方法，因此非常方便我们使用GestureDetector进行特定手势的处理。\n\n\n这里的处理很简单，当气泡被选中时moveEnable=true，通过onScroll回调方法返回的距离，不断更新当前位置的坐标，同时记得限制一下手势滑动的边界，总不能把球员移动到场地外面吧o(╯□╰)o，最后的postInvalidate()是关键，触发onDraw方法，实现重新绘制。\n\n**这里有一个细节，不知你发现没有，我们在更新坐标的时候，每次都是在当前坐标的位置，减去了滑动距离（distanceX/distanceY)。这是为什么(⊙o⊙)?，为什么不是加呢？**\n\n我们可以看看这个回调方法的定义\n\n```java\n       /**\n         * Notified when a scroll occurs with the initial on down {@link MotionEvent} and the\n         * current move {@link MotionEvent}. The distance in x and y is also supplied for\n         * convenience.\n         *\n         * @param e1 The first down motion event that started the scrolling.\n         * @param e2 The move motion event that triggered the current onScroll.\n         * @param distanceX The distance along the X axis that has been scrolled since the last\n         *              call to onScroll. This is NOT the distance between {@code e1}\n         *              and {@code e2}.\n         * @param distanceY The distance along the Y axis that has been scrolled since the last\n         *              call to onScroll. This is NOT the distance between {@code e1}\n         *              and {@code e2}.\n         * @return true if the event is consumed, else false\n         */\n        boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY);\n```\n\n可以看到，这里特定强调了**This is NOT the distance between {@code e1}and {@code e2}**，就是说这个距离并不是两次事件e1和e2 之间的距离。那么这个距离又是什么呢？那我们就找一找到底是在哪里触发了这个回调方法.\n\n最终在GestureDetector类的onTouchEvent()方法里找到了触发这个方法发生的地方：\n\n\n```java\npublic boolean onTouchEvent(MotionEvent ev) {\n\n\t.....\n\n        final boolean pointerUp =\n                (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;\n        final int skipIndex = pointerUp ? ev.getActionIndex() : -1;\n\n        // Determine focal point\n        float sumX = 0, sumY = 0;\n        final int count = ev.getPointerCount();\n        for (int i = 0; i < count; i++) {\n            if (skipIndex == i) continue;\n            sumX += ev.getX(i);\n            sumY += ev.getY(i);\n        }\n        final int div = pointerUp ? count - 1 : count;\n        final float focusX = sumX / div;\n        final float focusY = sumY / div;\n\n        boolean handled = false;\n\n        switch (action & MotionEvent.ACTION_MASK) {\n\n        case MotionEvent.ACTION_MOVE:\n            if (mInLongPress || mInContextClick) {\n                break;\n            }\n            final float scrollX = mLastFocusX - focusX;\n            final float scrollY = mLastFocusY - focusY;\n            if (mIsDoubleTapping) {\n                // Give the move events of the double-tap\n                handled |= mDoubleTapListener.onDoubleTapEvent(ev);\n            } else if (mAlwaysInTapRegion) {\n                final int deltaX = (int) (focusX - mDownFocusX);\n                final int deltaY = (int) (focusY - mDownFocusY);\n                int distance = (deltaX * deltaX) + (deltaY * deltaY);\n                if (distance > mTouchSlopSquare) {\n                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);\n                    mLastFocusX = focusX;\n                    mLastFocusY = focusY;\n                    mAlwaysInTapRegion = false;\n                    mHandler.removeMessages(TAP);\n                    mHandler.removeMessages(SHOW_PRESS);\n                    mHandler.removeMessages(LONG_PRESS);\n                }\n                if (distance > mDoubleTapTouchSlopSquare) {\n                    mAlwaysInBiggerTapRegion = false;\n                }\n            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {\n                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);\n                mLastFocusX = focusX;\n                mLastFocusY = focusY;\n            }\n            break;\n\n        \n        return handled;\n    }\n```\n\n这里还涉及到多指触控的考虑，情况较为复杂；简单说一下结论，**在ACTION_MOVE时，会从上一次手指离开的距离，减去此次手指触碰的位置；这样当scrollX>0时，就是在向右滑动，反之向左；scrollY > 0 时，是在向上滑动，反之向下**；因此，这两个距离和我们习以为常的方向恰好都是相反的，因此，在更新坐标时，需要做相反的处理。\n\n**有兴趣的同学，可以把上面的“-”改成“+”，尝试运行一下代码，就会明白其中的道理了。**\n\n好了，到了这里按照**绘制，布局，触摸反馈**的顺序我们已经完成了BallGameView这个自定义View自己的内容了，但是我们还看到在点击下面的球员头像时，还有一个简单的动画，下面就看看动画是如何实现的。\n\n\n## 动画效果\n\n首先说明一下，底部球员列表是一个横向的RecyclerView，这样一个横向滑动的双列展示的RecyclerView 应该很简单了，这里就不再详述。文末有源码，最后可以查看。\n\n这里看一下每一个RecyclerView中item的点击事件\n\n\n```java\n\n@Override\n    public void onRVItemClick(ViewGroup parent, View itemView, int position) {\n\n        if (mPlayerBeanList.get(position).isSelected()) {\n            Toast.makeText(mContext, \"球员已被选择!\", Toast.LENGTH_SHORT).show();\n        } else {\n            View avatar = itemView.findViewById(R.id.img);\n            int width = avatar.getWidth();\n            int height = avatar.getHeight();\n            Bitmap bitmap = Tools.View2Bitmap(avatar, width, height);\n            int[] location = new int[2];\n            itemView.getLocationOnScreen(location);\n            if (bitmap != null) {\n                mGameView.updatePlayer(bitmap, mPlayerBeanList.get(position).getName(), location, content);\n            }\n\n        }\n\n    }\n```\n\n这里可以看到调用了GameView的updatePlayer方法：\n\n```java\n/**\n     * 在下方球员区域，选中球员后，根据位置执行动画，将球员放置在选中的气泡中\n     *\n     * @param bitmap      被选中球员bitmap\n     * @param name        被选中球员名字\n     * @param location    被选中球员在屏幕中位置\n     * @param contentView 根视图（方便实现动画）\n     */\n    public void updatePlayer(final Bitmap bitmap, final String name, int[] location, final ViewGroup contentView) {\n\n        Path mPath = new Path();\n        mPath.moveTo(location[0] + bitmap.getWidth() / 2, location[1] - bitmap.getHeight() / 2);\n        mPath.lineTo(positions[currentPos].x - playW / 2, positions[currentPos].y - playW / 2);\n\n\n        final ImageView animImage = new ImageView(getContext());\n        animImage.setImageBitmap(bitmap);\n        RelativeLayout.LayoutParams params = new RelativeLayout.LayoutParams(120, 120);\n        contentView.addView(animImage, params);\n\n\n        final float[] animPositions = new float[2];\n        final PathMeasure mPathMeasure = new PathMeasure(mPath, false);\n\n        mValueAnimator = ValueAnimator.ofFloat(0, mPathMeasure.getLength());\n        mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                float value = (float) animation.getAnimatedValue();\n                mPathMeasure.getPosTan(value, animPositions, null);\n\n                animImage.setTranslationX(animPositions[0]);\n                animImage.setTranslationY(animPositions[1]);\n\n            }\n        });\n\n        mValueAnimator.addListener(new AnimatorListenerAdapter() {\n            @Override\n            public void onAnimationEnd(Animator animation) {\n                super.onAnimationEnd(animation);\n\n                contentView.removeView(animImage);\n\n                players[currentPos].setBitmap(bitmap);\n                players[currentPos].setSetReal(true);\n                players[currentPos].setName(name);\n\n                invalidate();\n\n\n            }\n        });\n        mValueAnimator.setDuration(500);\n        mValueAnimator.setInterpolator(new AccelerateInterpolator());\n        mValueAnimator.start();\n\n\n    }\n```\n\n这个动画，简单来说就是一个一阶贝塞尔曲线。根据RecyclerView中item在屏幕中的位置，构造一个一模一样的ImageView添加到根视图中，然后通过一个属性动画，在属性值不断更新时，在回调方法中不断调用setTranslation方法，改变这个ImageView的位置，呈现出动画的效果。动画结束后，将这个ImageView从视图移除，同时气泡中的数据即可，最后再次invalidate导致整个视图重新绘制，这样动画完成时，气泡就被替换为真实的头像了。\n\n\n\n到这里，基本上所有功能，都实现了。最后就是把自己排出来的阵型，保存为图片分享给小伙伴了。这里主要说一下保存图片的实现；分享功能，就不作为重点讨论了。\n\n## 自定义View保存为Bitmap\n\n\n```java\nprivate class SavePicTask extends AsyncTask<Bitmap, Void, String> {\n\n        @Override\n        protected String doInBackground(Bitmap... params) {\n            Bitmap mBitmap = params[0];\n            String filePath = \"\";\n            Calendar now = new GregorianCalendar();\n            SimpleDateFormat simpleDate = new SimpleDateFormat(\"yyyyMMddHHmmss\", Locale.getDefault());\n            String fileName = simpleDate.format(now.getTime());\n            //保存在应用内目录，免去申请读取权限的麻烦\n            File mFile = new File(mContext.getExternalFilesDir(Environment.DIRECTORY_PICTURES), fileName + \".jpg\");\n            try {\n                OutputStream mOutputStream = new FileOutputStream(mFile);\n                mBitmap.compress(Bitmap.CompressFormat.JPEG, 100, mOutputStream);\n                mOutputStream.flush();\n                mOutputStream.close();\n                filePath = mFile.getAbsolutePath();\n\n\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n\n            return filePath;\n        }\n    }\n```\n\n```java\n\n                mGameView.setDrawingCacheEnabled(true);\n                Bitmap mBitmap = mGameView.getDrawingCache();\n\n                if (mBitmap != null) {\n                    new SavePicTask().execute(mBitmap);\n                } else {\n                    Toast.makeText(mContext, \"fail\", Toast.LENGTH_SHORT).show();\n                }\n\n```\n\n\n一个典型的AsyncTask实现，文件流的输出，没什么多说的。主要是存储目录的选择，**这里有个技巧，如果没有特殊限制，平时我们做开发的时候，可以 把一些存储路径做如下定义**\n\n\n- mContext.getExternalFilesDir(Environment.DIRECTORY_PICTURES)：代表/storage/emulated/0/Android/data/{packagname}/files/Pictures\n- mContext.getExternalCacheDir() 代表 /storage/emulated/0/Android/data/{packagname}/cache\n\n对于mContext.getExternalFilesDir还可定义为Environment.DIRECTORY_DOWNLOADS，Environment.DIRECTORY_DOCUMENTS等目录，对应的文件夹名称也会变化。\n\n这个目录中的内容会随着用户卸载应用，一并删除。**最重要的是，读写这个目录是不需要权限的，因此省去了每次做权限判断的麻烦，而且也避免了没有权限时的窘境**。\n\n\n到这里，模仿功能，全部都实现了。下面稍微来一点额外的扩展。\n\n我们希望**图片保存后可以在通知栏提示用户，点击通知栏后可以通过手机相册查看保存的图片。**\n\n\n## 扩展-Android  Notification & FileProvider 的使用\n\n```\nprivate void SaveAndNotify() {\n        if (!TextUtils.isEmpty(picUrl)) {\n          \n            NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(mContext);\n            mBuilder.setWhen(System.currentTimeMillis())\n                    .setTicker(\"下载图片成功\")\n                    .setContentTitle(\"点击查看\")\n                    .setSmallIcon(R.mipmap.app_start)\n                    .setContentText(\"图片保存在:\" + picUrl)\n                    .setAutoCancel(true)\n                    .setOngoing(false);\n            //通知默认的声音 震动 呼吸灯\n            mBuilder.setDefaults(NotificationCompat.DEFAULT_ALL);\n\n            Intent mIntent = new Intent();\n            mIntent.setAction(Intent.ACTION_VIEW);\n            Uri contentUri;\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n                // 将文件转换成content://Uri的形式\n                contentUri = FileProvider.getUriForFile(mContext, getPackageName() + \".provider\", new File(picUrl));\n                // 申请临时访问权限\n                mIntent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n            } else {\n                contentUri = Uri.fromFile(new File(picUrl));\n            }\n\n            mIntent.setDataAndType(contentUri, \"image/*\");\n\n\n            PendingIntent mPendingIntent = PendingIntent.getActivity(mContext\n                    , 0, mIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n            mBuilder.setContentIntent(mPendingIntent);\n            Notification mNotification = mBuilder.build();\n            mNotification.flags |= Notification.FLAG_AUTO_CANCEL;\n            NotificationManager mManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n            mManager.notify(0, mNotification);\n        } else {\n            T.showSToast(mContext, \"图片保存失败\");\n        }\n    }\n```\n\nAndroid 系统中的通知栏，随着版本的升级，已经形成了固定了写法，在Builder模式的基础上，通过链式写法，可以非常方便的设置各种属性。这里重点说一下PendingIntent的用法，我们知道这个PendingIntent 顾名思义，就是处于Pending状态，当我们点击通知栏，就会触发他所包含的Intent。\n\n严格来说，通过自己的应用想用手机自带相册打开一张图片是无法实现的，因为无法保证每一种手机上面相册的包名是一样的，因此这里我们创建ACTION=Intent.ACTION_VIEW的 Intent，去匹配系统所有符合这个Action 的Activity，系统相册一定是其中之一。\n\n到这里，还有一定需要注意，Android 7.0 开始，无法以file://xxxx 形式向外部应用提供内容了，因此需要考虑使用FileProvider。当然，对这个问题，Google官方提供了完整的使用实例，实现起来都是套路，没有什么特别之处。\n\n重点记住下面的对应关系即可：\n\n```\n <root-path/> 代表设备的根目录new File(\"/\");\n <files-path/> 代表context.getFilesDir()\n <cache-path/> 代表context.getCacheDir()\n <external-path/> 代表Environment.getExternalStorageDirectory()\n <external-files-path>代表context.getExternalFilesDirs()\n <external-cache-path>代表getExternalCacheDirs()\n```\n\n\n按照上面，我们存储图片的目录，我们在file_path.xml 做如下定义即可：\n\n```xml\n\n<paths xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <external-path\n        name=\"root\"\n        path=\"\"/>\n</paths>\n```\n在AndroidManifest中完成如下配置 ：\n\n```\n        <!-- Android 7.0 FileUriExposedException -->\n        <provider\n            android:name=\"android.support.v4.content.FileProvider\"\n            android:authorities=\"${applicationId}.provider\"\n            android:exported=\"false\"\n            android:grantUriPermissions=\"true\">\n            <meta-data\n                android:name=\"android.support.FILE_PROVIDER_PATHS\"\n                android:resource=\"@xml/file_path\"/>\n        </provider>\n```\n\n这样，当Build.VERSION.SDK_INT大于等于24及Android7.0时，可以安心的使用FileProvider来和外部应用共享文件了。\n\n\n\n## 最后\n\n好了，从一个简单的自定义View 出发，又牵出了一大堆周边的内容。好在，总算完整的说完了。\n\n**特别申明**\n\n>以上代码中所用到的图片资源，全部源自懂球帝APP内；此处对应用解包，只是本着学习的目的，没有其他任何用意。\n\n\n\n******************\n\n**源码地址：** [Github-AndroidAnimationExercise](https://github.com/REBOOTERS/AndroidAnimationExercise)。\n\n有兴趣的同学欢迎 star &  fork。\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["自定义View"],"categories":["Android 进阶"]},{"title":"仿简书长按文章生成图片效果","url":"%2F2017%2F03%2F19%2F%E4%BB%BF%E7%AE%80%E4%B9%A6%E9%95%BF%E6%8C%89%E6%96%87%E7%AB%A0%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E6%95%88%E6%9E%9C%2F","content":"\n\n## 前言\n\n使用简书APP的同学都知道，简书有这样一个功能；文章页长按内容时底部会出现一个**生成图片分享**的按钮，点击之后就可以将当前的文章生成一张长图片；这张图片可以保存到本地或分享给好友，同时还可为图片设置成为白和黑两种风格，很有艺术范。个人一直很喜欢这个功能。\n\n但是从某一个版本开始，这个功能开始有bug了，生成的图片只有底部的固定标题，而没有文章内容，长图也变成了小短图。向简书意见反馈后，得到的回复是，使用点击分享按钮生成图片功能；分享菜单包含的生成长图功能的确是可以的。但是，还是很怀念之前长按生成图片的功能，所以作为一名程序猿；怀着好奇的心情，决定自己去实现这样一个功能.\n\n## 效果预览\n\n老规矩，首先看一下实现后的效果；虽然整体没有简书有范，个人感觉还是挺像的。\n\n\n![效果图](https://user-gold-cdn.xitu.io/2017/3/19/5bfdffd406bed1f24293ff9cc5ffe3c8)\n\n<!--more-->\n\n## 文章页实现\n\n#### 内容\n\n文章页内容的实现，没有什么难点。布局总的来说很简单，包含户信息和文章信息的一个LinearLayout，外加一个WebView即可。数据是根据布局中所需的内容，封装了一个HtmlBean 对象，而这个对象的则是通过使用Jsoup 解析当前页面的HTML文档内容获得（这里使用Jsoup 方式获取简书网页内容，只是个人学习，没有其他用意）。具体实现可查看[源码](https://github.com/REBOOTERS/AndroidAnimationExercise)\n\n#### 长按菜单实现\n\n这里特意说一下，长按弹出底部按钮的实现方式。一般情况下对于长按效果的实现，我们都会通过设置View的OnLongClickListene事件去实现相应的功能，但是对于这里的WebView可以如下实现：\n\n```java\n        mWebView.setOnCreateContextMenuListener(new View.OnCreateContextMenuListener() {\n            @Override\n            public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n                genImg.setVisibility(View.VISIBLE);\n                T.showSToast(mContext, \"再次点击文章可隐藏图片分享\");\n            }\n        });\n        // 点击隐藏底部按钮\n        mWebView.setOnTouchListener(new View.OnTouchListener() {\n            @Override\n            public boolean onTouch(View v, MotionEvent event) {\n                switch (event.getAction()) {\n                    case MotionEvent.ACTION_DOWN:\n                        lastTime = SystemClock.uptimeMillis();\n                        break;\n                    case MotionEvent.ACTION_UP:\n                        if (SystemClock.uptimeMillis() - lastTime < 300) {\n                            genImg.setVisibility(View.GONE);\n                        }\n                        break;\n                }\n                return false;\n            }\n        });\n```\n*****\n这里通过监听WebView的ContextMenu 监听何时显示底部按钮；同时在onTouch方法中隐藏底部按钮。\n\n```java\n        genImg.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                genImg.setVisibility(View.INVISIBLE);\n                Intent intent = new Intent(FakeJianShuActivity.this, GenScreenShotActivity.class);\n                intent.putExtra(\"data\", mHtmlBean);\n                startActivity(intent);\n            }\n        });\n```\n点击底部的Button就会跳转到生成长图的界面，同时将之前获取到的HTMLBean对象传递过去。\n\n## 长图效果实现\n\n这里首先说一下实现思路（思路来源于[此](http://www.jianshu.com/p/c34aad68bf46)）。\n- 首先通过WebView加载一个本地的Html页面，这个页面包含一些固定，定义了一些标签。然后根据传递过来的mHtmlBean 对象中的信息，通过执行JavaScript动态的替换静态HTML页面中的内容；\n- 关于黑白两种风格的实现，同样是WebView执行Js，动态替换HTML中CSS 样式，修改WebView的背景色呈现出两种不同的UI 效果。\n- 通过WebView的capturePicture 和Canvas 可以生成出当前WebView的Bitmap对象，有了这个Bitmap就可以图片保存的功能了。\n\n好了，下面就通过代码分别实现上述步骤。\n\n#### Html 页面（JianShu.html）\n\n```html \n<html>\n<head>\n    <meta charset=\"utf-8\"/>\n</head>\n<body>\n<img src=\"mark.png\" width=\"13px\" height=\"20px\"\n     style=\"position:absolute;top: 0px;left: 12px;margin-bottom: 15px;\"/>\n<article id=\"content\" style=\"margin: 25px;\"></article>\n<script type=\"text/javascript\">\n        function changeContent(content) {\n            document.getElementById('content').innerHTML = content;\n        }\n\n</script>\n</body>\n</html>\n```\n\n这个HTML页面的内容很简单，在整个文档左上角放置了一个小角标，就是简书APP生成长图时的那个mark.\n同时定义了一个JavaScript 方法，功能也很简单，就是用传递的参数content替换article标签中的文档内容。 \n\n#### 自定义WebView \n\n为了方便，我们自定义WebView，这里看一下核心逻辑：\n\n```java\npublic class FakeWebView extends WebView {\n     \n    private boolean isFirstLoad = false;\n\n    public void loadData(HtmlBean bean) {\n        assembleData(bean);\n        if (Build.VERSION.SDK_INT >= 21) {\n            isFirstLoad = true;\n            webView.setWebChromeClient(new WebChromeClient() {\n                @Override\n                public void onProgressChanged(WebView view, int newProgress) {\n                    if (newProgress == 100) {\n                        if (isFirstLoad) {\n                            isFirstLoad = false;\n                            Log.e(\"TAG\", \"onProgressChanged\");\n                            updateView();\n                        }\n                    }\n                }\n            });\n        } else {\n            isFirstLoad = true;\n            webView.setVisibility(View.INVISIBLE);\n\n            webView.setWebChromeClient(new WebChromeClient() {\n                @Override\n                public void onProgressChanged(WebView view, int newProgress) {\n                    if (newProgress == 100) {\n                        updateView();\n                        if (!isFirstLoad)\n                            webView.setVisibility(View.VISIBLE);\n                    }\n                }\n            });\n        }\n        webView.loadUrl(\"file:///android_asset/JianShu.html\");\n\n    }\n\n    private void assembleData(HtmlBean bean) {\n        final String data = bean.getContent();\n        final String title = bean.getTitle();\n        final String username = bean.getUsername();\n        final String publishTime = bean.getPublishTime();\n        String Title = \"<h2>\" + title + \"</h2>\";\n        String Footer = \"<p>\" + username + \"</p><p>\" + publishTime + \"</p>\";\n        content = Title + data + Footer;\n    }\n\n\n    public void updateView() {\n        if (mode == MODE_DAY) {\n            webView.setBackgroundColor(Color.WHITE);\n        } else {\n            webView.setBackgroundColor(Color.parseColor(\"#263238\"));\n            content = \"<div style=\\\"color: gray;display: inline;\\\">\" + content + \"</div>\";\n        }\n        webView.loadUrl(\"javascript:changeContent(\\\"\" + content.replace(\"\\n\", \"\\\\n\").replace(\"\\\"\", \"\\\\\\\"\").replace(\"'\", \"\\\\'\") + \"\\\")\");\n    }\n}\n```\n\n这几个方法是生成长图最核心的方法。在loadData 方法中首先调用了assembleData，这个方法会根据mHtmlBean 这个对象中的数据拼接出一段 HTML 文档。在webView的loadUrl 方法中会从本地加载之前定义好的JianShu.html这个页面。然后在页面加载完成，即onProgressChanged 回调方法中newProgress 的值等于100时调用updateView方法；这个方法会根据当前设置的模式，设置WebView的背景，如果是夜间模式，则会对assembleData 中生成的文档外部在添加 一个灰色风格的div标签，将整个内容包在这个div标签中，最后WebView执行JS方法 changeContent，传递的参数就是之前我们拼接好的内容。这样整个WebView又会刷新一次，整个WebView的内容就是文章内容了。\n\n####  GenScreenShotActivity \n\n```java\n        mFakeWebView = (FakeWebView) findViewById(R.id.fakeWebView);\n        bean = (HtmlBean) getIntent().getSerializableExtra(\"data\");\n        RadioGroup changeMode = (RadioGroup) findViewById(R.id.changeMode);\n        changeMode.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(RadioGroup group, @IdRes int checkedId) {\n                if (checkedId == R.id.rb_day) {\n                    mFakeWebView.setMode(FakeWebView.MODE_DAY);\n                } else {\n                    mFakeWebView.setMode(FakeWebView.MODE_NIGHT);\n                }\n            }\n        });\n        mFakeWebView.loadData(bean);\n\n      /**\n     * @param mode\n     */\n    public void setMode(@ViewMode int mode) {\n        this.mode = mode;\n        updateView();\n    }\n```\n\n这样在Activity中，mFakeWebView对象通过上一个页面（文章页）传递的mHtmlBean 对象就可以更新当前视图了，同时可以通过RadioButton实现页面风格的切换。\n\n#### 保存图片\n距离我们最后的目标**生成长图片**，前面的工作可以说只是完成了50%，因为到目前为止我们只不过是在WebView中把整个文章内容加载出来而已；长图还没有呢。因此，下面的工作就是通过WebView 生成长图。\n\n```java \n    public Bitmap getScreenView(){\n        Picture snapShot = webView.capturePicture();\n        Bitmap bmp = Bitmap.createBitmap(snapShot.getWidth(),snapShot.getHeight(), Bitmap.Config.ARGB_8888);\n        Canvas canvas = new Canvas(bmp);\n        snapShot.draw(canvas);\n        return bmp;\n    }\n```\n\nWebVeiw 很人性化，通过这个方法，我们就可以获得当前WebView视图**可见与不可见**部分的Bitmap了。\n其实通过WebView生成图片并不是一件难事，难得是如何把我们这里的图片保存下来；因为我们这里生成的是长图，如下图所示，这张照片的高度达到了惊人的。因此这里就要需要之前在[Bitmap 初探](http://www.jianshu.com/p/dc5e390d189a)中提到的第一种压缩方法进行文件大小的压缩了。具体实现，就不再重复贴出代码了，有兴趣的同学可参考文末Github源码。\n\n\n\n到这里，我们就完全实现了仿照简书长按生成图片的功能。那么回过头再来看，这样一个功能，为什么在我的手机上，简书APP的长按功能会有bug呢。\n\n## 缺陷\n\n文章详情页的WebView是系统自带的WebView，在加载带 代码的文章时，没有对代码类的内容做特殊的解析，因此无法对代码高亮显示。只是最为普通的文本进行了显示，因此生成的长图中代码也是普通文本。简书APP还是高大上呀，对代码的高亮显示正是棒棒哒！\n\n## 后话\n\n一个偶然的机会，在尝试简书长按生成图片的功能时发现，原来简书是通过WebView选择的区域生成第二页的内容；因此当我在文章页空白区域长按后，点击生成图片时必然是只有空白的，只有底部的一些固定标签。因此，这应该不算是一个bug，只是为大家提供了一种更方便的功能，可以按自己喜欢的内容生成更有效的长图。\n\n*******\n最后 [Github AndroidAnimationExercise](https://github.com/REBOOTERS/AndroidAnimationExercise)，这是一个平常自己学习Android各种动画、自定义View的集合项目，有兴趣的同学欢迎 star & fork 。","tags":["自定义View"],"categories":["Android 进阶"]},{"title":"2017 booklist","url":"%2F2017%2F03%2F01%2F2017-booklist%2F","content":"\n\n- 尤瓦尔·赫拉利-人类简史 Done\n- 肯·福莱特-世纪三部曲-巨人的陨落 Done\n- 肯·福莱特-世纪三部曲-世界的凛冬 Done\n- 肯·福莱特-世纪三部曲-永恒的边缘 Done\n\n\ntodo\n\n- 刘慈欣-三体 Delayed\n","tags":["读书"]},{"title":"Android MVP 十分钟入门！","url":"%2F2017%2F01%2F24%2FAndroid%20MVP%20%E5%8D%81%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8%EF%BC%81%2F","content":"\n## 前言##\n在日常开发APP 的过程中，随着业务的扩展，规模的变化。我们的代码规模也会逐渐变得庞大，每一个类里的代码也会逐渐增多。尤其是Activity和Fragment ，由于Context 的存在，基本上所有对视图的操作我们只能在Activity和Fragment中完成；即便是对某些逻辑进行封装，Activity和Fragment 依旧会显得过于臃肿。因此，我们需要换一种思路去写代码，这个时候MVP模式就应用而生了！那么MVP 怎么用呢，下面就来说一说。\n\n假设你现在如要实现下图中的功能：\n\n\n![](https://lc-mhke0kuv.cn-n1.lcfile.com/ddbae96177704862aa4c.jpg)\n\n这个需求很简单，就是点击按钮，下载一张图片，显示下载进度；下载完成后，在ImageView中显示这张图片。\n下面我们就分别用传统的方式（也就是所谓的MVC)和MVP 模式分别取实现这个功能。然后分析一下MVP 到底好在哪里。\n\n<!--more-->\n\n## MVC##\n\n```java\npublic class MVCActivity extends AppCompatActivity {\n\n    private Context mContext;\n    private ImageView mImageView;\n    private MyHandler mMyHandler;\n    private ProgressDialog progressDialog;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_mvc);\n        mContext = this;\n        init();\n    }\n\n    private void init() {\n        //view init\n        mImageView = (ImageView) findViewById(R.id.image);\n        mMyHandler = new MyHandler();\n\n        progressDialog = new ProgressDialog(mContext);\n        progressDialog.setButton(DialogInterface.BUTTON_NEGATIVE, \"Cancle\", new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialog, int which) {\n                progressDialog.dismiss();\n            }\n        });\n        progressDialog.setCanceledOnTouchOutside(false);\n        progressDialog.setTitle(\"下载文件\");\n        progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n\n\n        //click-event\n        findViewById(R.id.downloadBtn).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                progressDialog.show();\n                HttpUtil.HttpGet(Constants.DOWNLOAD_URL, new DownloadCallback(mMyHandler));\n            }\n        });\n\n        findViewById(R.id.downloadBtn1).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                progressDialog.show();\n                HttpUtil.HttpGet(Constants.DOWNLOAD_ERROR_URL, new DownloadCallback(mMyHandler));\n            }\n        });\n\n    }\n\n\n    class MyHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n            switch (msg.what) {\n                case 300:\n                    int percent = msg.arg1;\n                    if (percent < 100) {\n                        progressDialog.setProgress(percent);\n                    } else {\n                        progressDialog.dismiss();\n                        Glide.with(mContext).load(Constants.LOCAL_FILE_PATH).into(mImageView);\n                    }\n                    break;\n                case 404:\n                    progressDialog.dismiss();\n                    Toast.makeText(mContext, \"Download fail !\", Toast.LENGTH_SHORT).show();\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n}\n```\n用mvc的方式，一个Activity就能搞定。代码逻辑很简单，点击按钮后显示之前初始化好ProgressDialog，然后开始下载任务（这里HttpUtil 内部简单封装了OKHttp 的异步GET请求，实现下载文件保存到本地的功能，实现细节在此不做深入探讨，有兴趣的同学可以查看[源码](https://github.com/REBOOTERS/My-MVP))，然后将请求结果通过Handler返回，在handleMessage中根据返回数据的信息做出不同的UI 处理；下载成功时在ImageView中显示图片，下载失败时Toast提示。\n\n可以发现，在这种情况之前，Activity的任务十分繁重，既要负责下载任务的具体实施，还要根据下载进行再次的逻辑判断，才能去更新UI。这里只是一个简单的任务，你可能觉得无所谓，但是实际开发中，一个Activity中有许多的交互事件，这个时候Activity的代码就显得特别的庞大；一旦需求变更或出现bug，那简直就是噩梦一场。\n\n因此，我们希望Activity可以变成下面这样\n\n- 他负责发起处理和用户交互的内容，但又不负责具体的实现；\n- 需要显示什么，不显示什么，什么东西显示多少，有个东西可以直接告诉他，\n- Activity不再做复杂的逻辑处理；\n\n具体到上面的demo里就是，**Activity负责发起下载任务，但是不负责具体实现；什么时候显示ProgressDialog，显示多少？什么时候提示错误信息，这一切都希望有个东西能直接告诉Activity，而不再是在Activity里再做判断。怎样才能做到呢？那就得靠MVP 了。**\n\n## MVP ##\n\n**MVP 模式所做的事情很简单，就是将业务逻辑和视图逻辑抽象到接口中。**\n\n怎么理解呢，我们就根据此次要实现的下载功能，用代码说话。\n\n### 定义Model，View，Presenter 接口###\n\n#### Model Interface####\n\nModel 接口定义所有需要实现的**业务逻辑**，在我们的下载任务中，业务逻辑只有一个，就是下载；因此Model 接口可以这么定义 ：\n\n```java\npublic interface IDownloadModel {\n    /**\n     * 下载操作\n     * @param url\n     */\n    void download(String url);\n}\n```\n\n#### View Interface####\n\nView 接口定义所有需要实现的**视图逻辑**，在我们的下载任务中，视图逻辑包括\n- 显示ProgressDialog；\n- 显示Dialog具体进度；\n- 显示具体的View（设置图片）；\n- 显示错误信息（Toast提示）\n\n因此View接口可以这么定义：\n\n```java\npublic interface IDownloadView {\n    /**\n     * 显示进度条\n     * @param show\n     */\n    void showProgressBar(boolean show);\n\n    /**\n     * 设置进度条进度\n     * @param progress\n     */\n    void setProcessProgress(int progress);\n\n    /**\n     * 根据数据设置view\n     * @param result\n     */\n    void setView(String result);\n\n    /**\n     * 设置请求失败时的view\n     */\n    void showFailToast();\n}\n```\n#### Presenter Interface####\n\nPresenter 接口作为连接Model和View的中间桥梁，需要将二者连接起来，因此他需要完成以下工作：\n- 执行下载任务\n- 下载成功返回下载结果\n- 下载过程返回下载进度\n- 下载失败回调\n\n因此，Presenter 就可以这么定义：\n\n```java\npublic interface IDowndownPresenter {\n    /**\n     * 下载\n     * @param url\n     */\n    void download(String url);\n\n    /**\n     * 下载成功\n     * @param result\n     */\n    void downloadSuccess(String result);\n\n    /**\n     * 当前下载进度\n     * @param progress\n     */\n    void downloadProgress(int progress);\n\n    /**\n     * 下载失败\n     */\n    void downloadFail();\n}\n```\n### 接口Model，View，Presenter 具体实现###\n\n上面实现了，各个接口的定义，下面来看看他们具体的实现：\n\n#### Model 具体实现####\n\n```java\npublic class DownloadModel implements IDownloadModel {\n    private IDowndownPresenter mIDowndownPresenter;\n    private MyHandler mMyHandler = new MyHandler();\n\n    public DownloadModel(IDowndownPresenter IDowndownPresenter) {\n        mIDowndownPresenter = IDowndownPresenter;\n    }\n\n    @Override\n    public void download(String url) {\n        HttpUtil.HttpGet(url, new DownloadCallback(mMyHandler));\n    }\n\n    class MyHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n            switch (msg.what) {\n                case 300:\n                    int percent = msg.arg1;\n                    if (percent < 100) {\n                        mIDowndownPresenter.downloadProgress(percent);\n                    } else {\n                        mIDowndownPresenter.downloadSuccess(Constants.LOCAL_FILE_PATH);\n                    }\n                    break;\n                case 404:\n                    mIDowndownPresenter.downloadFail();\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n}\n```\n在MVP模式中，Model的工作就是完成具体的业务操作，网络请求，持久化数据增删改查等任务。同时Model中又不会包含任何View。\n这里Model的具体实现很简单，将Http任务的结果返回到Handler当中，而在Handler中的实现又是由Presenter完成。\n那么Presenter接口又是怎样实现的呢？赶紧来看看\n\n#### Presenter 具体实现####\n\n```java\npublic class DownloadPresenter implements IDowndownPresenter {\n    private IDownloadView mIDownloadView;\n    private IDownloadModel mIDownloadModel;\n\n\n    public DownloadPresenter(IDownloadView IDownloadView) {\n        mIDownloadView = IDownloadView;\n        mIDownloadModel = new DownloadModel(this);\n    }\n\n    @Override\n    public void download(String url) {\n        mIDownloadView.showProgressBar(true);\n        mIDownloadModel.download(url);\n    }\n\n    @Override\n    public void downloadSuccess(String result) {\n        mIDownloadView.showProgressBar(false);\n        mIDownloadView.setView(result);\n    }\n\n    @Override\n    public void downloadProgress(int progress) {\n        mIDownloadView.setProcessProgress(progress);\n    }\n\n    @Override\n    public void downloadFail() {\n        mIDownloadView.showProgressBar(false);\n        mIDownloadView.showFailToast();\n    }\n}\n```\n\n可以看到，我们在DownloadPresenter的构造方法中，同时实例化了Model和View，这样Presenter中就同时包含了两者；\n这样；**在Presenter具体实现中，业务相关的操作由Model去完成（例如download），视图相关的操作由View去完成\n（如setView等）**。Presenter 作为桥梁的作用就这样体现出来了，巧妙的将View和Model的具体实现连接了起来。\n\n\n#### View具体实现####\n\n最后再看一下View接口的具体实现，也就是Activity的实现：\n\n```java\npublic class MVPActivity extends AppCompatActivity implements IDownloadView {\n    private Context mContext;\n    private ImageView mImageView;\n    private ProgressDialog progressDialog;\n\n    private DownloadPresenter mDownloadPresenter;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mContext = this;\n        setContentView(R.layout.activity_mvp);\n        init();\n    }\n\n    private void init() {\n        mDownloadPresenter = new DownloadPresenter(this);\n        //view init\n        mImageView = (ImageView) findViewById(R.id.image);\n        findViewById(R.id.downloadBtn).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                mDownloadPresenter.download(Constants.DOWNLOAD_URL);\n            }\n        });\n\n        findViewById(R.id.downloadBtn1).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                mDownloadPresenter.download(Constants.DOWNLOAD_ERROR_URL);\n            }\n        });\n\n        progressDialog = new ProgressDialog(mContext);\n        progressDialog.setButton(DialogInterface.BUTTON_NEGATIVE, \"Cancle\", new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialog, int which) {\n                progressDialog.dismiss();\n            }\n        });\n        progressDialog.setCanceledOnTouchOutside(false);\n        progressDialog.setTitle(\"下载文件\");\n        progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n\n    }\n\n    @Override\n    public void showProgressBar(boolean show) {\n        if (show) {\n            progressDialog.show();\n        } else {\n            progressDialog.dismiss();\n        }\n    }\n\n    @Override\n    public void setProcessProgress(int progress) {\n        progressDialog.setProgress(progress);\n    }\n\n    @Override\n    public void setView(String result) {\n        Glide.with(mContext).load(result).into(mImageView);\n    }\n\n    @Override\n    public void showFailToast() {\n        Toast.makeText(mContext, \"Download fail !\", Toast.LENGTH_SHORT).show();\n    }\n}\n```\n在点下按钮执行开始下载任务的时候，View（Activity）中没有具体的实现，只是调用了Presenter中的download方法，而Presenter中的download又会去调用Model的download方法，Model又会在根据具体逻辑（在这里就是Http请求）的状态去调用Presenter中的方法，例如我们在handleMessage方法中，调用mIDowndownPresenter.downloadProgress(percent)时，就会去调用Presenter的具体实现\n\n```java\n    @Override\n    public void downloadProgress(int progress) {\n        mIDownloadView.setProcessProgress(progress);\n    }\n```\n而他的内部实现又是操作具体的View，也就是我们在Activity中初始化Presenter中传递的this，也就是当前Activity（View），这样最终回到了Activity中的\n\n```java\n\n    @Override\n    public void setProcessProgress(int progress) {\n        progressDialog.setProgress(progress);\n    }\n```\n我们为progressDialog 设置进度。\n\n\n\n至此，我们就通过MVP 的模式实现了我们之前所设想的Activity\n\n- Button的click方法负责发起下载任务，但又不负责具体实现，而是由Presenter转接给Model去实现\n- Activity 什么时候显示ProgressDialog，什么时候显示Toast直接由Presenter告诉他，他只做一个View想做的事情\n- Activity里没有任何逻辑处理，所有的逻辑判断都在Model中完成了。\n\n这就是MVP ！！！\n\n## MVC VS MVP##\n\n通过上面的两种实现方案，相信每个人都已经理解了MVC和MVP的区别；下面就其各自的优缺点再做一下\n总结；**当然，这里的优缺点只是相对而言**。\n\n#### 优点####\n\n\n![MVC](https://lc-mhke0kuv.cn-n1.lcfile.com/423fe583f67b01d47106.gif)\n\n\n![MVP](https://lc-mhke0kuv.cn-n1.lcfile.com/8de34d72fad5bc8d67e2.png)\n\n\n上面两张图分别是MVC和MVP架构图。相信许多和我一样尝试去学习和了解MVP架构的同学对这两图（或类似的图）并不陌生。\n\n**结构更加清晰***\n\n我们回过头再去看MVCActivity 的实现，暂且将我们对Http请求的封装归结为Model(M),那么剩下的就只有Activity了,而这个Activity即实现视图逻辑，又需要实现部分业务逻辑，也就是说他既是Controller（C）又是View（V）。V和C的划分完全不清晰；因此，传统的代码结构只能勉强称为MV 或者是MC，如果算上xml 的布局文件，才能牵强的称为MVC 结构。\n\n而MVP 就不同了，Model，View，Presenter各司其职，互相搭配，实现了解耦，完全解放了Activity（或者是Fragment）。这就是MVP 的优势，代码结构更加清晰。可以这样说，同一个模块的实现，甚至允许几个人分工完成；假设有一个非常复杂的Activity，如果使用MVP 的模式开发；那么这个时候，定义好MVP的接口之后，就可以有人专门去做Model，另一个人专门去做View；再由一个人写Presenter的代码，当然这需要极强的代码规范和协作能力；但这在传统的MVC模式中根本是无法想象的，所有的东西都在一个类里，两个人一起改，有了冲突怎么玩/(ㄒoㄒ)/~~。\n\n**需求变更，不再是噩梦**\n\n假设现在有新的需求，产品经理认为下载失败后只有一个Toast提示太单调了（而且用户有可能错过了这Toast的显示，而误以为APP失去了响应），因此，现在希望在下载失败后弹出一个Dialog，可以重试下载任务。是想，如果代码使用传统的MVC 结构，恰巧这个代码不是你写的，或者说就是你写的，但是你已经忘记了具体的逻辑；那么为了实现这个需求你又得去重新捋一遍逻辑，到某个类的xxx行进行修改；但是如果使用MVP就不同了View接口已经定义好了showFailToast就是用来显示错误提示的；因此即便代码不是你写的，你都可以很快的找到，应该去哪里改；而省去很多时间。\n\n\n**更容易写单元测试**\n\n这个就不展开说了，总之写过单元测试的人应该都有这样的体会。\n\n#### 缺点####\n\nMVP这么好，也不是没有缺点。\n\n\n![](https://lc-mhke0kuv.cn-n1.lcfile.com/7e28a3b3f0bc414e469b.png)\n\n如图中所示，使用MVP 架构之后，多出了许多类；这是必然的；每一个View（Activity或Fragment）都至少需要各自的Model、Presenter和View接口，在加上他们各自的实现，也就是说每一个页面都会有6个java文件（算上Fragment或Activity，因为他就是View的实现），这样一个稍有点规模的APP，类就会变得异常的多，而每一个类的加载又会消耗资源；因此，相较于MVC，这算是MVP最大的缺点了吧。\n\n当然，对于这个问题我们可以通过泛型参数、抽象父类的方式，将一些公用的Model及Presenter抽象出来。这应该就是使用MVP架构的精髓了。\n\n\n## 最后##\n\n个人感觉，使用MVP 架构是利大于弊的；随着项目规模的增加，代码逻辑的清晰才是最重要的事情。况且Google官方也出推出了一系列关于[MVP的使用demo](https://github.com/googlesamples/android-architecture)。\n因此，这也是官方提倡大家使用的。凡事，有利必有弊；类数目的增长是无法避免的事情，因此如何使用泛型和抽象优化MVP 的结构就变成了我们用好\nMVP的关键了。\n\n当然，我们不能为了MVP而去MVP，如果项目结构不是很庞大，业务不是很复杂；那么传统的MVC 架构足以，而且也方便！\n\n****\n年前的最后一个工作日了，我居然写了一篇学习笔记；今天一定是上了假的班儿！明天回家过年，O(∩_∩)O哈哈哈~！每一个人，新年快乐！\n\n\n\n","tags":["mvp/mvc"],"categories":["Android 进阶"]},{"title":"仿知乎首页学习CoordinateLayout","url":"%2F2016%2F12%2F22%2F%E4%BB%BF%E7%9F%A5%E4%B9%8E%E9%A6%96%E9%A1%B5%E5%AD%A6%E4%B9%A0CoordinateLayout%E7%94%A8%E6%B3%95%2F","content":"\n\n### 前言###\n\n第一次接触CoordinateLayout的时候深深的被其炫酷的特效所吸引；想着什么时候在实际项目中可以使用一下，无奈实际项目因行业特点，并不需要使用到CoordinateLayout这么高端的交互体验；所以本着学习的态度，便用CoordinateLayout模仿了一下知乎首页效果，这也是现在掘金APP首页的效果；这种效果其实很友好，能让用户最大限度的使用到手机屏幕。\n\n\n好了，废话不多说，先看看模仿效果。\n\n<!--more-->\n\n\n![index](https://user-gold-cdn.xitu.io/2016/12/22/f9d16ce6e1191880092de3903be0e63f)\n\n\n![discovery](https://user-gold-cdn.xitu.io/2016/12/22/0fffb5a7fb23a754884ab7b13bb87c60)\n\n\n![message](https://user-gold-cdn.xitu.io/2016/12/22/bedd0f983f9217f3342c45094779718f)\n\n\n![userCenter](https://user-gold-cdn.xitu.io/2016/12/22/cce602916eb19ba376f1e429b96ceb6f)\n\n**这里用到的icon 大部分来源于[iconfont](http://www.iconfont.cn/)。**\n\n*使用模拟器截取gif貌似永远都是这样模糊不清*，有兴趣的同学可以点[github](https://github.com/REBOOTERS/ZhiHuIndex)查看源码，实际运行在手机上效果会比这里好一些。\n\n### 综述###\n\nCoordinateLayout是Android Design Support Library提供的一种布局方式。\n\n\n查看源码我们可以看到 CoordinateLayout继承自ViewGroup，是一个“超级强大”的FrameLayout，FrameLayout 相信大家都很熟悉，使用也很简单，FrameLayout可以说是让Android布局中有了“**层**”的概念，那么这个CoordinateLayout又有什么神奇之处呢，下面我们就学习一下。\n\n**Coordinate  按照字面意思理解，就是协调。它可以方便的实现布局内view协调**\n\n那么究竟是怎么个调节法呢，我们来看一下。\n\n### CoordinateLayout 使用###\n\n#### 结合Snackbar####\n\n关于CoordinateLayout最经典的例子就是其结合Snackbar的使用了。\n\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.design.widget.CoordinatorLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <android.support.design.widget.FloatingActionButton\n        android:id=\"@+id/fab\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"end|bottom\"\n        android:layout_margin=\"16dp\"\n        android:src=\"@drawable/ic_done\" />\n\n</android.support.design.widget.CoordinatorLayout>\n\n```\n\n\n``` java\n@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        findViewById(R.id.fab).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n\n                Snackbar.make(view,\"FAB\",Snackbar.LENGTH_LONG)\n                        .setAction(\"cancel\", new View.OnClickListener() {\n                            @Override\n                            public void onClick(View v) {\n                                \n                            }\n                        })\n                        .show();\n            }\n        });\n    }\n\n```\n****\n\n上面这份代码应该是很多人对CoordinateLayout的第一印象，这也是关于CoordinateLayout最直观的解释。\n\n这里实现的效果就是如上面第三幅动图message中那样，底部弹出一个SnackBar，FloatingActionButton自动上移；这就是所谓的协调，协调FloatingActionButton上移，不被顶部弹出的SnackBar所遮挡。\n\n这里如果没有使用CoordinateLayout作为根布局，而是使用LinearLayout或RelativeLayout等，如果FloatingActionButton距离底部太近，那么它将会被底部弹出的Snackbar所遮挡。\n\n#### 结合AppBarLayout使用####\n\n说到CoordinateLayout就不得不提这个AppBarLayout，他们俩简直就是天生一对，二者结合使用，那画面真是太美了，想想都觉得刺激。\n\n这里看一下我们模仿首页顶部搜索栏的代码：\n\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:id=\"@+id/coordinatorLayout\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".fragments.IndexFragment\">\n\n    <android.support.design.widget.AppBarLayout\n        android:id=\"@+id/index_app_bar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:theme=\"@style/AppTheme.AppBarOverlay\">\n\n        <RelativeLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"?attr/actionBarSize\"\n            android:background=\"@color/colorPrimary\"\n            app:layout_scrollFlags=\"scroll|enterAlways\">\n\n            <ImageView\n                android:id=\"@+id/live\"\n                android:layout_width=\"24dp\"\n                android:layout_height=\"24dp\"\n                android:layout_alignParentRight=\"true\"\n                android:layout_centerVertical=\"true\"\n                android:layout_marginRight=\"5dp\"\n                android:src=\"@drawable/live_button\" />\n\n            <RelativeLayout\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_margin=\"10dp\"\n                android:layout_toLeftOf=\"@id/live\"\n                android:background=\"@color/searchmenu\">\n\n                <ImageView\n                    android:id=\"@+id/search\"\n                    android:layout_width=\"24dp\"\n                    android:layout_height=\"24dp\"\n                    android:layout_centerVertical=\"true\"\n                    android:layout_marginLeft=\"10dp\"\n                    android:src=\"@drawable/ic_search\" />\n\n                <TextView\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"wrap_content\"\n                    android:layout_centerVertical=\"true\"\n                    android:layout_marginLeft=\"10dp\"\n                    android:layout_toRightOf=\"@id/search\"\n                    android:text=\"搜索话题、问题或人\"\n                    android:textSize=\"16sp\" />\n\n            </RelativeLayout>\n        </RelativeLayout>\n    </android.support.design.widget.AppBarLayout>\n\n        .......\n\n</android.support.design.widget.CoordinatorLayout>\n\n```\n***\n这里我们在AppBarLayout内部嵌套了一个RelativeLayout，在这个RelativeLayout中我们模仿了顶部的搜索栏的布局效果，这个很简单。这里最核心的东西就是\n\n``` xml\napp:layout_scrollFlags=\"scroll|enterAlways\"\n```\n\n这行代码。什么意思呢？这个app:layout_scrollFlags有下面几个值：\n\n* scroll: 所有想滚动出屏幕的view都需要设置这个flag， 没有设置这个flag的view将被固定在屏幕顶部。\n\n* enterAlways: 设置这个flag时，向下的滚动都会导致该view变为可见。\n\n* enterAlwaysCollapsed: 当你的视图已经设置minHeight属性又使用此标志时，你的视图只能已最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。\n\n* exitUntilCollapsed: 滚动退出屏幕，最后折叠在顶端。\n\n* snap: 视图在滚动时会有一种“就近原则”，怎么说呢，就是当视图展开时，如果滑动中展   开的内容超过视图的75%,那么视图依旧会保持展开；当视图处于关闭时，如果滑动中展开的部分小于视图的25%，那么视图会保持关闭。总的来说，就是会让动画有一种弹性的视觉效果。\n\n这里我们使用了scroll 和 enterAlways ，就很容易的实现了向下滑动时顶部隐藏，向下滑动时顶部出现的效果。\n\n#### 结合TabLayout使用####\n\n注意，这里所说的TabLayout是android.support.design.widget.TabLayout，不是很久以前的那个TabLayout。\n\n使用这个TabLayout可以产生一种滑动时tab 悬停的效果，这里我们模仿的时候，用于种种原因没能使用TabLayout的动态效果，只是简单的结合ViewPager使用了一下，第二个页面discovery就是使用TabLayout作为顶部的Indicator使用；这个很简单，就不展开说了；具体实现看查看源码。\n\n#### 结合CollapsingToolbarLayout使用####\n\n个人感觉，这是整个CoordinateLayout中最拉风的动画特效，主要是实现一种“折叠”的动画效果。我们在模仿个人中心的时候就是用到了这个功能：\n\n看一下个人中心的布局文件：\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <android.support.design.widget.AppBarLayout\n        android:id=\"@+id/appbar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"256dp\"\n        android:fitsSystemWindows=\"true\"\n        android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\">\n\n        <android.support.design.widget.CollapsingToolbarLayout\n            android:id=\"@+id/collapsing_toolbar\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            android:fitsSystemWindows=\"true\"\n            app:contentScrim=\"?attr/colorPrimary\"\n            app:expandedTitleMarginEnd=\"64dp\"\n            app:expandedTitleMarginStart=\"48dp\"\n            app:layout_scrollFlags=\"scroll|exitUntilCollapsed|snap\">\n\n            <RelativeLayout\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:background=\"@drawable/user_bg\"\n                app:layout_collapseMode=\"parallax\">\n\n                <de.hdodenhof.circleimageview.CircleImageView\n                    android:layout_width=\"68dp\"\n                    android:layout_height=\"68dp\"\n                    android:layout_centerInParent=\"true\"\n                    android:src=\"@drawable/profile\" />\n\n            </RelativeLayout>\n\n            <android.support.v7.widget.Toolbar\n                android:id=\"@+id/toolbar\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"?attr/actionBarSize\"\n                app:layout_collapseMode=\"pin\"\n                app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" />\n\n        </android.support.design.widget.CollapsingToolbarLayout>\n\n    </android.support.design.widget.AppBarLayout>\n\n    <android.support.v4.widget.NestedScrollView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        app:layout_behavior=\"@string/appbar_scrolling_view_behavior\">\n\n        <LinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"vertical\"\n            android:paddingTop=\"10dp\">\n\n            <ImageView\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:scaleType=\"fitStart\"\n                android:src=\"@drawable/fake\" />\n\n        </LinearLayout>\n\n    </android.support.v4.widget.NestedScrollView>\n\n    <android.support.design.widget.FloatingActionButton\n        android:id=\"@+id/btn\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"16dp\"\n        android:clickable=\"true\"\n        android:src=\"@drawable/ic_edit\"\n        app:layout_anchor=\"@id/appbar\"\n        app:layout_anchorGravity=\"bottom|right|end\" />\n\n</android.support.design.widget.CoordinatorLayout>\n```\n\n***\n\n* 首先，我们在AppBarLayout中嵌套一个CollapsingToolbarLayout，并指定其\n\n```\napp:layout_scrollFlags=\"scroll|exitUntilCollapsed|snap\"\n```\n这个属性前面介绍过了，这里三种属性结合就可实现滚动中“折叠视差”的效果了。\n\n* 接下来，我们又在CollapsingToolbarLayout放置了一个RelativeLayout。这个RelativeLayout有一个很重要的设置；\n\n```\napp:layout_collapseMode=\"parallax\"\n```\n这个layout_collapseMode就是用来设置整个RelativeLayout的折叠效果的，有两种取值，“pin”：固定模式，在折叠的时候最后固定在顶端；“parallax”：视差模式，在折叠的时候会有个视差折叠的效果。\n\n* 最后是Toolbar，可以看到Toolbar的collapseMode设置为pin，这样向上滑动时，当RelativeLayout的内容完全折叠后，Toolbar将显示在顶部；而向下滑动时，Toolbar将消失，而RelativeLayout的内容会动态的折叠展开，而且由于设置了snap，会有一种轻微的弹性效果。\n\n**这里需要注意，这个时候，我们需要将AppBarLayout的高度设置为固定值**\n\nCoordinatorLayout 还提供了一个 layout_anchor 的属性，连同 layout_anchorGravity 一起，可以用来放置与其他视图关联在一起的悬浮视图（如 FloatingActionButton）。\n\n这里如果我们将floatingActionButton设置为：\n\n```\nandroid:layout_gravity=\"bottom|right|end\"\n```\n\nFloatingActionButton将位于整个屏幕的右下角。\n\n### 使用细节###\n\n这里需要注意的是，使用AppBarLayout时，为了实现其滚动时的效果，在其下面必须有一个可滚动的View，并且需要为其设置app:layout_behavior属性。\n\n比如我们在结合结合CollapsingToolbarLayout使用时，\n在AppBarLayout的下面放置了一个NestedScrollView，并设置其app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"。\n\n而在其他页面，我们AppBarLayout的下面放置了ViewPager或者是FrameLayout都设置了相应的属性；具体可参考源码。\n\n### Behavior###\n\n上面我们提到了layout_behavior，这是个什么意思呢？\n\n这里就不得不说这个Behavior了，可以说Behavior是整个CoordinateLayout最核心的东西。还记得我们最开始的列子吗？FloatingActionButton会随着Snackbar的出现，自动的调节自己的位置，这是怎样的实现的呢？\n\n我们通过追踪查看 Snackbar 的 show() 这个方法，最终会在Snack的源码中找到如下实现：\n\n``` java\nfinal void showView() {\n        if (mView.getParent() == null) {\n            final ViewGroup.LayoutParams lp = mView.getLayoutParams();\n\n            if (lp instanceof CoordinatorLayout.LayoutParams) {\n                // If our LayoutParams are from a CoordinatorLayout, we'll setup our Behavior\n                final CoordinatorLayout.LayoutParams clp = (CoordinatorLayout.LayoutParams) lp;\n\n                final Behavior behavior = new Behavior();\n                behavior.setStartAlphaSwipeDistance(0.1f);\n                behavior.setEndAlphaSwipeDistance(0.6f);\n                behavior.setSwipeDirection(SwipeDismissBehavior.SWIPE_DIRECTION_START_TO_END);\n                behavior.setListener(new SwipeDismissBehavior.OnDismissListener() {\n                    @Override\n                    public void onDismiss(View view) {\n                        view.setVisibility(View.GONE);\n                        dispatchDismiss(Callback.DISMISS_EVENT_SWIPE);\n                    }\n\n                    @Override\n                    public void onDragStateChanged(int state) {\n                        switch (state) {\n                            case SwipeDismissBehavior.STATE_DRAGGING:\n                            case SwipeDismissBehavior.STATE_SETTLING:\n                                // If the view is being dragged or settling, cancel the timeout\n                                SnackbarManager.getInstance().cancelTimeout(mManagerCallback);\n                                break;\n                            case SwipeDismissBehavior.STATE_IDLE:\n                                // If the view has been released and is idle, restore the timeout\n                                SnackbarManager.getInstance().restoreTimeout(mManagerCallback);\n                                break;\n                        }\n                    }\n                });\n                clp.setBehavior(behavior);\n                // Also set the inset edge so that views can dodge the snackbar correctly\n                clp.insetEdge = Gravity.BOTTOM;\n            }\n\n            mTargetParent.addView(mView);\n        }\n\n        \n    ......\n        \n    }\n```\n\n***\n\n我们可以看到，当Snack执行show方法的时候，会生成一个Behavior对象，然后将这个对象set给CoordinateLayout，而CoordinateLayout会根据这个Behavior执行动作。这个方法下面省略的代码大体上就是一个Translation属性动画的实现，这里就不展开来说了。\n\n回到我们之前所说，我们需要为带有滚动属性的view设置layout_behavior这个属性，我们为其设置的值\n\n``` xml\napp:layout_behavior=\"@string/appbar_scrolling_view_behavior\"\n```\n\n```\n<string name=\"appbar_scrolling_view_behavior\" translatable=\"false\">android.support.design.widget.AppBarLayout$ScrollingViewBehavior</string>\n```\n***\n\n我们可以在AppBarLayout的源码中找到这个ScrollingViewBehavior，其最终也是继承自Behavior实现了特定的效果。\n\n现在或许你有疑问，这个神秘的Behavior到底是个什么鬼？\n\n#### Behavior 核心概念####\n\nBehavior 就是行为，他定义了View的行为。\n\nCoordinatorLayout的工作原理是搜索定义了CoordinatorLayout Behavior的子view，不管是通过在xml中使用app:layout_behavior标签还是通过在代码中对view类使用@DefaultBehavior修饰符来添加注解。当滚动发生的时候，CoordinatorLayout会尝试触发那些声明了依赖的子view。\n\nBehavior最基础的两个方法是：layoutDependsOn() 和onDependentViewChanged()；这两个方法的说明如下：\n\n``` java\n public boolean layoutDependsOn(CoordinatorLayout parent, T child, \n                                            View dependency) {\n    boolean result;\n    //返回false表示child不依赖dependency，ture表示依赖\n    return result;    \n}\n\n```\n\n``` java\n/**\n* 当dependency发生改变时（位置、宽高等），执行这个函数\n* 返回true表示child的位置或者是宽高要发生改变，否则就返回false\n*/\n@Override\npublic boolean onDependentViewChanged(CoordinatorLayout parent, T child, View dependency) {\n     //child要执行的具体动作\n        return true;\n}\n```\n***\n\n#### FloatingActionButton 的Behavior####\n\n我们用Android Studio查看FloatingActionButton的源码，会发现他包含了一个Behavior的注解：\n\n``` java\n@CoordinatorLayout.DefaultBehavior(FloatingActionButton.Behavior.class)\npublic class FloatingActionButton extends VisibilityAwareImageButton {\n.....\n}\n```\n***\n\n这里我们看一下FloatingActionButton的注解参数FloatingActionButton.Behavior.class 是怎样实现的。通过源码我们发现这个FloatingActionButton的Behavior继承自CoordinateLayout的Behavior，而且只实现了onDependentViewChanged方法，我们看一下：\n\n``` java\npublic static class Behavior extends CoordinatorLayout.Behavior<FloatingActionButton> {\n        private static final boolean AUTO_HIDE_DEFAULT = true;\n\n        private Rect mTmpRect;\n        private OnVisibilityChangedListener mInternalAutoHideListener;\n        private boolean mAutoHideEnabled;\n\n        public Behavior() {\n            super();\n            mAutoHideEnabled = AUTO_HIDE_DEFAULT;\n        }\n\n        public Behavior(Context context, AttributeSet attrs) {\n            super(context, attrs);\n            TypedArray a = context.obtainStyledAttributes(attrs,\n                    R.styleable.FloatingActionButton_Behavior_Layout);\n            mAutoHideEnabled = a.getBoolean(\n                    R.styleable.FloatingActionButton_Behavior_Layout_behavior_autoHide,\n                    AUTO_HIDE_DEFAULT);\n            a.recycle();\n        }\n\n        @Override\n        public boolean onDependentViewChanged(CoordinatorLayout parent, FloatingActionButton child,\n                View dependency) {\n            if (dependency instanceof AppBarLayout) {\n                // If we're depending on an AppBarLayout we will show/hide it automatically\n                // if the FAB is anchored to the AppBarLayout\n                updateFabVisibilityForAppBarLayout(parent, (AppBarLayout) dependency, child);\n            } else if (isBottomSheet(dependency)) {\n                updateFabVisibilityForBottomSheet(dependency, child);\n            }\n            return false;\n        }\n\n      \n    }\n```\n***\n可以看到他在onDependentViewChanged中直接判断了当前依赖的view。我们在模仿个人中心时，设置的FloatingActionButton的dependency就是AppBarLayout。而在这个方法中，他就会根据此执行特定的操作，也就是updateFabVisibilityForAppBarLayout 这个方法中的内容。\n\n#### 自定义Behavior####\n\n好了，说了这么多，下面我们说一下自定义Behavior。我们在模仿知乎底部用于切换Fragment的Tab时，便使用了一个自定义的Behavior。\n\n##### BottomViewBehavior #####\n``` java\npublic class BottomViewBehavior extends CoordinatorLayout.Behavior<View> {\n    public BottomViewBehavior(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    @Override\n    public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) {\n        return dependency instanceof AppBarLayout;\n    }\n\n    @Override\n    public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) {\n        float translationY = Math.abs(dependency.getTop());\n        child.setTranslationY(translationY);\n        return true;\n    }\n\n}\n```\n***\n\n这里我们的思路很简单，就是我们的View 要依赖于顶部的AppBarLayout，而用其距离屏幕的距离，作为底部（tab)相对于屏幕的距离，这样当顶部的AppBarLayout 滑动出屏幕时，底部也将做相应的位移，当然这里底部tab 的高度是需要做限制的，不能大于顶部AppBarLayout的高度。\n\n``` xml\n<LinearLayout \n        android:id=\"@+id/bottom\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"48dp\"\n        android:layout_gravity=\"bottom\"\n        android:background=\"@color/white\"\n        android:orientation=\"horizontal\"  \n      app:layout_behavior=\"home.smart.fly.zhihuindex.behavior.BottomViewBehavior\">\n\n        <RadioGroup\n            android:id=\"@+id/tabs_rg\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            android:orientation=\"horizontal\"\n            android:paddingLeft=\"5dp\"\n            android:paddingRight=\"5dp\">\n\n            <RadioButton\n                android:id=\"@+id/home_tab\"\n                android:layout_width=\"0dp\"\n                android:layout_height=\"match_parent\"\n                android:layout_weight=\"1\"\n                android:background=\"#00000000\"\n                android:button=\"@null\"\n                android:checked=\"true\"\n                android:drawableTop=\"@drawable/home_sel\"\n                android:gravity=\"center|bottom\"\n                android:paddingTop=\"5dp\" />\n\n            <RadioButton\n                android:id=\"@+id/explore_tab\"\n                android:layout_width=\"0dp\"\n                android:layout_height=\"match_parent\"\n                android:layout_weight=\"1\"\n                android:background=\"#00000000\"\n                android:button=\"@null\"\n                android:drawableTop=\"@drawable/explore_sel\"\n                android:gravity=\"center|bottom\"\n                android:paddingTop=\"5dp\" />\n\n            <RadioButton\n                android:id=\"@+id/notify_tab\"\n                android:layout_width=\"0dp\"\n                android:layout_height=\"match_parent\"\n                android:layout_weight=\"1\"\n                android:background=\"#00000000\"\n                android:button=\"@null\"\n                android:drawableTop=\"@drawable/notify_sel\"\n                android:gravity=\"center|bottom\"\n                android:paddingTop=\"5dp\" />\n\n            <RadioButton\n                android:id=\"@+id/user_tab\"\n                android:layout_width=\"0dp\"\n                android:layout_height=\"match_parent\"\n                android:layout_weight=\"1\"\n                android:background=\"#00000000\"\n                android:button=\"@null\"\n                android:drawableTop=\"@drawable/user_sel\"\n                android:gravity=\"center|bottom\"\n                android:paddingTop=\"5dp\" />\n        </RadioGroup>\n\n    </LinearLayout>\n```\n***\n\n我们将自定义的Behavior设置为这个bottom的app:layout_behavior就可以实现类似于知乎首页的那种效果了。\n\n##### FabBehavior #####\n\n这里我们用到的FloatingActionButton也可以自定义Behavior。\n\n```\npublic class FabBehavior extends CoordinatorLayout.Behavior<View> {\n    private static final Interpolator INTERPOLATOR = new FastOutSlowInInterpolator();\n    /**\n     * 控件距离coordinatorLayout底部距离\n     */\n    private float viewDistance;\n    private boolean aninmating;\n\n    public FabBehavior(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    @Override\n    public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) {\n\n        if(child.getVisibility() == View.VISIBLE&& viewDistance ==0){\n            //获取控件距离父布局（coordinatorLayout）底部距离\n            viewDistance =coordinatorLayout.getHeight()-child.getY();\n        }\n\n        return (nestedScrollAxes & ViewCompat.SCROLL_AXIS_VERTICAL) != 0;//判断是否竖直滚动\n    }\n\n    @Override\n    public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) {\n        //dy大于0是向上滚动 小于0是向下滚动\n\n        if (dy >=0&&!aninmating &&child.getVisibility()==View.VISIBLE) {\n            hide(child);\n        } else if (dy <0&&!aninmating &&child.getVisibility()==View.GONE) {\n            show(child);\n        }\n    }\n\n    private void hide(final View view) {\n        ViewPropertyAnimator animator = view.animate().translationY(viewDistance).setInterpolator(INTERPOLATOR).setDuration(200);\n\n        animator.setListener(new Animator.AnimatorListener() {\n            @Override\n            public void onAnimationStart(Animator animator) {\n                aninmating =true;\n            }\n\n            @Override\n            public void onAnimationEnd(Animator animator) {\n                view.setVisibility(View.GONE);\n                aninmating =false;\n            }\n\n            @Override\n            public void onAnimationCancel(Animator animator) {\n                show(view);\n            }\n\n            @Override\n            public void onAnimationRepeat(Animator animator) {\n            }\n        });\n        animator.start();\n    }\n\n    private void show(final View view) {\n        ViewPropertyAnimator animator = view.animate().translationY(0).setInterpolator(INTERPOLATOR).setDuration(200);\n        animator.setListener(new Animator.AnimatorListener() {\n            @Override\n            public void onAnimationStart(Animator animator) {\n                view.setVisibility(View.VISIBLE);\n                aninmating =true;\n            }\n\n            @Override\n            public void onAnimationEnd(Animator animator) {\n                aninmating =false;\n            }\n\n            @Override\n            public void onAnimationCancel(Animator animator) {\n                hide(view);\n            }\n\n            @Override\n            public void onAnimationRepeat(Animator animator) {\n            }\n        });\n        animator.start();\n    }\n}\n```\n***\n这里我们并没有去实现layoutDependsOn() 和onDependentViewChanged()这两个方法，前面我们看FloatingActionButton源码的时候知道他已经实现了onDependentViewChanged，我们这里我们从自身需求出发，就其滑动时的特性，做了一个滑动屏幕时FloatingActionButton快速从底部弹出或隐藏的Behavior。结合注释，代码很容易理解。\n\n好了，这就是所有关于CoordinateLayout的东西了，可以看到Behavior是这个控件的核心，也是最难理解的东西。自定义Behavior可以让我们的滑动动画有无限的可能。\n\n### 总结###\n\n关于这个模仿知乎首页的实现，最初真的只是想研究一下“首页”是怎么实现的。结果随着Demo的展开，加上轻微强迫症的作祟，便成了现在这个样子。\n\n到这里，不得不说一下，个人感觉，真正的知乎首页应该是没有使用CoordinateLayout；因为按现在这种Activity+n*Fragment 的套路，使用CoordinateLayout完全是给自己添乱，因为CoordinateLayout是滑动特性是无法嵌套使用的（或者说很复杂，我没发现），当我在最外层的Activity中使用了CoordinateLayout后，内部的Fragment中再次使用CoordinateLayout时，就会发生意想不到的各种bug，所以你会发现我们模拟的个人中心是有问题的，这里就是嵌套CoordinateLayout后外部的CoordinateLayout失效了，导致底部的Behavior也失效。\n\n不过在整个模仿的过程，也算是对CoordinateLayout的一次深入了解吧，顺便也对SwipeRefreshLayout的内容和Tween Animation的使用做了一次巩固。首页RecycleView item中仿照Toolbar的弹出菜单，真的是耗费了不少时间。\n\n***源码地址***\n\n好了，按照惯例再次给出[github](https://github.com/REBOOTERS/ZhiHuIndex)地址，欢迎star&fork。\n\n\n****\n\n## 后话##\n\n之前学习CoordinateLayout模仿知乎首页的效果，断断续续的大概用了一周时间；现在回过头来再看，其实关于CoordinateLayout的使用很简单，甚至有些无聊；因为app:layout_scrollFlags和 app:layout_collapseMode 这两个属性的可选值都也就那么几个；这其实是一种局限性，大家在应用中使用这个东西，产生的滑动视差效果几乎就是相似的，唯一就是颜色及主题风格的差异；这很容易让用户产生审美疲劳；唯一变化的就是Behavior，这是我们可以自定义的东西，因此这也是最难掌握的东西。知乎首页以及掘金首页的效果比我在这里实现的要更加柔和舒服，至于其是否使用了CoordinateLayout就不得而知了。\n\n\n\n\n\n\n\n\n","tags":["Android 动画"],"categories":["Android 进阶"]},{"title":"我们真的需要使用RxJava+Retrofit吗？","url":"%2F2016%2F12%2F12%2F%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8RxJava%2BRetrofit%E5%90%97%2F","content":"\n\n\n## 前言 ##\n\n可以说RxJava+Retrofit是整个2016年Android 开发圈内最受关注的的组合。各大Android论坛上有大量以RxJava+Retrofit+xxx 为标题的文章，此类文章也备受大家的关注。这个组合仿佛已经成为了Android开发的必备组件，项目里没使用这个组合好像自己都out了似的。\n\n平心而论，RxJava和Retrofit 相较于以往的各种框架（如 AsyncHttpClient，Volley等 )学习和使用起来会有一些难度；RxJava 强大而又庞大的操作符，Retrofit采用注解风格定义接口，都会让初学者花费不少功夫，绕不少圈子，踩大量的坑。既然这样，那么就会有人怀疑，我们真的需要学习RxJava和Retrofit吗？\n\n任意一款需要联网的APP，最典型的套路就是请求后端数据，解析数据进行UI更新；响应用户操作，再次请求数据，更新UI。这里我们就从最基础的网络请求出发，带着疑问，逐步了解一下Retrofit的前生今世，看一看RxJava和Retrofit的价值所在。\n\n<!--more-->\n\n## Android Http ##\n\n### 最基础的实现方式 ###\n\n初学Android开发时，还在上大学，那会儿还不知有AsyncHttpClient，Volley，OKHttp 这么方便的框架存在于这个世界上；一个简单的网络请求通常要写一大段代码。\n\n#### 使用HttpURLConnection实现网络请求#### \n\n\n``` java\nclass MyTask extends AsyncTask<String, Void, String> {\n\n        @Override\n        protected String doInBackground(String... params) {\n            InputStream mInputStream = null;\n            HttpURLConnection connection = getHttpUrlConnection(params[0]);\n            String result = \"\";\n            try {\n                connection.connect();\n                int statusCode = connection.getResponseCode();\n                String response = connection.getResponseMessage();\n                mInputStream = connection.getInputStream();\n                InputStreamReader inputStreamReader = new InputStreamReader(mInputStream);\n                BufferedReader reader = new BufferedReader(inputStreamReader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    sb.append(line + \"\\n\");\n                }\n\n                result = \"StatusCode: \" + statusCode + \"\\n\"\n                        + \"Response\" + response + \"\\n\"\n                        + sb.toString();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return result;\n        }\n\n        @Override\n        protected void onPostExecute(String s) {\n            super.onPostExecute(s);\n            tv.setText(s);\n        }\n    }\n\n    private HttpURLConnection getHttpUrlConnection(String url) {\n        HttpURLConnection connection = null;\n        try {\n            URL mUrl = new URL(url);\n            connection = (HttpURLConnection) mUrl.openConnection();\n            connection.setConnectTimeout(20000);\n            connection.setReadTimeout(40000);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json\");\n            connection.setRequestProperty(\"Accept\", \"application/json\");\n            connection.setRequestProperty(\"Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Length\", \"0\");\n\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return connection;\n    }\n```\n\n```java\nnew MyTask().execute(BASE_URL);\n```\n\n这段代码的逻辑很简单，就是将网络请求的结果显示在一个TextView上。很大一部分的内容都是在执行HttpURLConnection 相关的配置及初始化工作。\n\n记得第一次通过网络请求把数据显示的Android模拟器（那时候还是穷学生，买不起Android手机）的屏幕上时，虽然只是一大堆别人看不懂的json字符串，但是感觉自己就要上天了，现在想想真是。。。。。\n\n即便是这么长的一段代码，还没有包含网络请求异常的内容，如果加上网络请求失败处理的逻辑，将使得整个代码结构更加臃肿庞大。\n\n### 网络请求框架的涌现###\n\n一款联网的APP至少会有十几次的网络请求，更多的就无法估计了。因此，每一次的网络请求不可能像上面那样写。所以，我们需要封装，将一些固定的操作统一处理；当然已经有许多大神比我早想到了这个问题，便出现了许多对网络请求进行封装的库。\n\n- AsyncHttpClient（底层基于HttpClient）\n- afinal（FinalHttp，同样是基于HttpClient封装）\n- xUtils (基于afinal)\n- Volley（Google官方出品）\n- okHttp\n- NoHttp (个人开发)\n\n这里列出的几个库当中，个人使用AsyncHttpClient较多，AsyncHttpClient 的确非常好用，但是后来伴随着Android sdk 23 中HttpClient的废弃也逐渐被遗忘。\nafinal和xUtils 都没有在实际项目中没用过，不做评价。\n\nVolley作为Google官方在2013年I/O 大会上推出的库，相较于AsyncHttpClient 更强大。\n\n下面简单列举一个使用Volley进行get请求的demo。\n\n#### Volley 简单使用####\n\n添加依赖：\n\n```\ncompile 'com.mcxiaoke.volley:library:1.0.19'\n```\n\n``` java\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mContext = this;\n        queue = Volley.newRequestQueue(mContext);\n        setContentView(R.layout.activity_http_volley_demo);\n        tv = (TextView) findViewById(R.id.editText);\n\n        final StringRequest request = new StringRequest(Request.Method.GET, BASE_URL,\n                new ResponseSuccessListener(), new ResponseFailListener());\n        findViewById(R.id.volley).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                queue.add(request);\n            }\n        });\n\n    }\n\n    private class ResponseSuccessListener implements com.android.volley.Response.Listener<String> {\n\n        @Override\n        public void onResponse(String response) {\n            tv.setText(response);\n        }\n    }\n\n    private class ResponseFailListener implements Response.ErrorListener {\n\n        @Override\n        public void onErrorResponse(VolleyError error) {\n            Toast.makeText(mContext, error.toString(), Toast.LENGTH_SHORT).show();\n        }\n    }\n```\n\n\n\n这段代码和上面的功能一样，都是将网络请求的结果显示在TextView。但是通过Volley对http请求进行一次封装后，我们不再关注网络请求的具体细节，而是将重点放在了对请求结果的处理上；网络请求无论成功还是失败，我们都可以很多好的应对。\n\n而且在Volley中，异步网络请求的回调方法已然处于UI线程中，这样我们就可以直接在回调方法中进行UI更新了。\n\n可以说，使用Volley已经可以非常方便的处理Android 网络请求的相关内容了。既然如此，为什么还会有OKHttp和Retrofit的出现呢?他们的优势又在哪里呢？\n\n#### OKHttp 简单介绍####\n\nokHttp 是由square 推出的一个网络请求库，包括Retrofit也是由其开发，这里为square点个赞。\n\n使用之前加入依赖\n\n```\n    compile 'com.squareup.okhttp3:okhttp:3.4.1'\n    compile 'com.squareup.okio:okio:1.11.0'\n```\n\n**okHttp 网络请求实现**\n\n\n\n```\nfindViewById(R.id.get).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                tv.setText(\"\");\n                loading.setVisibility(View.VISIBLE);\n                client = new OkHttpClient();\n                Request.Builder builder = new Request.Builder()\n                        .url(BASE_URL)\n                        .method(\"GET\", null);\n\n                request = builder.build();\n                Call mCall = client.newCall(request);\n                mCall.enqueue(new MyCallback());\n            }\n        });\n\nprivate class MyCallback implements Callback {\n\n        @Override\n        public void onFailure(Call call, IOException e) {\n            Message msg = new Message();\n            msg.what = 100;\n            msg.obj = e;\n            handler.sendMessage(msg);\n        }\n\n        @Override\n        public void onResponse(Call call, Response response) throws IOException {\n            Message msg = new Message();\n            msg.what = 200;\n            msg.obj = response.body().string();\n            handler.sendMessage(msg);\n        }\n    }\n\nclass MyHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n            loading.setVisibility(View.GONE);\n            switch (msg.what) {\n                case 100:\n                    Object e = msg.obj;\n                    Toast.makeText(mContext, e.toString(), Toast.LENGTH_SHORT).show();\n                    break;\n                case 200:\n                    String response = (String) msg.obj;\n                    tv.setText(response);\n                    break;\n                case 300:\n                    int percent = msg.arg1;\n                    Log.e(\"llll\", \"the percent is \" + percent);\n                    if (percent < 100) {\n                        progressDialog.setProgress(percent);\n                    } else {\n                        progressDialog.dismiss();\n                        Glide.with(mContext).load(FILE_PATH).into(imageView);\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n```\n\n\n**这里必须了解的是，okHttp的回调方法，并不处于UI 线程中，对网络请求结果如果涉及UI 线程的操作，需要使用Handler**。这么看来，okHttp 貌似反而不如Volley了。其实不然，okhttp的封装套路和Volley，AsyncHttp不是一个级别的，不能和后两者作比较，okhttp 和HttpClient、HttpUriConneciton 才是一个级别的产物，相较于这两者，okhttp显然强大了许多。\n\n所以，OKHttp不仅仅可以用于Android开发，Java开发也是OK的。\n\n## Retrofit ##\n\n> A type-safe HTTP client for Android and Java\n> \n> 一个针对Android和Java类型安全的http客户端\n\n上面这句话，就是Squire对Retrofit的说明，言简意赅。Retrofit其实是对okhttp 做了进一步的封装，有了okhttp 的基础，使用Retrofit会很容易。\n\n下面就来看看，使用Retrofit做网络请求又是一种怎样的体验。\n\n这里为了方便我们使用\n\n>https://api.github.com/\n\n作为网络请求的接口基地址\n\n使用之前加入依赖：\n\n``` \ncompile 'com.squareup.retrofit2:retrofit:2.1.0'\n\n```\n\n**定义接口**\n\n``` java\npublic interface GithubService {\n\n    @GET(\"users/{user}\")\n    Call<ResponseBody> getUserString(@Path(\"user\") String user);\n\n}\n```\n\n这里我们使用http中的get 方法获取users这个接口下，当前user的具体信息，参数为当前user名。返回内容为Http请求的ResponseBody。\n\n**Retrofit 返回ResponseBody**\n\n```java\nprivate void SimpleRetrofit() {\n        OkHttpClient.Builder httpClient = new OkHttpClient.Builder();\n        Retrofit.Builder builder = new Retrofit.Builder()\n                .baseUrl(BASE_URL);\n        Retrofit retrofit = builder.client(httpClient.build()).build();\n        GithubService simpleService = retrofit.create(GithubService.class);\n        Call<ResponseBody> call = simpleService.getUserString(name);\n        call.enqueue(new Callback<ResponseBody>() {\n            @Override\n            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {\n                loading.dismiss();\n                try {\n                    String result = response.body().string();\n                    Gson gson = new Gson();\n                    GithubUserBean bean = gson.fromJson(result, GithubUserBean.class);\n                    setUserView(bean);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            @Override\n            public void onFailure(Call<ResponseBody> call, Throwable t) {\n                loading.dismiss();\n            }\n        });\n    }\n\nprivate void setUserView(GithubUserBean user) {\n        if (user != null) {\n            viewShell.removeAllViews();\n            View view = LayoutInflater.from(mContext).inflate(R.layout.user_item_layout, null);\n            TextView title = (TextView) view.findViewById(R.id.title);\n            TextView id = (TextView) view.findViewById(R.id.userId);\n            TextView creteaTime = (TextView) view.findViewById(R.id.createTime);\n            TextView updateTime = (TextView) view.findViewById(R.id.updateTime);\n            TextView bio = (TextView) view.findViewById(R.id.bio);\n            ImageView avatar = (ImageView) view.findViewById(R.id.avatar);\n\n            title.setText(\"Name: \" + user.getLogin());\n            bio.setText(\"Bio: \" + user.getBio());\n            id.setText(\"Id: \" + String.valueOf(user.getId()));\n            creteaTime.setText(\"createTime: \" + user.getCreated_at());\n            updateTime.setText(\"updateTime: \" + user.getUpdated_at());\n            Glide.with(mContext).load(user.getAvatar_url()).into(avatar);\n\n            viewShell.addView(view);\n        } else {\n            Toast.makeText(mContext, \"result is null\", Toast.LENGTH_SHORT).show();\n        }\n    }\n```\n\n**GitHubUserBean** 为网络请求结果json数据所对应的实体类。\n\n通过这段代码，我们在最终的回调方法里可以友好的处理请求结果，失败时onFailure方法执行。成功时，onResponse方法执行，我们在这里用Gson解析返回的数据，并进行UI更新操作（setUserView(bean))，\n\n这里我们这样做有些啰嗦，Gson转换的方式都是类似，唯一不同的只是每次网络请求结果对应的实体类；因此我们可以借助强大的Retrofit帮助我们完成Gson转换的步骤。当然，如果在你所在的开发环境中，接口返回的并不是json格式的数据，也没有问题的。\n\n\n![convert](https://lc-mhke0kuv.cn-n1.lcfile.com/12c4ecd081399a08d6ca.png)\n\n上图是Retrofit官网对可转换类型给出的介绍。有这么多种，当然了如果你们家服务器返回的数据格式比较神奇，你也可以自定义转换类。\n\n好了，言归正传，这里还是以Json 格式数据为例。\n\n添加依赖：\n\n```\ncompile 'com.squareup.retrofit2:converter-gson:2.1.0'\n```\n\n**注意这里converter-gson 的版本号，要和之前Retrofit的版本号保持一致。**\n\n我们重新定义接口：\n\n``` java\npublic interface GithubService {\n    @GET(\"users/{user}\")\n    Call<GithubUserBean> getUser(@Path(\"user\") String user);\n\n}\n```\n这里我们用GithubUserBean取代ResponseBody，直接将其作为返回类型。\n\n**Retrofit 返回对象**\n\n``` java\nprivate void LazyRetrofit() {\n        OkHttpClient.Builder httpClient = new OkHttpClient.Builder();\n        Retrofit.Builder builder = new Retrofit.Builder()\n                .baseUrl(BASE_URL)\n                .addConverterFactory(GsonConverterFactory.create());\n        Retrofit retrofit = builder.client(httpClient.build()).build();\n        GithubService service = retrofit.create(GithubService.class);\n        Call<GithubUserBean> call = service.getUser(name);\n        call.enqueue(new Callback<GithubUserBean>() {\n            @Override\n            public void onResponse(Call<GithubUserBean> call, Response<GithubUserBean> response) {\n                GithubUserBean bean = response.body();\n                setUserView(bean);\n                loading.dismiss();\n            }\n\n            @Override\n            public void onFailure(Call<GithubUserBean> call, Throwable t) {\n                loading.dismiss();\n            }\n        });\n    }\n```\n\n这里的实现方式和上面基本相似，只是多了一行\n\n```java\n.addConverterFactory(GsonConverterFactory.create());\n```\n\n这样，我们在onResponse中获得就是对象，不再需要做额外的转换工作，可以直接使用。\n\n**Retrofit 简单封装**\n\n这里我们可以看到，Retrofit使用有着一定的套路，所以我们可以将Retrofit初始化相关得内容做一次简单的封装。\n\n``` java\npublic class GenServiceUtil {\n    private static final String BASE_URL = \"https://api.github.com/\";\n\n    private static OkHttpClient.Builder httpClient = new OkHttpClient.Builder();\n\n    private static Retrofit.Builder builder = new Retrofit.Builder()\n            .baseUrl(BASE_URL)\n            .addConverterFactory(GsonConverterFactory.create());\n\n    private static Retrofit retrofit = builder.client(httpClient.build()).build();\n\n    public static <S> S createService(Class<S> serviceClass) {\n        return retrofit.create(serviceClass);\n    }\n\n}\n\nprivate void EasyRetrofit() {\n        GithubService service = GenServiceUtil.createService(GithubService.class);\n        Call<GithubUserBean> call = service.getUser(name);\n        call.enqueue(new Callback<GithubUserBean>() {\n            @Override\n            public void onResponse(Call<GithubUserBean> call, Response<GithubUserBean> response) {\n                GithubUserBean bean = response.body();\n                loading.dismiss();\n                setUserView(bean);\n            }\n\n            @Override\n            public void onFailure(Call<GithubUserBean> call, Throwable t) {\n                loading.dismiss();\n            }\n        });\n    }\n\n```\n\n我们只需传入定义好的借口，会使代码简介许多。看到这里可以发现，Retrofit的确很厉害，那为什么又要将他和RxJava结合在一起呢？下面我们就来看看。\n\n## RxJava+Retrofit ##\n\n关于什么是RxJava，这里不再赘述，不了解的看以看看[这里](http://www.jianshu.com/p/ce9574619697)。这里我们就看看将RxJava 和我们之前的内容结合在一起会有怎样的效果。\n\n首先，加入依赖\n\n```\n    compile 'io.reactivex:rxjava:1.1.7'\n    compile 'io.reactivex:rxandroid:1.2.1'\n```\n\n### RxJava+Retrofit 实现###\n\n``` java\nprivate void RxRetrofit() {\n        GithubService service = GenServiceUtil.createService(GithubService.class);\n        final Call<GithubUserBean> call = service.getUser(name);\n        final Observable myObserable = Observable.create(new Observable.OnSubscribe<GithubUserBean>() {\n            @Override\n            public void call(Subscriber<? super GithubUserBean> subscriber) {\n                Response<GithubUserBean> bean = null;\n                try {\n                    bean = call.execute();\n                    subscriber.onNext(bean.body());\n\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    subscriber.onError(e);\n                }\n\n                subscriber.onCompleted();\n            }\n        });\n\n        myObserable\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .map(new Func1<GithubUserBean, GithubUserBean>() {\n                    @Override\n                    public GithubUserBean call(GithubUserBean o) {\n                        if (TextUtils.isEmpty(o.getBio())) {\n                            o.setBio(\"nothing !\");\n                        }\n                        return o;\n                    }\n                })\n                .subscribe(new Subscriber<GithubUserBean>() {\n                    @Override\n                    public void onCompleted() {\n                        loading.dismiss();\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        loading.dismiss();\n                    }\n\n                    @Override\n                    public void onNext(GithubUserBean o) {\n                        setUserView(o);\n                    }\n                });\n\n    }\n```\n\n这里有几点需要注意：\n\n- RxJava 本身最大的特定就是异步，因此这里我们Retrofit执行网络请求的时候，使用了execute（同步请求），而不再是enqueue。\n- RxJava 可以使用subscribeOn和observeOn完美处理Observeable和Subscribe的执行线程问题。\n- 这里使用RxJava中map操作符，对返回内容中的为null或“” 的对象做了简单的处理。\n\n我们引入RxJava实现了同样的功能，却使得代码量增加了很多。不禁要问，RxJava的价值到底在哪里呢？\n\n### RxJava + Retrofit 到底好在哪里 ###\n\n好了，为了说明为题，我们添加一个接口\n\n``` java\npublic interface GithubService {\n\n    @GET(\"users/{user}\")\n    Call<GithubUserBean> getUser(@Path(\"user\") String user);\n\n    @GET(\"users/{user}/followers\")Observable<List<UserFollowerBean>> followers(@Path(\"user\") String usr);\n\n}\n```\n当然这里依旧需要添加依赖：\n\n```\ncompile 'com.squareup.retrofit2:adapter-rxjava:2.1.0'\n````\n同时在Service的封装方法中添加\n\n```\n.addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n```\n\n这样，RxJava就和Retrofit完美的关联在了一起。\n\n我们在接口中，定义followers()方法直接返回了Observable，因为Observable是RxJava的源头，而且Retrofit可以很好的支持RxJava，这样就非常方便了。\n\n\n```java\n    private void RxRetrofitList() {\n        GithubService service = GenServiceUtil.createService(GithubService.class);\n        Observable<List<UserFollowerBean>> myObserve = service.followers(name);\n        myObserve\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Subscriber<List<UserFollowerBean>>() {\n                    @Override\n                    public void onCompleted() {\n                        loading.dismiss();\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        loading.dismiss();\n                        e.printStackTrace();\n                    }\n\n                    @Override\n                    public void onNext(List<UserFollowerBean> userFollowerBeen) {\n                        setFollowersView(userFollowerBeen);\n                    }\n                });\n\n    }\n```\n\n\n\n在接口中返回的内容就是Observable，因此不用再像之前一样单独定义Observable；在onNext 方法中，接收到返回的对象，更新UI。 这里如果我们不使用RxJava,单独使用Retrofit实现这个过程是没有任何问题的； RxJava看似没有价值；但是假设现在出现如下之一的情景\n\n- 需要对返回的userFollowerBeen 这个list 进行按用户名从小到大的排序\n- 需要对返回的userFollowerBeen 这个list 进行按用户ID从小到大的排序\n- 如果返回的userFollowerBeen 这个list 中，某一项的头像地址为空，则不显示该项\n\n.....\n\n这种情景在实际开发中太常见了，试想如果没有RxJava；那么每一次需求的变更都意味着我们需要去修改setFollowersView这个方法，需求一旦变更，就去修改这个方法，这样会不可避免的产生各种bug。那有没有办法不去修改这个方法呢？这个时候，就需要强大的RxJava了。\n\n这里我们就看看如何在不修改setFollowersView的前提下，实现对用户名从小到大的排序：\n\n```java\n    private void RxRetrofitList() {\n        GithubService service = GenServiceUtil.createService(GithubService.class);\n        Observable<List<UserFollowerBean>> myObserve = service.followers(name);\n        myObserve\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .map(new Func1<List<UserFollowerBean>, List<UserFollowerBean>>() {\n                    @Override\n                    public List<UserFollowerBean> call(List<UserFollowerBean> userFollowerBeen) {\n                        for (UserFollowerBean bean : userFollowerBeen) {\n                            String name = \"\";\n                            name = bean.getLogin().substring(0, 1).toUpperCase() + bean.getLogin().substring(1, bean.getLogin().length());\n                            bean.setLogin(name);\n                        }\n                        return userFollowerBeen;\n                    }\n                })\n                .map(new Func1<List<UserFollowerBean>, List<UserFollowerBean>>() {\n                    @Override\n                    public List<UserFollowerBean> call(List<UserFollowerBean> userFollowerBean) {\n                        Collections.sort(userFollowerBean, new Comparator<UserFollowerBean>() {\n                            @Override\n                            public int compare(UserFollowerBean o1, UserFollowerBean o2) {\n                                return o1.getLogin().compareTo(o2.getLogin());\n                            }\n                        });\n                        return userFollowerBean;\n                    }\n                })\n                .subscribe(new Subscriber<List<UserFollowerBean>>() {\n                    @Override\n                    public void onCompleted() {\n                        loading.dismiss();\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        loading.dismiss();\n                        e.printStackTrace();\n                    }\n\n                    @Override\n                    public void onNext(List<UserFollowerBean> userFollowerBeen) {\n                        setFollowersView(userFollowerBeen);\n                    }\n                });\n\n    }\n```\n\n*RxJava 链式风格的代码*\n\n**在代码中我们使用RxJava的map 操作符，对返回数据做了两次处理，首先将所有用户名的首字母转换为大写字母；然后对整个list按照用户名从小到大排序。因为用户名中同时包含以大小写字母打头的内容，所以为了方便，我们进行了一次转换大写的操作。**\n\n\n同样是随着需求变更，修改代码；但是你会发现，使用RxJava的方式，会降低出现bug的概率，而且就算是不同的人去改，也会比较方便维护。\n\n看到了吧，这就是RxJava的优点，当然这个例子也只是冰山一角。这里提到的map操作符只是RxJava庞大操作符集合中的一员，更特别的是，RxJava的操作符还是可以自定义的，这样让我们的代码有了无限的可能；RxJava的存在不仅仅在于网络请求，可以用在别的方面；RxJava其实是体现了一种思路，所有对数据的操作都在流上完成，将最终的结果返回给观察者。**同时，如果返回的followers 列表有任何异常，RxJava的onError 方法会执行，这就方便我们去处理异常数据了。**\n\n## 总结##\n\n通篇通过对Android 网络请求各种实现的总结，可以看到 相对于Volley，AsyncHttpClient 等库，RxJava+Retrofit 的优势并非特别显著；在执行效率及功能上并无大的亮点；对Volley进行良好的封装同样可以实现类似Retrofit自动转Gson的功能；RxJava+Retrofit 结合会让我们写代码的方式更加有条理，虽然代码量会增多，但逻辑的清晰才是最重要的不是吗？所以，RxJava+Retrofit 组合不失为一种好的选择。\n\n所以，赶紧拥抱RxJava+Retrofit吧！\n\n***\n\n文中所有源码地址[github](https://github.com/REBOOTERS/My-MVP)\n\n","tags":["RxJava，Retrofit"],"categories":["Android 进阶，Android 三方框架"]},{"title":"Android 动画总结","url":"%2F2016%2F10%2F19%2FAndroid%20%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93%2F","content":"\n\n在日常的Android开发中，经常会使用到动画，这里就对Android开发中的动画做一下总结。\n\n## Android 动画分类\n\n总的来说，Android动画可以分为两类，最初的**传统动画**和Android3.0 之后出现的**属性动画**；\n传统动画又包括 帧动画（Frame Animation）和补间动画（Tweened Animation）。\n\n\n## 传统动画\n### 帧动画\n\n帧动画是最容易实现的一种动画，这种动画更多的依赖于完善的UI资源，他的原理就是将一张张单独的图片连贯的进行播放，\n从而在视觉上产生一种动画的效果；有点类似于某些软件制作gif动画的方式。\n\n\n\n![frame.gif](http://upload-images.jianshu.io/upload_images/1115031-b52487cb6b97f911.gif?imageMogr2/auto-orient/strip)\n\n如上图中的京东加载动画，代码要做的事情就是把一幅幅的图片按顺序显示，造成动画的视觉效果。\n\n<!--more-->\n\n**京东动画实现**\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item\n        android:drawable=\"@drawable/a_0\"\n        android:duration=\"100\" />\n    <item\n        android:drawable=\"@drawable/a_1\"\n        android:duration=\"100\" />\n    <item\n        android:drawable=\"@drawable/a_2\"\n        android:duration=\"100\" />\n</animation-list>\n```\n```\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_frame_animation);\n        ImageView animationImg1 = (ImageView) findViewById(R.id.animation1);\n        animationImg1.setImageResource(R.drawable.frame_anim1);\n        AnimationDrawable animationDrawable1 = (AnimationDrawable) animationImg1.getDrawable();\n        animationDrawable1.start();\n    }\n```\n*可以说，图片资源决定了这种方式可以实现怎样的动画*\n\n*在有些代码中，我们还会看到android：oneshot=\"false\" ，这个oneshot 的含义就是动画执行一次（true）还是循环执行多次。*\n\n这里其他几个动画实现方式都是一样，无非就是图片资源的差异。\n\n### 补间动画\n\n补间动画又可以分为四种形式，分别是 **alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）**。\n补间动画的实现，一般会采用xml 文件的形式；代码会更容易书写和阅读，同时也更容易复用。\n\n#### XML 实现\n\n首先，在res/anim/ 文件夹下定义如下的动画实现方式\n\n**alpha_anim.xml 动画实现**\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"1000\"\n    android:fromAlpha=\"1.0\"\n    android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"\n    android:toAlpha=\"0.0\" />\n```\n**scale.xml 动画实现**\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<scale xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"1000\"\n    android:fromXScale=\"0.0\"\n    android:fromYScale=\"0.0\"\n    android:pivotX=\"50%\"\n    android:pivotY=\"50%\"\n    android:toXScale=\"1.0\"\n    android:toYScale=\"1.0\"/>\n```\n然后，在Activity中 \n\n```\nAnimation animation = AnimationUtils.loadAnimation(mContext, R.anim.alpha_anim);\nimg = (ImageView) findViewById(R.id.img);\nimg.startAnimation(animation);\n```\n这样就可以实现ImageView alpha 透明变化的动画效果。\n\n也可以使用set 标签将多个动画组合（代码源自Android SDK API）\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:interpolator=\"@[package:]anim/interpolator_resource\"\n    android:shareInterpolator=[\"true\" | \"false\"] >\n    <alpha\n        android:fromAlpha=\"float\"\n        android:toAlpha=\"float\" />\n    <scale\n        android:fromXScale=\"float\"\n        android:toXScale=\"float\"\n        android:fromYScale=\"float\"\n        android:toYScale=\"float\"\n        android:pivotX=\"float\"\n        android:pivotY=\"float\" />\n    <translate\n        android:fromXDelta=\"float\"\n        android:toXDelta=\"float\"\n        android:fromYDelta=\"float\"\n        android:toYDelta=\"float\" />\n    <rotate\n        android:fromDegrees=\"float\"\n        android:toDegrees=\"float\"\n        android:pivotX=\"float\"\n        android:pivotY=\"float\" />\n    <set>\n        ...\n    </set>\n</set>\n```\n可以看到组合动画是可以嵌套使用的。\n\n各个动画属性的含义结合动画自身的特点应该很好理解，就不一一阐述了；这里主要说一下**interpolator** 和 **pivot**。\n\n>Interpolator 主要作用是可以控制动画的变化速率 ，就是动画进行的快慢节奏。\n\nAndroid 系统已经为我们提供了一些Interpolator ，比如 accelerate_decelerate_interpolator，accelerate_interpolator等。更多的interpolator 及其含义可以在Android SDK 中查看。同时这个Interpolator也是可以自定义的，这个后面还会提到。\n\n\n>pivot 决定了当前动画执行的参考位置\n\npivot 这个属性主要是在translate 和 scale 动画中，这两种动画都牵扯到view 的“物理位置“发生变化，所以需要一个参考点。而pivotX和pivotY就共同决定了这个点；它的值可以是float或者是百分比数值。\n\n\n我们以pivotX为例，\n\n|pivotX取值|含义|\n|---|:-----:|\n|10|距离动画所在view自身左边缘10像素|\n|10%|距离动画所在view自身左边缘 的距离是整个view宽度的10%|\n|10%p|距离动画所在view父控件左边缘的距离是整个view宽度的10%|\n\npivotY 也是相同的原理，只不过变成的纵向的位置。如果还是不明白可以参考[源码](https://github.com/REBOOTERS/AndroidAnimationExercise)，在Tweened Animation中结合seekbar的滑动观察rotate的变化理解。\n\n\n\n![rotate1.gif](http://upload-images.jianshu.io/upload_images/1115031-743288fa3be134ea.gif?imageMogr2/auto-orient/strip)\n\n#### Java Code  实现\n\n有时候，动画的属性值可能需要动态的调整，这个时候使用xml 就不合适了，需要使用java代码实现\n\n```\nprivate void RotateAnimation() {\n        animation = new RotateAnimation(-deValue, deValue, Animation.RELATIVE_TO_SELF,\n                pxValue, Animation.RELATIVE_TO_SELF, pyValue);\n        animation.setDuration(timeValue);\n\n        if (keep.isChecked()) {\n            animation.setFillAfter(true);\n        } else {\n            animation.setFillAfter(false);\n        }\n        if (loop.isChecked()) {\n            animation.setRepeatCount(-1);\n        } else {\n            animation.setRepeatCount(0);\n        }\n\n        if (reverse.isChecked()) {\n            animation.setRepeatMode(Animation.REVERSE);\n        } else {\n            animation.setRepeatMode(Animation.RESTART);\n        }\n        img.startAnimation(animation);\n    }\n```\n**这里animation.setFillAfter决定了动画在播放结束时是否保持最终的状态；animation.setRepeatCount和animation.setRepeatMode 决定了动画的重复次数及重复方式，具体细节可查看源码理解。**\n\n好了，传统动画的内容就说到这里了。\n\n\n## 属性动画\n\n属性动画，顾名思义它是对于对象属性的动画。因此，所有补间动画的内容，都可以通过属性动画实现。\n\n### 属性动画入门\n\n首先我们来看看如何用属性动画实现上面补间动画的效果\n\n```\n    private void RotateAnimation() {\n        ObjectAnimator anim = ObjectAnimator.ofFloat(myView, \"rotation\", 0f, 360f);\n        anim.setDuration(1000);\n        anim.start();\n    }\n\n    private void AlpahAnimation() {\n        ObjectAnimator anim = ObjectAnimator.ofFloat(myView, \"alpha\", 1.0f, 0.8f, 0.6f, 0.4f, 0.2f, 0.0f);\n        anim.setRepeatCount(-1);\n        anim.setRepeatMode(ObjectAnimator.REVERSE);\n        anim.setDuration(2000);\n        anim.start();\n    }\n```\n这两个方法用属性动画的方式分别实现了旋转动画和淡入淡出动画，其中setDuration、setRepeatMode及setRepeatCount和补间动画中的概念是一样的。\n\n可以看到，属性动画貌似强大了许多，实现很方便，同时动画可变化的值也有了更多的选择，动画所能呈现的细节也更多。\n\n当然属性动画也是可以组合实现的\n\n```\n                ObjectAnimator alphaAnim = ObjectAnimator.ofFloat(myView, \"alpha\", 1.0f, 0.5f, 0.8f, 1.0f);\n                ObjectAnimator scaleXAnim = ObjectAnimator.ofFloat(myView, \"scaleX\", 0.0f, 1.0f);\n                ObjectAnimator scaleYAnim = ObjectAnimator.ofFloat(myView, \"scaleY\", 0.0f, 2.0f);\n                ObjectAnimator rotateAnim = ObjectAnimator.ofFloat(myView, \"rotation\", 0, 360);\n                ObjectAnimator transXAnim = ObjectAnimator.ofFloat(myView, \"translationX\", 100, 400);\n                ObjectAnimator transYAnim = ObjectAnimator.ofFloat(myView, \"tranlsationY\", 100, 750);\n                AnimatorSet set = new AnimatorSet();\n                set.playTogether(alphaAnim, scaleXAnim, scaleYAnim, rotateAnim, transXAnim, transYAnim);\n//                set.playSequentially(alphaAnim, scaleXAnim, scaleYAnim, rotateAnim, transXAnim, transYAnim);\n                set.setDuration(3000);\n                set.start();\n```\n可以看到这些动画可以同时播放，或者是按序播放。\n\n### 属性动画核心原理\n\n在上面实现属性动画的时候，我们反复的使用到了ObjectAnimator  这个类，这个类继承自ValueAnimator，使用这个类可以对任意对象的**任意属性**进行动画操作。而ValueAnimator是整个属性动画机制当中最核心的一个类；这点从下面的图片也可以看出。\n\n\n![valueanimator.png](http://upload-images.jianshu.io/upload_images/1115031-80301bbb0ae884b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n属性动画核心原理，此图来自于Android SDK API 文档。\n\n>属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等。\n\n从上图我们可以了解到，通过duration、startPropertyValue和endPropertyValue 等值，我们就可以定义动画运行时长，初始值和结束值。然后通过start方法开始动画。\n那么ValueAnimator 到底是怎样实现从初始值平滑过渡到结束值的呢？这个就是由TypeEvaluator 和TimeInterpolator 共同决定的。\n\n具体来说，**TypeEvaluator 决定了动画如何从初始值过渡到结束值。**\n**TimeInterpolator 决定了动画从初始值过渡到结束值的节奏。**\n\n说的通俗一点，你每天早晨出门去公司上班，TypeEvaluator决定了你是坐公交、坐地铁还是骑车；而当你决定骑车后，TimeInterpolator决定了你一路上骑行的方式，你可以匀速的一路骑到公司，你也可以前半程骑得飞快，后半程骑得慢悠悠。\n\n如果，还是不理解，那么就看下面的代码吧。首先看一下下面的这两个gif动画，一个小球在屏幕上以 y=sin(x) 的数学函数轨迹运行，同时小球的颜色和半径也发生着变化，可以发现，两幅图动画变化的节奏也是不一样的。\n\n\n\n![anim1.gif](http://upload-images.jianshu.io/upload_images/1115031-741c714c3ef5fa84.gif?imageMogr2/auto-orient/strip)\n\n\n![anim2.gif](http://upload-images.jianshu.io/upload_images/1115031-dbbb2e4aca44b0e7.gif?imageMogr2/auto-orient/strip)\n\n*如果不考虑属性动画，这样的一个动画纯粹的使用Canvas+Handler的方式绘制也是有可能实现的。但是会复杂很多，而且加上各种线程，会带来很多意想不到的问题。*\n\n这里就通过自定义属性动画的方式看看这个动画是如何实现的。\n\n### 属性动画自定义实现\n这个动画最关键的三点就是 运动轨迹、小球半径及颜色的变化；我们就从这三个方面展开。最后我们在结合Interpolator说一下TimeInterpolator的意义。\n\n##### 用TypeEvaluator 确定运动轨迹\n\n前面说了，TypeEvaluator决定了动画如何从初始值过渡到结束值。这个TypeEvaluator是个接口，我们可以实现这个接口。\n\n```\npublic class PointSinEvaluator implements TypeEvaluator {\n\n    @Override\n    public Object evaluate(float fraction, Object startValue, Object endValue) {\n        Point startPoint = (Point) startValue;\n        Point endPoint = (Point) endValue;\n        float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());\n\n        float y = (float) (Math.sin(x * Math.PI / 180) * 100) + endPoint.getY() / 2;\n        Point point = new Point(x, y);\n        return point;\n    }\n}\n```\n\nPointSinEvaluator 继承了TypeEvaluator类，并实现了他唯一的方法evaluate；这个方法有三个参数，第一个参数fraction 代表当前动画完成的**百分比**，这个值是如何变化的后面还会提到；第二个和第三个参数代表动画的**初始值和结束值**。这里我们的逻辑很简单，x的值随着fraction 不断变化，并最终达到结束值；y的值就是当前x值所对应的sin(x) 值，然后用x 和 y 产生一个新的点（Point对象）返回。\n\n这样我们就可以使用这个PointSinEvaluator 生成属性动画的实例了。\n\n```\n        Point startP = new Point(RADIUS, RADIUS);//初始值（起点）\n        Point endP = new Point(getWidth() - RADIUS, getHeight() - RADIUS);//结束值（终点）\n        final ValueAnimator valueAnimator = ValueAnimator.ofObject(new PointSinEvaluator(), startP, endP);\n        valueAnimator.setRepeatCount(-1);\n        valueAnimator.setRepeatMode(ValueAnimator.REVERSE);\n        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                currentPoint = (Point) animation.getAnimatedValue();\n                postInvalidate();\n            }\n        });\n```\n这样我们就完成了动画轨迹的定义，现在只要调用valueAnimator.start() 方法，就会绘制出一个正弦曲线的轨迹。\n\n##### 颜色及半径动画实现\n\n之前我们说过，使用ObjectAnimator  可以对任意对象的任意属性进行动画操作，这句话是不太严谨的，这个任意属性还需要有get 和 set  方法。\n\n```\npublic class PointAnimView extends View {\n\n    /**\n     * 实现关于color 的属性动画\n     */\n    private int color;\n    private float radius = RADIUS;\n   \n\t.....\n\n}\n```\n这里在我们的自定义view中，定义了两个属性color 和 radius，并实现了他们各自的get set 方法，这样我们就可以使用属性动画的特点实现小球颜色变化的动画和半径变化的动画。\n\n```\n        ObjectAnimator animColor = ObjectAnimator.ofObject(this, \"color\", new ArgbEvaluator(), Color.GREEN,\n                Color.YELLOW, Color.BLUE, Color.WHITE, Color.RED);\n        animColor.setRepeatCount(-1);\n        animColor.setRepeatMode(ValueAnimator.REVERSE);\n\n\n        ValueAnimator animScale = ValueAnimator.ofFloat(20f, 80f, 60f, 10f, 35f,55f,10f);\n        animScale.setRepeatCount(-1);\n        animScale.setRepeatMode(ValueAnimator.REVERSE);\n        animScale.setDuration(5000);\n        animScale.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                radius = (float) animation.getAnimatedValue();\n            }\n        });\n\n```\n\n这里，我们使用ObjectAnimator  实现对color 属性的值按照ArgbEvaluator 这个类的规律在给定的颜色值之间变化，这个ArgbEvaluator 和我们之前定义的PointSinEvaluator一样，都是决定动画如何从初始值过渡到结束值的，只不过这个类是系统自带的，我们直接拿来用就可以，他可以实现各种颜色间的自由过渡。\n\n对radius 这个属性使用了ValueAnimator，使用了其ofFloat方法实现了一系列float值的变化；同时为其添加了动画变化的监听器，在属性值更新的过程中，我们可以将变化的结果赋给radius，这样就实现了半径动态的变化。\n\n**这里radius 也可以使用和color相同的方式，只需要把ArgbEvaluator 替换为FloatEvaluator，同时修改动画的变化值即可；使用添加监听器的方式，只是为了介绍监听器的使用方法而已**\n\n好了，到这里我们已经定义出了所有需要的动画，前面说过，属性动画也是可以组合使用的。因此，在动画启动的时候，同时播放这三个动画，就可以实现图中的效果了。\n\n```\n        animSet = new AnimatorSet();\n        animSet.play(valueAnimator).with(animColor).with(animScale);\n        animSet.setDuration(5000);\n        animSet.setInterpolator(interpolatorType);\n        animSet.start();\n```\n\nPointAnimView  源码\n\n```\npublic class PointAnimView extends View {\n\n    public static final float RADIUS = 20f;\n\n    private Point currentPoint;\n\n    private Paint mPaint;\n    private Paint linePaint;\n\n    private AnimatorSet animSet;\n    private TimeInterpolator interpolatorType = new LinearInterpolator();\n\n    /**\n     * 实现关于color 的属性动画\n     */\n    private int color;\n    private float radius = RADIUS;\n\n    public PointAnimView(Context context) {\n        super(context);\n        init();\n    }\n\n\n    public PointAnimView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n\n    public PointAnimView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n\n    public int getColor() {\n        return color;\n    }\n\n    public void setColor(int color) {\n        this.color = color;\n        mPaint.setColor(this.color);\n    }\n\n    public float getRadius() {\n        return radius;\n    }\n\n    public void setRadius(float radius) {\n        this.radius = radius;\n    }\n\n    private void init() {\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint.setColor(Color.TRANSPARENT);\n\n        linePaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        linePaint.setColor(Color.BLACK);\n        linePaint.setStrokeWidth(5);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        if (currentPoint == null) {\n            currentPoint = new Point(RADIUS, RADIUS);\n            drawCircle(canvas);\n//            StartAnimation();\n        } else {\n            drawCircle(canvas);\n        }\n\n        drawLine(canvas);\n    }\n\n    private void drawLine(Canvas canvas) {\n        canvas.drawLine(10, getHeight() / 2, getWidth(), getHeight() / 2, linePaint);\n        canvas.drawLine(10, getHeight() / 2 - 150, 10, getHeight() / 2 + 150, linePaint);\n        canvas.drawPoint(currentPoint.getX(), currentPoint.getY(), linePaint);\n\n    }\n\n    public void StartAnimation() {\n        Point startP = new Point(RADIUS, RADIUS);\n        Point endP = new Point(getWidth() - RADIUS, getHeight() - RADIUS);\n        final ValueAnimator valueAnimator = ValueAnimator.ofObject(new PointSinEvaluator(), startP, endP);\n        valueAnimator.setRepeatCount(-1);\n        valueAnimator.setRepeatMode(ValueAnimator.REVERSE);\n        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                currentPoint = (Point) animation.getAnimatedValue();\n                postInvalidate();\n            }\n        });\n\n//\n        ObjectAnimator animColor = ObjectAnimator.ofObject(this, \"color\", new ArgbEvaluator(), Color.GREEN,\n                Color.YELLOW, Color.BLUE, Color.WHITE, Color.RED);\n        animColor.setRepeatCount(-1);\n        animColor.setRepeatMode(ValueAnimator.REVERSE);\n\n\n        ValueAnimator animScale = ValueAnimator.ofFloat(20f, 80f, 60f, 10f, 35f,55f,10f);\n        animScale.setRepeatCount(-1);\n        animScale.setRepeatMode(ValueAnimator.REVERSE);\n        animScale.setDuration(5000);\n        animScale.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                radius = (float) animation.getAnimatedValue();\n            }\n        });\n\n\n        animSet = new AnimatorSet();\n        animSet.play(valueAnimator).with(animColor).with(animScale);\n        animSet.setDuration(5000);\n        animSet.setInterpolator(interpolatorType);\n        animSet.start();\n\n    }\n\n    private void drawCircle(Canvas canvas) {\n        float x = currentPoint.getX();\n        float y = currentPoint.getY();\n        canvas.drawCircle(x, y, radius, mPaint);\n    }\n\n\n    public void setInterpolatorType(int type ) {\n        switch (type) {\n            case 1:\n                interpolatorType = new BounceInterpolator();\n                break;\n            case 2:\n                interpolatorType = new AccelerateDecelerateInterpolator();\n                break;\n            case 3:\n                interpolatorType = new DecelerateInterpolator();\n                break;\n            case 4:\n                interpolatorType = new AnticipateInterpolator();\n                break;\n            case 5:\n                interpolatorType = new LinearInterpolator();\n                break;\n            case 6:\n                interpolatorType=new LinearOutSlowInInterpolator();\n                break;\n            case 7:\n                interpolatorType = new OvershootInterpolator();\n            default:\n                interpolatorType = new LinearInterpolator();\n                break;\n        }\n    }\n\n\n    @TargetApi(Build.VERSION_CODES.KITKAT)\n    public void pauseAnimation() {\n        if (animSet != null) {\n            animSet.pause();\n        }\n    }\n\n\n    public void stopAnimation() {\n        if (animSet != null) {\n            animSet.cancel();\n            this.clearAnimation();\n        }\n    }\n}\n```\n\n#### TimeInterpolator 介绍\n\nInterpolator的概念其实我们并不陌生，在补间动画中我们就使用到了。他就是用来控制动画快慢节奏的；而在属性动画中，TimeInterpolator 也是类似的作用；TimeInterpolator 继承自Interpolator。我们可以继承TimerInterpolator 以自己的方式控制动画变化的节奏，也可以使用Android 系统提供的Interpolator。\n\n下面都是系统帮我们定义好的一些Interpolator，我们可以通过setInterpolator 设置不同的Interpolator。\n\n\n![系统自带Interpolator](http://upload-images.jianshu.io/upload_images/1115031-9e26dde319ebaae7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里我们使用的Interpolator就决定了 前面我们提到的fraction。变化的节奏决定了动画所执行的百分比。不得不说，这么ValueAnimator的设计的确是很巧妙。\n\n#### XML 属性动画####\n\n这里提一下，属性动画当然也可以使用xml文件的方式实现，但是属性动画的属性值一般会牵扯到对象具体的属性，更多是通过代码动态获取，所以xml文件的实现会有些不方便。\n\n```\n<set android:ordering=\"sequentially\">\n    <set>\n        <objectAnimator\n            android:propertyName=\"x\"\n            android:duration=\"500\"\n            android:valueTo=\"400\"\n            android:valueType=\"intType\"/>\n        <objectAnimator\n            android:propertyName=\"y\"\n            android:duration=\"500\"\n            android:valueTo=\"300\"\n            android:valueType=\"intType\"/>\n    </set>\n    <objectAnimator\n        android:propertyName=\"alpha\"\n        android:duration=\"500\"\n        android:valueTo=\"1f\"/>\n</set>\n```\n使用方式：\n```\nAnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,\n    R.anim.property_animator);\nset.setTarget(myObject);\nset.start();\n```\nxml 文件中的标签也和属性动画的类相对应。\n```\n ValueAnimator --- <animator> \n ObjectAnimator --- <objectAnimator> \n AnimatorSet --- <set> \n```\n这些就是属性动画的核心内容。现在使用属性动画的特性自定义动画应该不是难事了。其余便签的含义，结合之前的内容应该不难理解了。\n\n## 传统动画 VS 属性动画 \n\n相较于传统动画，属性动画有很多优势。那是否意味着属性动画可以完全替代传统动画呢。其实不然，两种动画都有各自的优势，属性动画如此强大，也不是没有缺点。\n\n\n\n![补间动画点击事件](http://upload-images.jianshu.io/upload_images/1115031-6864a7fffbc80884.gif?imageMogr2/auto-orient/strip)\n\n\n\n![属性动画点击事件](http://upload-images.jianshu.io/upload_images/1115031-10bb818b5584da5e.gif?imageMogr2/auto-orient/strip)\n\n\n* 从上面两幅图比较可以发现，补间动画中，虽然使用translate将图片移动了，但是点击原来的位置，依旧可以发生点击事件，而属性动画却不是。因此我们可以确定，属性动画才是真正的实现了view的移动，补间动画对view的移动更像是在不同地方绘制了一个影子，实际的对象还是处于原来的地方。\n\n* 当我们把动画的repeatCount设置为无限循环时，如果在Activity退出时没有及时将动画停止，属性动画会导致Activity无法释放而导致内存泄漏，而补间动画却没有问题。因此，使用属性动画时切记在Activity执行 onStop 方法时顺便将动画停止。（对这个怀疑的同学可以自己通过在动画的Update  回调方法打印日志的方式进行验证）。\n\n* xml 文件实现的补间动画，复用率极高。在Activity切换，窗口弹出时等情景中有着很好的效果。\n\n* 使用帧动画时需要注意，不要使用过多特别大的图，容易导致内存不足。\n\n\n好了，关于Android 动画的总结就到这里。\n\n最后 有兴趣的同学可查看[github 源码](https://github.com/REBOOTERS/AndroidAnimationExercise)欢迎star & fork\n*********","tags":["自定义View"],"categories":["Android 进阶"]},{"title":"理解Android中的注解与反射","url":"%2F2016%2F09%2F24%2F%E7%90%86%E8%A7%A3Android%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84%2F","content":"\n## 前言##\n\n最近一段时间在研究EventBus和Retrofit 的过程中，都遇到了**注解**这个概念。由于在学习Java的时候对这方面没有深入了解过，所以看起相关的代码来，总会有点不知其所以然，这里就注解和反射的使用做一下总结。\n\n*这里我们先从反射说起，了解了反射的意义及用法后，我们在看看注解的使用，最后叙述一下在Android开发中是怎样结合使用注解与反射。*\n\n<!--more-->\n\n## 反射##\n\n\n### Java反射（Reflection）定义###\n\nJava反射机制是指在**运行状态**中\n\n**对于任意一个类，都能知道这个类的所有属性和方法；**\n**对于任何一个对象，都能够调用它的任何一个方法和属性；**\n\n这样动态获取新的以及动态调用对象方法的功能就叫做反射。\n\n比如像下面：\n\n```\n           //获取类\n        Class c = Class.forName(\"java.lang.String\");\n        // 获取所有的属性\n        Field[] fields = c.getDeclaredFields();\n        StringBuffer sb = new StringBuffer();\n        sb.append(Modifier.toString(c.getModifiers()) + \" class \" + c.getSimpleName() + \"{\\n\");\n        // 遍历每一个属性\n        for (Field field : fields) {\n            sb.append(\"\\t\");// 空格\n            sb.append(Modifier.toString(field.getModifiers()) + \" \");// 获得属性的修饰符，例如public，static等等\n            sb.append(field.getType().getSimpleName() + \" \");// 属性的类型的名字\n            sb.append(field.getName() + \";\\n\");// 属性的名字+回车\n        }\n        sb.append(\"}\\n\");\n        System.out.println(sb);\n```\n就可以获得 **String** ，这个我们常用类的所有属性：\n\n\n ![string_property](http://img.blog.csdn.net/20160902224548933)\n\n再比如：\n\n```\n       //获取类\n        Class c = Class.forName(\"java.lang.String\");\n        // 获取所有的方法\n        Method[] ms = c.getDeclaredMethods();\n        //遍历输出所有方法\n        for (Method method : ms) {\n            //获取方法所有参数\n            Parameter[] parameters = method.getParameters();\n            String params = \"\";\n            if (parameters.length > 0) {\n                StringBuffer stringBuffer = new StringBuffer();\n                for (Parameter parameter : parameters) {\n                    stringBuffer.append(parameter.getType().getSimpleName() + \" \" + parameter.getName() + \",\");\n                }\n                //去掉最后一个逗号\n                params = stringBuffer.substring(0, stringBuffer.length() - 1);\n            }\n            System.err.println(Modifier.toString(method.getModifiers())\n                    + \" \" + method.getReturnType().getSimpleName()\n                    + \" \" + method.getName()\n                    + \" (\" +params  + \")\");\n        }\n```\n\n可以获得String 类的所有方法（图片只截取了部分方法，实际有很多就不占篇幅了）：\n\n![string_method](http://img.blog.csdn.net/20160902224713217)\n\n \n### Java反射机制API###\n\n\n\n#### 主要的几个类####\n\nJava中有关反射的类有以下这几个：\n\n|类|用途|\n|--|:--:|\n|java.lang.Class|编译后的class文件的对象|\n|java.lang.reflect.Constructor|构造方法|\n|java.lang.reflect.Field|类的成员变量（属性）|\n|java.lang.reflect.Method|类的成员方法|\n|java.lang.reflect.Modifier|判断方法类型|\n|**java.lang.annotation.Annotation**|**类的注解**|\n\n#### 具体实现####\n\n为了方便描述，这里我们创建一个类 TestClass\n\n```\npublic class TestClass {\n    private String address;\n    private String port;\n    private int number;\n\n   public void printInfo() {\n        System.out.println(\"info is \" + address + \":\" + port);\n    }        \n    private void myMethod(int number,String sex) {\n\n    }\n\n    public String getPort() {\n        return port;\n    }\n\n    public void setPort(String port) {\n        this.port = port;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public int getNumber() {\n        return number;\n    }\n\n    public void setNumber(int number) {\n        this.number = number;\n    }\n\n\n}\n```\n\n这个类很简单，包含三个成员变量address，port和number，以及它们各自的get,set方法。\n两个自定义的方法printInfo()和myMethod()。\n\n下面我们就看一下如何通过反射，获取这个TestClass的所有**“信息”**\n\n* 1.获取Class\n关于Class的获取有三种写法：\n```\n//获取类的三种方法:\nClass c = Class.forName(\"java.lang.String\");  //这里一定要用完整的包名\nClass c1=String.class;\nString str = new String();\nClass c2=str.getClass();\n```\n这里获取的c,c1以及c2都是相等的。一般在反射中会用第一种写法。\n\n* 2.获取类的属性（成员变量）\n\n```\nField[] fields = c.getDeclaredFields();\n```\n这里返回的是一个数组 ，包含所有的属性。获取到的每一个属性Filed，包含一系列的方法可以获取及修改他的内容。\n如下所示：\n```\n// 遍历每一个属性\n        for (Field field : fields) {\n            sb.append(\"\\t\");// 空格\n            sb.append(Modifier.toString(field.getModifiers()) + \" \");// 获得属性的修饰符，例如public，static等等\n            sb.append(field.getType().getSimpleName() + \" \");// 属性的类型的名字\n            sb.append(field.getName() + \";\\n\");// 属性的名字+回车\n        }\n```\n这里我们可以得到TestClass的所有属性：\n\n![test_p](http://img.blog.csdn.net/20160902225142207)\n \n\n* 3.获取类的方法\n```\n// 获取所有的方法\nMethod[] ms = c.getDeclaredMethods();\n```\n和属性类似，我们依然可以通过一系列的方法获取到方法的**返回值类型，名称以及参数**。下面的表格中总结了一些关键方法：\n\n![reflection](http://img.blog.csdn.net/20160902225331083)\n\n 类似的获取到TestClass的所有方法：\n\n![test_method](http://img.blog.csdn.net/20160902225358568)\n  \n  这里可以看到，获取的TestClass的属性和方法同我们定义的是完全一致的。\n\n这里我们顺便调用一下TestClass的printInfo方法：\n```\nnew TestClass().printInfo();\n```\n用于所有属性没有做初始化，所以得到如下输出：\n\n![null](http://img.blog.csdn.net/20160902225523803)\n \n\n可以看到，利用反射我们可以很方便的去“反编译”一个class。那么我们用反射这么做的意义是什么呢？不要着急，下面我们先来了解一下注解\n\n## Java 注解（Annotation）##\n### 什么是注解###\n> 关于注解的定义网上有很多说法，就不再赘述。这里我们就说两点\n\n\n**Annotation（注解）就是Java提供了一种源程序中的元素关联任何信息或者任何元数据（metadata）的途径和方法。**\n\n**Annotation是被动的元数据，永远不会有主动行为**\n\n既然是被动数据，对于那些已经存在的注解，比如Override,我们只能看看而已，并不知道它具体的工作机制是什么；所以想要理解注解，就直接从自定义注解开始。\n\n### 自定义注解###\n\n```\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.FIELD})\n@Documented\n@Inherited\npublic @interface Bind {\n    int value() default 1;\n    boolean canBeNull() default false;\n}\n```\n这就是自定义注解的形式，我们用@interface 表明这是一个注解，Annotation只有成员变量，没有方法。Annotation的成员变量在Annotation定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。比如上面的value和canBeNull。\n\n### 元注解###\n\n可以看到自定义注解里也会有注解存在，给自定义注解使用的注解就是元注解。\n\n#### @Rentention Rentention####\n\n@Rentention Rentention用来标记自定义注解的有效范围，他的取值有以下三种：\n\n**RetentionPolicy.SOURCE: ** 只在源代码中保留 一般都是用来增加代码的理解性或者帮助代码检查之类的，比如我们的Override;\n\n**RetentionPolicy.CLASS: ** 默认的选择，能把注解保留到编译后的字节码class文件中，仅仅到字节码文件中，运行时是无法得到的；\n\n**RetentionPolicy.RUNTIME: **，注解不仅 能保留到class字节码文件中，还能在运行通过反射获取到，这也是我们最常用的。\n\n#### @Target####\n@Target指定Annotation用于修饰哪些程序元素。\n@Target也包含一个名为”value“的成员变量，该value成员变量类型为ElementType[ ]，ElementType为枚举类型，值有如下几个：\n\n* ElementType.TYPE：能修饰类、接口或枚举类型\n* ElementType.FIELD：能修饰成员变量\n* ElementType.METHOD：能修饰方法\n* ElementType.PARAMETER：能修饰参数\n* ElementType.CONSTRUCTOR：能修饰构造器\n* ElementType.LOCAL_VARIABLE：能修饰局部变量\n* ElementType.ANNOTATION_TYPE：能修饰注解\n* ElementType.PACKAGE：能修饰包\n\n*使用了@Documented的可以在javadoc中找到*\n*使用了@Interited表示注解里的内容可以被子类继承，比如父类中某个成员使用了上述@From(value)，From中的value能给子类使用到。*\n\n好了，关于注解就说这么多。\n\n## 反射&注解的使用##\n\n\n### 属性值使用注解###\n\n下面我们首先自定义两个注解：BindPort 和 BindAddress\n\n```\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface BindPort {\n    String value() default \"8080\";\n}\n```\n指定BindPort 可以保留到**运行时**，并且可以修饰成员变量，包含一个成员变量默认值为”8080“。\n```\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface BindAddress {\n    String value() default \"127.0.0.0\";\n}\n```\n这个和上面类似，只是默认值为\"127.0.0.0\"。\n\n同时，我们修改之前的TestClass \n\n```\npublic class TestClass {\n    @BindAddress()\n    String address;\n    @BindPort()\n    private String port;\n\n    private int number;\n\n    public void printInfo() {\n        System.out.println(\"info is \" + address + \":\" + port);\n    }\n   \n   ........\n\n\n}\n```\n这里我们将原先的address 和 port 两个变量分别用这里定义的注解进行修饰，由于我们在定义注解时有默认值，所以这里的注解可以不写参数。\n\n#### 使用反射获取注解信息####\n\n前面已经说了，**Annotation是被动的元数据，永远不会有主动行为**，所以我们需要通过使用反射，才能让我们的注解产生意义。\n\n通过反射可以获取Class的所有属性和方法，因此获取注解信息也不在话下。我们看代码：\n\n```\n\t    //获取类\n        Class c = Class.forName(className);\n        //实例化一个TestClass对象\n        TestClass tc= (TestClass) c.newInstance();\n\n        // 获取所有的属性\n        Field[] fields = c.getDeclaredFields();\n\n        for (Field field : fields) {\n            if(field.isAnnotationPresent(BindPort.class)){\n                BindPort port = field.getAnnotation(BindPort.class);\n                field.setAccessible(true);\n                field.set(tc,port.value());\n            }\n\n            if (field.isAnnotationPresent(BindAddress.class)) {\n                BindAddress address = field.getAnnotation(BindAddress.class);\n                field.setAccessible(true);        \n                field.set(tc,address.value());\n            }\n\n        }\n\n        tc.printInfo();\n```\n我们运行程序得到如下输出：\n\n![output](http://img.blog.csdn.net/20160902230814464)\n \n\n上面代码的逻辑很简单：\n\n**首先遍历循环所有的属性，如果当前属性被指定的注解所修饰，那么就将当前属性的值修改为注解中成员变量的值。**\n\n上面的代码中，找到被BindPort修饰的属性，然后将BindPort中value的值赋给该属性。\n\n这里setAccessible(true)的使用时因为，我们在声明port变量时，其类型为private，为了确保可以访问这个变量，防止程序出现异常。\n\n>理论上来说，这样做是不安全的，不符合面向对象的思想，这里只是为了说明注解和反射举例。\n>\n>但是，你也会发现，反射给我们提供了一种在运行时改变对象的方法。\n\n好了，下面我们继续修改TestClass \n```\npublic class TestClass {\n    @BindAddress(\"http://www.google.com.cn\")\n    String address;\n    @BindPort(\"8888\")\n    private String port;\n\n    private int number;\n\n    public void printInfo() {\n        System.out.println(\"info is \" + address + \":\" + port);\n    }\n    .......\n}\n```\n\n我们为注解设定了参数，再次运行，相信你已经猜到结果了。\n\n![output1](http://img.blog.csdn.net/20160902231316528)\n \n这时候由于我们在给成员变量设定注解时，写了参数，反射时也取到了相应的值。\n\n\n\n### 方法使用注解###\n\n上面对于类属性（成员变量）设定注解，可能还不能让感受到注解&反射的优势，我们再来看一下类的方法使用注解会怎样。\n\n我们还是先定义一个注解\n\n```\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface BindGet {\n    String value() default \"\";\n}\n```\n有效范围至运行时，适用于方法。\n\n再次修改TestClass 如下：\n\n```\npublic class TestClass {\n    @BindAddress(\"http://www.google.com.cn\")\n    String address;\n    @BindPort(\"8888\")\n    private String port;\n\n    private int number;\n\n    @BindGet(\"mike\")\n    void getHttp(String param){\n        String url=\"http://www.baidu.com/?username\"+param;\n        System.err.println(\"get------->\"+url);\n    }\n\n    ...........\n}\n```\n\n我们添加了一个名为getHttp的方法，而且这个方法由@BindGet注解。\n\n然后看反射的使用：\n\n```\n\t//获取类\n        Class c = Class.forName(className);\n        TestClass tc= (TestClass) c.newInstance();\n\t\n\t// 获取所有的方法\n        Method[] ms = c.getDeclaredMethods();\n\n        for (Method method : ms) {\n           if(method.isAnnotationPresent(BindGet.class)){\n               BindGet bindGet = method.getAnnotation(BindGet.class);\n               String param=bindGet.value();\n               method.invoke(tc, param);\n           }\n        }\n```\n\n这里的逻辑和对属性的解析相似，依旧是判断当前方法是否被指定的注解（BindGet）所修饰，\n如果是的话，就使用**注解中的参数**作为**当前方法的参数**去调用他自己。\n\n这样，我们在运行程序时，通过反射就回去主动调用get方法，得到如下输出：\n\n![output2](http://img.blog.csdn.net/20160902231615406)\n\n \n这里我们就可以通过注解动态的实现username参数的修改，甚至get方法整个http url地址的修改。\n(假设我们这里的get 方法是做网络请求）\n\n\n到这里，你应该已经明白了如何使用反射获取注解的信息，但你一定会困惑这么做有什么用呢？\n\n**”动态“**，**”动态“**，**”动态“**\n\n这就是使用注解和反射最大的意义，我们可以动态的访问对象。\n\n说了这么多，下面我们看看，在Android开发中，我们遇到的注解和反射。\n \n## Android 中的注解&反射##\n\n### Butterknife###\n\n如果你是一个Android开发者，相信在使用Butterknife插件之前，你一定写了无数次的findViewById。\n\n然而，如果使用了Butterknife 插件，我们就可以很方便的完成findViewById的工作，甚至是setOnClickListener 的工作。\n```\npublic class ButtferknifeDemoActivity extends AppCompatActivity {\n    @BindView(R.id.textView)\n    TextView textView;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_buttferknife);\n        ButterKnife.bind(this);\n        textView.setText(\"I'm not null\");\n\n    }\n}\n```\n\n上面的代码，应该不陌生。试想如果你的activity_bufferknife 布局文件中有很多控件时，这样做不知道可以省多少时间了\n\n我们看一下BindView的注解定义：\n\n```\n@Retention(CLASS) @Target(FIELD)\npublic @interface BindView {\n  /** View ID to which the field will be bound. */\n  @IdRes int value();\n}\n```\n这个注解用于修饰变量，有效范围也是限定到了CLASS(即编译阶段），并没有到运行时。\n我们在Butterknife（8.4.0）的部分源码中可以看到：\n```\n /** Simpler version of {@link View#findViewById(int)} which infers the target type. */\n  @SuppressWarnings({ \"unchecked\", \"UnusedDeclaration\" }) // Checked by runtime cast. Public API.\n  @CheckResult\n  public static <T extends View> T findById(@NonNull View view, @IdRes int id) {\n    return (T) view.findViewById(id);\n  }\n```\n我们可以猜到的，编译时最终的实现必然是到这里，实现view.findViewById(id)。\n\n**在这里，注解和反射的结合，使我们可以避免做很多重复的工作。**\n\n### Retrofit 2.0 ###\n\n第一次使用Retrofit的时候，完全被接口定义的方式搞蒙圈了，完全搞不懂啊。\n\n```\npublic interface UserBasicService {\n\n    @GET(\"users/{user}\")\n    Call<ResponseBody> getUsers(@Path(\"user\") String uses);\n}\n```\n\n为什么要这么写？参数是怎么传递的？@ 是什么意思？带着曾经的这些疑问，我们首先看看这里的两个注解。\n\n这里使用了两个注解GET 和Path ,我们看一下：\n\n**GET**\n\n```\n/** Make a GET request. */\n@Documented\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface GET {\n  /**\n   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first\n   * parameter of the method is annotated with {@link Url @Url}.\n   * <p>\n   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how\n   * this is resolved against a base URL to create the full endpoint URL.\n   */\n  String value() default \"\";\n}\n```\n\n**Path**\n```\n@Documented\n@Retention(RUNTIME)\n@Target(PARAMETER)\npublic @interface Path {\n  String value();\n\n  /**\n   * Specifies whether the argument value to the annotated method parameter is already URL encoded.\n   */\n  boolean encoded() default false;\n}\n```\n\n这两个注解的生命周期都延续到了 RUNTIME，即运行时。GET用于方法，Path用于参数。这点和我们定义getUsers（）方法是一致的。\n\n关于Retrofit中反射和注解的使用，涉及到动态代理的相关概念，这里就不展开来说。总的思路就是通过注解中使用的参数，动态的生成Request有OKHttp去调用。这个以后会做深入分析，这里只是了解注解和反射用法。\n\n好了，关于注解和反射的使用方法及意义就暂时总结到这里。\n\n## 后话##\n\n以合适的方式使用反射，会让我们写代码的方式更加灵活。反射使用不当，反而会适得其反，会对性能造成影响。\n\n但是EventBus，Retrofit 的如此火爆，让我们有理由相信，对性能的影响也许没那么大，或者说面对现如今硬件配置堪比电脑的手机，这点影响也许可以忽略不计。\n\n所以关于反射的使用还是仁者见仁智者见智吧。\n\n***\n\n\n\n","tags":["注解，反射"],"categories":["Android 进阶"]},{"title":"EventBus 3.0 相见恨晚","url":"%2F2016%2F07%2F23%2FEventBus%203.0%20%E7%9B%B8%E8%A7%81%E6%81%A8%E6%99%9A%2F","content":"\n## 为什么要用EventBus？它是干什么用的？##\n\n### EventBus是什么###\n\nEventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。\n\n这样一个简单的概念，可能让你不足以感受到EventBus的魅力。我们来思考一下下面这些情况。\n\n<!--more-->\n\n*  使用购物类APP时，我们在商品详情页将商品加入购物车时，底部tab栏的购物车tab右上角的小数字也同步发生了变化。\n\n面对这样的需求，一般情况下都是在详情页中提供一个接口，在tab栏所在的Activity（或者是Fragment）中注册这个接口，当点击事件发生是，回调这个接口，更新tab栏的内容。甚至有时候，由于Activity+多个fragment 的组合，可能需要多个接口经过层层传递才能实现某些在产品经理看来很简单的UI更新。\n\n*  大部分APP在用户完成用户登录操作后，需要在返回界面同步更新用户信息。\n\n这个时候，我们一般会在返回界面的onActivityResult方法中，通过requestCode及resultCode做出种种判断，最后在确认用户登录成功的情况下，请求用户信息完成UI的更新，这种体验其实是非常不好，作为一个用户希望的是登录成功的同时完成用户信息的更新。\n\n当然上面两种情况，用BroadcastReceiver实现，也是完全可以的，肯能会相对简单一些，但是从整体性能来说，这样是不好的。\n\n而EventBus的出现，很好的解决了这些让我们头疼的问题。首先就用一个简单的列子来实现一下用户登录信息**异步**更新的情况。\n\n\n## EventBus 3.0 使用Demo##\n\n这里用两个Activity简单的模拟常见的用户登录。\n\n\n### 用户信息界面###\n\n\n```\npublic class FirstActivity extends AppCompatActivity {\n    private Button btn;\n    private Context mContext;\n    //User Info\n    private TextView userName;\n    private ImageView usreImg;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mContext = this;\n        EventBus.getDefault().register(mContext);\n        InitView();\n\n\n    }\n\n    private void InitView() {\n        setContentView(R.layout.activity_first);\n        userName = (TextView) findViewById(R.id.userName);\n        usreImg = (ImageView) findViewById(R.id.userImg);\n        btn = (Button) findViewById(R.id.button);\n        btn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                startActivity(new Intent(mContext, SecondActivity.class));\n            }\n        });\n    }\n\n\n    @Subscribe\n    public void onUserEvent(UserEvent event) {\n        userName.setText(\"用户名:\" + event.nameStr);\n        Glide.with(mContext).load(event.imgUrl).into(usreImg);\n\n    }\n\n    @Override\n    protected void onDestroy() {\n        EventBus.getDefault().unregister(mContext);\n        super.onDestroy();\n    }\n}\n```\n### 用户登录界面###\n\n```\npublic class SecondActivity extends AppCompatActivity {\n    private Context mContext;\n    private Button btn;\n    private EditText name;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mContext=this;\n        setContentView(R.layout.activity_second);\n        name = (EditText) findViewById(R.id.name);\n        findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                //测试数据\n                String userImg = \"http://img5.imgtn.bdimg.com/it/u=3774008831,1558972780&fm=21&gp=0.jpg\";\n                //这里只是为了方便测试,随便写的登录逻辑\n                String userName=\"\";\n                if(!TextUtils.isEmpty(name.getText().toString())){\n                    userName = name.getText().toString();\n                    UserEvent userEvent = new UserEvent(userName, userImg);\n                    EventBus.getDefault().post(userEvent);\n                }else {\n                    //不再发送事件Event\n                    Toast.makeText(mContext,\"登录失败\",Toast.LENGTH_SHORT).show();\n                }\n\n                finish();\n            }\n        });\n\n    }\n}\n```\n### UserEvent 类###\n\n```\npublic class UserEvent {\n    public final String nameStr;\n    public final String imgUrl;\n\n    public UserEvent(String nameStr, String imgUrl) {\n        this.nameStr = nameStr;\n        this.imgUrl = imgUrl;\n    }\n}\n```\n\n这里可以看到没有Handler，没有onActivityResult的判断，没有没有任何接口。就实现了如gif图中所示效果。\n\n接下来，就总结一下如何使用EventBus3.0 。\n\n## EventBus 3.0 使用步骤##\n\n1.首先我们需要将EventBus添加到我们的项目中。在AndroidStudio中我们可以在gradle里面直接配置即可。\n\n```\ncompile 'org.greenrobot:eventbus:3.0.0'\n```\n\n2.创建一个事件类（这个类似于JavaBean)，就是上面的UserEvent类。\n\n这里的Demo只是举例说明简单用法，实际中可以根据需要创建不同的事件类\n\n3.注册\n\n```\n  EventBus.getDefault().register(mContext);\n```\n\n4.订阅（响应事件方法）\n\n```\n@Subscribe\n    public void onUserEvent(UserEvent event) {\n        userName.setText(\"用户名:\" + event.nameStr);\n        Glide.with(mContext).load(event.imgUrl).into(usreImg);\n\n    }\n```\n\n这里的注解@Subscribe 很关键，表明这个方法为订阅者，这个方法的名字也已经不在重要了（相对于以前的版本来说），在这个方法里，我们实现了UI更新。\n\n5.分发事件\n\n```\nUserEvent userEvent = new UserEvent(userName, userImg);\n                    EventBus.getDefault().post(userEvent);\n```\n\n6.解除注册\n\n```\nEventBus.getDefault().unregister(mContext);\n```\n\n\n\n\n\n\n\n\n\n\n","tags":["观察者模式"],"categories":["Android 三方框架"]},{"title":"我的少年时代","url":"%2F2016%2F06%2F06%2F%E6%88%91%E7%9A%84%E5%B0%91%E5%B9%B4%E6%97%B6%E4%BB%A3%2F","content":"\n#### 蝉鸣的夏季 我想遇见你####\n     \n2006年的夏天，郭然读高一。\n\n在后来许许多多的日子里，回忆起那个夏天，郭然总是笑着说，那是最最快乐的青春时光。\n\n二中是县里的重点高中，每年初中毕业后能踏进二中校门的人，在内心深处总有着几分悲壮与莫名的骄傲。而一上高中，就直接进入实验班的人，更是许多人眼里神一样的存在，就像郭然，初中三年，始终是那个全年级考第一的人，没有人去嫉妒，就像你不会嫉妒马云赚的比你多一样。所以呢，他能进入实验班在我们一群初中同学眼中是理所当然，反倒是亦安没能进实验班让我们一群人很是诧异，因为亦安虽然不如郭然一样那么稳定的始终待在全年级第一的宝座上，但初中三年下来也没跌出过年纪前五。\n\n那个时候，刚住校的我们，每周五都会一起坐车回家；每次在车上和亦安同属六班的“狗圣”都会说，一定是哪个有钱人家给学校塞了钱把自己家的孩子硬塞进了实验班，挤掉了原本属于亦安的名额，对此，我们几个人都是义愤填膺。反倒是亦安自己觉得没什么，按照她的话就是，只要自己努力，还怕考不上自己心目中的大学，在哪里都无所谓。\n\n\n\n![](http://upload-images.jianshu.io/upload_images/1115031-8a3ae7cb4ba9086f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n<!--more-->\n\n“狗圣”是跟我从小一块用尿和稀泥玩过家家的发小，我们从小学开始就一直在一个班，每天一起上学，一起放学，夏天一起到河里游泳，冬天一起到山上追野兔，在学校里一起打架，当然有时候也是一起被打。直到高中，我们被分到了不同的班里。“狗圣”并不姓狗，学生证上姓名那一栏写的是李鸿盛。小学的时候，有一次放学后去河边游泳，小伙伴们聊天，不知为何就聊到了嘘嘘的话题上，大家都在自己说可以嘘的多远多高，甚至有些人都开始比划上了，狗圣也是其中之一。一场小小的较量慢慢开始，最终狗圣以微弱的劣势的败给了另外一位嘘的比他更远的小伙伴。也许是心有不甘，狗圣忽然问大家说，你们知道狗是怎么嘘嘘的吗？那个时候，宠物不像现在这么的流行，一般人很少能看见小狗小猫，街坊领居家里养猫狗的人也不多，所以真的是没吃过狗肉，也没怎么见过狗跑。\n\n在大部分人的世界观里，对于嘘嘘这件事，基本上都停留在站着还是蹲着的区别上，脑袋里完全没有另外一种姿势。当然，也是有人看到过的，我经常去狗圣家玩，有时候就会看见他们家那条看门的哈巴狗对着南墙嘘嘘时的样子。我们几个小伙伴彼此看了一眼，怀揣着好奇的心情心照不宣的摇了摇头。狗圣还特意看了我一眼，然后微微一笑，仿佛是在感谢我很识时务的没有破坏他想要表演的欲望。只是接下来他所做的一切，彻底成为了他此生最不愿回首的事情。他单脚站立，另一只脚耷拉的半空，弯着腰很有节奏的哆嗦了两下，此刻的你可以脑补一下那个画面，完全就是一条狗的姿态。那一瞬间，我们所有的小伙伴都笑喷了，而明白过来的狗圣在河边气愤却又无可奈何的追打着我们。李鸿盛因为一出真实版的《人与自然》就成了小伙伴们口中的狗，而后来为了叫着顺溜，狗圣就成了伴随他多年的外号。\n\n\n![](http://upload-images.jianshu.io/upload_images/1115031-414d7c5dde950ba4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n那个夏天，过的很快。我们几个一起踏入二中校门的同学和能联系上的初中同班同学以及老师一起进行了一次野炊。男同学负责生火捕鱼，在小树林搭起帐篷，女同学负责洗菜，做饭。在那个蝉鸣的夏季，我们谈着理想，憧憬着美好的未来。所有同学和老师都一致认为，郭然只要加把劲，将来考进清华或者北大是没有问题的，况且二中每年都会有学生进这两所名校，师资力量完全不是问题。郭然特意的感谢了大家的支持，并且说一定会不负众望。我们几个二中的同学也是彼此约定，这三年也要互相帮助，资源共享。在后来日子里，参加过很多大大小小各种形式的聚会，却再也没有过当年的那份快乐，再也没有过像当年那般让自己充满力量的时刻。\n\n#### 枫叶将故事染色 结局我看透####\n\n高中的课程，比起以往，从质和量上都有了很大的跨越。尤其是物理，变得更加的抽象和难以理解。更神奇的是，我遇上了一位奇葩的物理老师，而且与他结下了不解之缘。这位老师第一次给全班做自我介绍的时候，有两件事给我留下了深刻的印象，一件事是他的名字，张发财。在我们那个地方，每个小孩的名字都显得很“通俗”，比如我有个表弟的名字叫做赵长寿，小学的音乐老师叫李雪莲，总之都是父母用心良苦，希望儿女们以后可以活的精彩，活的漂亮，活的有滋有味。\n\n\n一件事是他的着装，尽管从小爸妈和老师都告诉我们不应该随意的对别人的穿着相貌评头论足，可是张发财老师那时的着装在后来很长的日子里深深地影响了我的审美观。那时的张老师其实也很年轻，也许是刚刚从哪个师范院校毕业没几年，讲课很有激情。但是他上的第一堂课结束后，全班同学都在讨论他为什么梳着一个中分的发型，上身穿着一款很有型的小西装，下身却穿着一件洗的发白的牛仔裤和一双布鞋。对他身上这些东西，没有任何的鄙视，因为那时候班里大部分人穿的都是妈妈做的布鞋，很多人穿的牛仔裤甚至是在屁股上打了好几层补丁的。我们诧异的仅仅是他这种搭配，当时还有同学说，也许可能是老师今天皮鞋刚好坏了，裤子洗了没干，所以只能暂时凑合。只是，在后来将近整整一学期这样的装扮后，我们彻底被打败了。\n\n是的，这就是张老师，永远的中分小西装，牛仔裤和布鞋。这样的装扮，直到十年后的今天，我依旧无法理解那是时尚还是别的什么。他的课也是如同他的衣品一样糟糕，虽然每次总是很有激情的讲着，从他每次准备的那么多资料，可以想象课下的他是多么努力的想把一个人民教师的工作做好，只是每次都是让我们坐在前排的这些同学淹没在无用的唾沫和无尽的粉笔灰里。\n\n\n![](http://upload-images.jianshu.io/upload_images/1115031-3143dba1686d2da8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n高二时文理科分班，想着终于可以解脱了，只是命运再一次安排我们相遇，高中三年物理课始终都是他带，幸好有亦安，分班后刚好和我在一个班，所以平时就会对我加以辅导，才使我的物理考试成绩总能维持在一个能让自己满意的水平。我不知道后来的日子里张老师的衣品会不会有所提升，但是有一件事我敢确定，他的课会越讲约好，因为他是一个努力想把这件事做好的人。\n\n分班后，所有人似乎一下子就进入了备战高考的状态。大家都没有了玩的心思，把不得把所有的时间都用在学习这件事情上。周末回家的公交车上也只剩下我和亦安了，我俩都是特别恋家的孩子，纵然时间宝贵也想回家看一眼爸妈，吃一口妈妈做的饭。其他人美其名曰要抓紧时间复习，但是真正把时间花在学习上的可能也只有郭然了，狗圣自从高二的时候找了个女朋友，在加上分了班的缘故，就慢慢从我们的视线里消失了。当然，我们的友谊依旧地久天长，偶尔在厕所里遇见了，也会调侃他几句重色轻友，而作为文科生的他，总能引经据典的让我哑口无言，而我也只能回敬几句他永远都不会理解的生物学专有术语。\n\n天外有天，人上有人，郭然虽然不能像初中那般稳坐全年级第一的宝座，但每次模拟考试从来是没有跌出过前十名。依旧像神一样存在于几个小伙伴的内心当中。他总会把实验班老师发的复习资料分享给我们，每次有不懂的问题找他，也会毫不犹豫的帮我们解答，一如从前，你在他的脸上看不到沮丧的表情，他总是像个孩子一样，整天都很开心。\n\n07年冬天，正式的进入了高考倒计时，每个高三毕业班教室后面黑板报上都会有用红色的粉笔描绘的距离高考还有XX天的大字，并且由班长负责每天进行更新。那是一段很特别的时光，只有经历的那样一段岁月，你才可能真正地明白所谓的考场如战场意味着什么。后来上大学包括工作时，每次和别人聊到高三时为高考奋战的日子，每个人眼里总会显现出无尽的自豪，那是带着汗水与艰辛的青春岁月。许多人说那是一段你再也无法体验的日子，在漫长的人生道路上，也许你要考研，为了出国要考GRE,考托福……，要面对新的挑战，但再也不能像高三那年那么的投入，那么的心无旁骛。因为随着年龄和阅历的增长，我们明白很多事的选择不是唯一，我们是有退路的。而且，在活着这件事情上，永远都没有一劳永逸。\n\n那时候开始，我和亦安回家的次数也从每周一次，变成了每月回一次。这也是各自父母的要求。按照亦安她爸的说法就是，起跑线上有没有输，已经不重要了，但是一定不能输在最后冲刺的阶段。月末回家的那天是我们俩每个月最开心的日子，不仅是因为可以回家吃到妈妈做的饭，更是因为回家的路上可以去音像店里听歌，那时虽然MP3已经很普及，但是对于那个时候我们，那依然是奢侈品。所以听歌的唯一途径就是去路边的音像店里打着挑选磁带的幌子在那里赖一个小时，听听最新的流行歌曲。\n\n\n![](http://upload-images.jianshu.io/upload_images/1115031-4c743623cf910440.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我和亦安到现在都可以把《青花瓷》的歌词完完整整的写下来，那是我们在那段时间听得最多的歌。在作为周杰伦歌迷的这么多年里，觉得《青花瓷》是他中国风类型歌曲的巅峰之作，同时也是方文山歌词创作的巅峰之作。从小到大学了那么被强迫背诵全文而如今早已忘得一干二净的所谓的经典之作，也没有让我感受到任何古诗词作品的美妙，没有激发对语文学习的兴趣，反而是一篇歌词。\n\n#### 时间被安排，演一场意外####\n\n08年的元旦，学校破天荒的决定放假，这对于憋了一整个冬天的所有高三党来说完全就是一个惊喜，包括老师。我和亦安决定还是回家，因为觉得反正在家里也能学习，在学校学三天反而不会有什么效果。郭然本来就是那种喜欢安静的人，学校放假人少了刚好可以放松一下身心，所以决定不回家。狗圣也决定不回家，虽然和我们一再强调要安心复习，争取下次模拟考能进年纪前十，但我和亦安都知道他留在学校不过是为了陪他的女朋友，亦安更是无情的嘲笑狗圣这是媳妇还没娶呢，就忘了娘。\n\n*如果时光能够倒流，真的想回到08年的元旦，把郭然和狗圣想尽一切办法的拉回家，免得他们承受之后的一切*\n\n放完假回来的那天下午，带着郭然很喜欢吃葱花油饼去他们宿舍找他，这是过元旦时每家都会做的好东西，想让没回家的他解解馋，可却没有找到他，同宿舍的室友告诉我说他回家了，让我很是诧异。再去找狗圣，也是同样的结果，让我在内心隐隐有一丝的不安。晚自习课间休息的时候，我开玩笑的问亦安，“你说郭然和狗圣不会是私奔了吧”。亦安鄙视的看了我一眼说，怎么可能。可我们俩心里都有些不安，尤其是对郭然。第二天我特意去实验班找郭然，结果被告知一整天都没来上课，去狗圣宿舍也是被告知一直没回来，两个人就像突然失踪了一样。\n\n\n![](http://upload-images.jianshu.io/upload_images/1115031-c57d1886a18687a3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n就像暴风雨来临之前，天空会变得阴云密布，当我们内心烦躁时，真的会有事情发生。到了第三天早上整个高三党都在说一件事，实验班的学生把年级主任打了。那段时间大约有一个星期，都没有看到郭然和狗圣。再次看到他俩的时候，完全都认不出了，不知道一个人经历了什么才会变成那个样子，狗圣变得真像一条狗一样，蓬头垢面。而郭然呢，更是像一下子老了十岁似的，看不到那熟悉的笑容。直到那年高考结束，我始终不知道具体发生了什么，只知道一群学生把年纪主任打伤了，还住了院，这群学生里包括郭然和狗圣。\n\n后来，高考前的那段日子里发生很多事，郭然和狗圣的父母来过学校好几次，每次都是直接去行政楼，也不知道具体说了些什么。想必以往，他们俩都变得异常的沉默，脸上很少再有笑容。大家偶尔在路上碰见，一起聊天的时候，亦安讲笑话，他们俩也是强颜欢笑。郭然在后来的两次模拟考试中，成绩一落千丈，直接被其他班里成绩比他好的顶替了他在实验班的位置，被分到了一个普通班。狗圣呢，也变成了单身狗。对于郭然的急速陨落，我和亦安都是看在眼里，急在心里，而他总是刻意躲避我们，想要找他好好聊聊很困难。而狗圣也是像在校园里消失了似得，很难看见他的身影。去宿舍找他，不是在睡觉就是人不在宿舍。人在忙碌的时候，时间总是会过的特别快，过完年回来一百多天的日子转瞬即逝，高考终于来临。我清楚的记得，当年考完最后一门英语，交卷后从教室里出来的那一刻，并没有一种解脱的感觉，内心反而显得特别的平静，恍然间有点不知所措罢了。\n\n\n\n亦安说，高考结束后一定要回家好好睡上一星期，把这半年缺的觉都要补回来。\n\n\n![](http://upload-images.jianshu.io/upload_images/1115031-aa37e8820139a681.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n高考结束后，等分数的那段日子也是充满煎熬，尤其是对于狗圣，最后两次模拟考的分数跳跃挺大，让他对自己的状态也是有些怀疑，而且文科考试不像理科，有太多的不确定。那时候的我们都没有手机，更别提上网了。所以查成绩的唯一途径就是打有线电话。\n\n成绩公布的那天，我和狗圣早早的来到了镇上的小超市，想用那里的唯一的公用电话查成绩，去的路上狗圣还跟我说，要让他先查，不许跟他抢，结果到了那又开始犹豫，让我先查；我的成绩比几次模拟考试还高点，所以我还是有点庆幸自己有点小小的超常发挥。轮到狗圣的时候，始终在那里磨磨唧唧，最后还是我帮他查，当我按下免提键分数从电话机里报出来的那一刻，我在狗圣脸上再次看到了那份久违的纯真笑容。\n\n\n\n我和亦安很多次都问过狗圣和郭然那次到底发生了什么，只是他们俩永远都是转移话题，避而不谈。那天回去的路上，狗圣终于把一切都告诉了我。事情其实很简单，几个男生在宿舍里看黄色杂志被恰好查寝的年级主任发现，年纪主任要没收书，几个人碍于面子不愿意把书交出来，主任一开始不知道是色情杂志，想没收没成功，反而激发他的好奇心，死活都要让几个人把书交出来，几个男生不愿意。一来二去便发生了肢体冲突，其实谁都没有想着动手去打人，毕竟是老师。只是在混乱中不知谁推了一把，年纪主任头撞在了窗户的棱角上流了血，几个人赶紧扶着年级主任去了校医院，而这次意外就慢慢发酵成了几个学生把年纪主任打伤了这样一件事情。出事之后，几个学生的家长都被叫到了学校，校方对于这件事很是愤怒，一开始说是要开除这几个学生，后来几个家长各种求情，最终才决定留校察看。狗圣说，这件事最对不起的人是自己的父母，在出事的那段时间父母似乎一下子老了许多，所以，这次高考自己一定要考好，再也不能让他们失望。\n\n08年秋天，我和亦安去了北京上大学，狗圣选择去了西安，郭然去了南方一座不知名的院校。我们所有人对为他感到惋惜，这本不该是属于他的命运，他可是当年我们心中的神啊。南美洲的蝴蝶煽一下翅膀，通过种种因素，就可能引起亚洲地区的一阵台风，有些小事，会给我们原本平静的生活带来一些波折。\n\n![](http://upload-images.jianshu.io/upload_images/1115031-971f7671a9f30df9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在后来很多的日子里，我总会去幻想，如果当年的一切都没有发生，现在的郭然会是什么样子。很多时候，都觉得这就是命运，生活中总有些我们无能为力的事情。从《那些年，我们一起追过的女孩》到《致我们终将逝去的青春》，再到后来的《匆匆那年》，任何一个故事，但凡涉及到青春，总会或多或少的给我们带来些许共鸣。但总是少一些感同身受的成分，直到《我的少女时代》的出现。当林真心为了让徐太宇变回从前的徐太宇，不顾疼痛的穿着旱冰鞋跑向终点时，我瞬间就想到了郭然。那时的郭然没有徐太宇幸运，没有遇见他的“林真心”。年少的我们，总会犯错，总会在成长的道路上误入歧途，有时候我们只是不小心迷失了方向，丧失了信心，这个时候我们真的需要有个人能让我们重新回到正确的轨道。\n\n2016年的夏天，郭然来北京玩，晚上我们在簋街吃小龙虾，聊起即将到来的高考，郭然说，当年高考失利真的以为这辈子就这么完了，到了大学慢慢发现，人生不止眼前的苟且，还有诗与远方的苟且。我说，靠，你是不是喝醉了。我们俩一起开始哈哈大笑。\n\n\n***\n\n\n\n\n\n\n","tags":["生活，理想"],"categories":["诗与远方"]},{"title":"Android View 事件分发记录","url":"%2F2016%2F05%2F07%2FAndroid%20View%E4%BA%8B%E4%BB%B6%E8%AE%B0%E5%BD%95%2F","content":"\n# View初探 #\n\n\n> 一直以来对View的事件分发机制很晕，今天就在这里梳理一下\n\n\n<!--more-->\n\n## MyView ##\n\n### 首先继承View类，自定义一个MyView。并在初始化时打印View类是否可点击，这里从View点击事件分发的角度出发，所以不考虑绘制，测量相关方法的实现。 ###\n\n    public class MyView extends View {\n    String TAG = \"Activity\";\n\n    public MyView(Context context) {\n        super(context);\n        init();\n    }\n\n\n    public MyView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n\n    public MyView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n    private void init() {\n        Log.e(TAG, \"the View clickable is \" + isClickable());\n    }\n\n}\n\n将整个MyView放置到布局文件中，看Log日志。\n\n    <engineer.test.MyView\n        android:id=\"@+id/myview\"\n        android:layout_width=\"150dp\"\n        android:layout_height=\"150dp\"\n        android:layout_centerInParent=\"true\"\n        android:background=\"#ff00ff\" />\n\n\n**可以看到，View类默认是不可点击的。**\n\n## 监听View的Touch事件 ##\n\n> 这里首先明确MotionEvent中事件所对应的值\n\n    public static final int ACTION_DOWN= 0;\n    public static final int ACTION_UP= 1;\n    public static final int ACTION_MOVE= 2\n\n\n> 给MyView设置OnTouchListener，并打印事件日志\n\n    myView = (MyView) findViewById(R.id.myview);\n        myView.setOnTouchListener(new View.OnTouchListener() {\n            @Override\n            public boolean onTouch(View v, MotionEvent event) {\n                Log.e(TAG, \"myview_onTouch---->\"+event.getAction());\n                return false;\n            }\n        });\n\n点击一下MyView看日志：\n\n\n\n**可以看到，这里只有ACTION_DOWN事件发生**\n\n> 给MyView设置OnClickListener，并打印日志\n\n    myView.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Log.e(TAG, \"the View clickable is \" + myView.isClickable());\n                Log.e(TAG, \"myview_onClick\");\n            }\n        });\n\n点击一下MyView看日志：\n\n**可以看到，设置ClickListener之后：**\n\n*  MyView直接由一个不可点击的控件变成了可点击控件，isClickable返回true。\n*  ACTION_DOWN和ACTION_UP事件都发生了。\n*  Touch事件先于Click事件发生。\n\n\n我们看到TouchListener的onTouch方法是有返回值，而且默认返回为false，我们将其改为true，然后点击MyView看日志：\n\n\n**可以看到，多次点击MyView后，Click方法没有执行，即onTouch事件返回true时，相当于屏蔽了click事件的发生**\n\n## View源码分析 ##\n\n根据上面所获得的一系列结论，我们去看View中关于事件分发的两个方法dispatchTouchEvent和onTouchEvent。\n\n\n\n> 首先看dispatchTouchEvent，因为首先执行的也是这个方法\n\n### API 注释 ###\n\n> /**\n     * Pass the touch screen motion event down to the target view, or this\n     * view if it is the target.\n     *\n     * @param event The motion event to be dispatched.\n     * \n     * @return True if the event was handled by the view, false otherwise.\n     */\n\n从注释可以看到，这个方法返回true就是当前view要处理此次事件。\n\n### dispatchTouchEvent源码（截取主要内容） ###\n\n    public boolean dispatchTouchEvent(MotionEvent event) {      \n        boolean result = false;        \n        if (onFilterTouchEventForSecurity(event)) {\n            //noinspection SimplifiableIfStatement\n            ListenerInfo li = mListenerInfo;\n            if (li != null && li.mOnTouchListener != null\n                    && (mViewFlags & ENABLED_MASK) == ENABLED\n                    && li.mOnTouchListener.onTouch(this, event)) {\n                result = true;\n            }\n\n            if (!result && onTouchEvent(event)) {\n                result = true;\n            }\n        }\n\n        \n        return result;\n    }\n\n**可以看到，这里默认的返回值默认是false**\n\n* 首先，onFilterTouchEventForSecurity方法检测，点击事件是否确实发生在当前view上，如果是的话，view就会处理当前点击事件，否则的话就直接返回false不去处理此次事件。\n* 接着，当view的touchListener不为null,且View是enable，并且touchListener的onTouch方法返回true时，result=true,这样下面的if语句中onTouchEvent方法就不会执行，这样onClick方法就不会调用了，这也和之前测试的结果一致。\n\n但是**正常情况下，onTouch方法是返回false**的，所以下面就会执行到onTouEvent方法中去了。\n\n\n### onTouchEvent源码（截取） ###\n\n    public boolean onTouchEvent(MotionEvent event) {\n        final float x = event.getX();\n        final float y = event.getY();\n        final int viewFlags = mViewFlags;\n        final int action = event.getAction();\n\n\n        //view不是enable时，也会消耗touch事件，只是就此返回，不会进入\n        //到performClick()方法中\n        if ((viewFlags & ENABLED_MASK) == DISABLED) {\n            if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {\n                setPressed(false);\n            }\n            // A disabled view that is clickable still consumes the touch\n            // events, it just doesn't respond to them.\n            return (((viewFlags & CLICKABLE) == CLICKABLE\n                    || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)\n                    || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);\n        }\n\n        if (mTouchDelegate != null) {\n            if (mTouchDelegate.onTouchEvent(event)) {\n                return true;\n            }\n        }\n\n        if (((viewFlags & CLICKABLE) == CLICKABLE ||\n                (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) ||\n                (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {\n            switch (action) {\n                case MotionEvent.ACTION_UP:\n                    boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;\n                    if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {\n                        // take focus if we don't have it already and we should in\n                        // touch mode.\n                        boolean focusTaken = false;\n                        if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {\n                            focusTaken = requestFocus();\n                        }\n                            // Only perform take click actions if we were in the pressed state\n                            if (!focusTaken) {\n                                // Use a Runnable and post this rather than calling\n                                // performClick directly. This lets other visual state\n                                // of the view update before click actions start.\n                                if (mPerformClick == null) {\n                                    mPerformClick = new PerformClick();\n                                }\n                                if (!post(mPerformClick)) {\n                                    performClick();\n                                }\n                            }\n                    }\n                    break;\n            }\n            //switch完毕后，最终会返回true\n            return true;\n        }\n        //如果click，longclick以及contextClickable都为false时，返回false\n        return false;\n    }\n\n\n\n**可以看到，一个正常的veiw（即enable时），存在点击事件时，在ACTION_UP的时候，最终会进入performclick()这个方法中去**\n\n可以再看一下，performanceclick方法的实现\n\n    public boolean performClick() {\n        final boolean result;\n        final ListenerInfo li = mListenerInfo;\n        if (li != null && li.mOnClickListener != null) {\n            playSoundEffect(SoundEffectConstants.CLICK);\n            li.mOnClickListener.onClick(this);\n            result = true;\n        } else {\n            result = false;\n        }\n\n        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);\n        return result;\n    }\n\n最终会执行onClickListener中的onClick方法，也就是平常我们去实现的那个方法。\n\n**同时，也可以看到可以clickable,longclickable以及contextclickable中只要有一个为true，那么在switch最后也会返回true，这样返回到上面的dispatchTouchEvent方法，返回result也为true，即完整的消耗（处理）了此次touch事件**。\n\n这里可以自己去看一下源码，整体结构上就是一旦进入if语句内部，switch执行完毕后，return true；\n\n***当然，如果clickable,longclickable以及contextclickable这三个都为false时，就不会进入if语句，直接返回为false，dispatchTouchEvent方法的返回也为false，即表示没有处理此次touch事件***\n\n\n好了，这样终于理清了View(不包括ViewGroup)的事件分发机制。\n\n> 最终得出下面结论：\n\n**View接收到Touch事件时各个方法执行顺序**\n\nonTouch-->onTouchEvent-->onClick  \n\n**onTouch默认返回false，返回true时后续事件无法执行**\n\n**dispatchTouchEvent返回true表示处理了touch事件，返回结果受onTouchEvent方法影响**\n\n**onTouchEvent返回true表示已消耗touch事件，否则的话不消耗。**\n\n**view enable属性的true和false，不能完全决定touch事件的传递，还得考虑其listener**\n\n\n\n***","tags":["Android Touch 事件分发"],"categories":["Android 基础"]},{"title":"2016 booklist","url":"%2F2016%2F03%2F01%2F2016-booklist%2F","content":"\n- 大仲马-基督山伯爵 Done\n- 韩寒-One 系列 Done\n- 郭敬明-夏至未至 Done\n- 吴承恩-西游记 Done","tags":["读书"]},{"title":"你的生活会变成什么样子","url":"%2F2013%2F08%2F19%2F%E4%BD%A0%E7%9A%84%E7%94%9F%E6%B4%BB%E4%BC%9A%E5%8F%98%E6%88%90%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%2F","content":"\n\n在北京上学四年，毕业后才发现，原来这里真的很热。\n\n那天在微博上看到一个段子，感觉挺搞笑。说是某市高考状元填报志愿，所填的第一志愿是“北京有空调大学”，其后依次才是xx大学（传说中的国内名牌大学）。这当然只是调侃北京的天气，故事的真假倒是其次。但北京的热真是快到让人无法忍受的地步了。\n\n<!--more-->\n\n夜里实在是太热，蚊子又多，所以决定放弃早睡，23:00爬起来，打开电脑开始继续看《nikita》。MaggieQ打架的身影依旧那么性感，虽然鱼尾纹已经爬上了眼角，只是情节的发展真是让我又有了睡意，可是我躺下之后在汗水和蚊子的摧残下又一次爬了起来。点开新浪体育，时间才是六月份，欧洲五大联赛正在休息，也没啥球赛可看。继续瞎点，打开了好久没上的人人，决定去看看那些好久没见的同学们现在都是什么样子了。看到的第一条状态是关于小时代吐槽的日志，我点进去大概看了几眼就叉掉了，都是一些车轱辘话，无非是对电影里各种炫富的不满与嫉妒。只是，我不明白当初《折纸时代》出版的时候，没有人出来说小说炫富，而一部电影的却引起了那么针锋相对的网络骂战。第一次看《小时代》是大三那年的国庆节，那时候找了一个兼职，每天差不多要坐三个小时的地铁，趁着无聊就用手机开始看这部在手机SD卡里放了快半年的电子书。其实，第一次看到我几乎没怎么记住故事情节，只是深刻的记住了四个女主人公的名字“顾里，林萧，南湘，唐宛如”。还有如如那句剽悍的“看看看！我的奶有什么好看的！”。曾经一度以为，在上海，人们过得就是那样的生活。LV,GUCCI,哈根达斯……这些东西在他们的生活中，就如我们每天要卖的一次性塑料袋，雪糕一般平凡。后来，我明白其实不是那样，小说里的那些东西叫做奢侈品。大四毕业的时候，终于等到了《刺金时代》，作为结局小四再次延续了以往的风格，除了林萧之外的所有人竟然在上海那场著名的静安区大火中丧生了。死亡总是能引起人们无限的遐想和追忆，我时常在想如果小说里的那些主人公们没有死，后来会怎样。我喜欢小时代里的那些人不记仇，无论今天说了什么或做了什么，到了明天，依旧会开着玩笑做彼此最好的依靠。\n\n \n\n鼠标继续滚动，看到的一条状态让我停了下来。倒不是内容有多么的吸引人，而是下面的定位信息“在北纬40.44° 西经79.92°”。而发这条状态的人我认识，大一时我们曾是同一个社团的。我们社团叫“真爱行动部”，其实就是志愿者社团的别称。现在想来，那时的她真的毫无特别之处，没有倾国倾城的容貌，也没有可以倾倒众生的气质，只知道她学习很好，是他们专业的第一名。在后来多次的共事中也没发现什么特别之处。只是此刻的她，身处大洋彼岸的Carnegie Mellon University里拍下来一张张在我看来完全可以秒杀国内二流女明星的写真照，完全一副女神的姿态。点到她的主页继续看，她来到这个国度已然有一年的时间了。个人相册里是各种各样她在异国的生活学习记录。看着那些在她灿烂笑脸下映衬的国外大学风光，我有那么一丝的羡慕嫉妒没有恨。那一刻我突然在想，为什么彼此的生活相差这么大。倒不是真的想像她那样留学在外，体验异国的生活。从小到大在我的梦想里从来没有出国这个字眼。我只是对自己现在的状态有些不满。突然觉得一件事情，做了，失败了，总比懒得去做或懒得去想强！“懒”是比“怕”更糟糕的一种状态。\n\n有段时间，我一直有一种矛盾的想法。上学时，老师教育说要通过自己的努力改变命运，于是我们听老师的话，努力学习，决定用知识改变命运。我们不怕艰辛，不抛弃，不放弃，为了所谓的梦想奋斗。只是，在某一个瞬间我会想，我们这么拼命到底是在改变命运，还是说一切早已命中注定，我们所做的一切，无论是不怕失败的尝试，还是大彻大悟的重头再来……，都只不过是按照命运早已安排好的轨迹在前行。\n\n每当无聊的时候我都会到她的人人主页上看看，除了欣赏一下女神在异国的风采之外。还会提醒自己，其实生活中的很多事情是我们无法控制的，付出了不一定有收获，但是不付出，就什么都没有。在我们成长的道路上，机遇是一件很要的事情。\n\n看不清远方模糊的事，就做好手边清楚的事。这是我早就明白的道理，只是在纷纷扰扰的杂乱生活中被我遗忘了。所以，无论生活怎样，总应该有一些不会被抛弃的原则和信念一直被铭记着。就像女神一样，不是用来娶回家当老婆的，当然也不一定娶得到，但依旧会被怀念很久很久，因为，在这个世界上有一种姑娘是用来励志的，比如女神！那不是YY，是一种可以让我们在迷茫或无奈时依旧能够勇往直前的信念和力量。\n\n \n\n \n\n上面的内容是我在三个月之前写的。现在想来，那真是一段无法形容的日子。\n\n在过去的这个夏天最炎热的时候，不知怎的，我误以为自己得了抑郁症。对生活有一些消极。我用了一个没有答案的问题把QQ空间加密了。我怕自己会说一些疯狂的话。免得造成一些大家的误解。开始逃避许多东西。现在想来，那完全是对安于现状的烦躁与不安。我不是崔永元，抑郁症是一种高级的病，像我这种凡人得不起。\n\n九月初开学的时候，我接了两个电话。一个是那个睡神打来的，他开始新的大学生活。一想到在大学里留了那么多的遗憾，对现在的他完全是嫉妒啊。一个是和我小时候撒了尿和泥玩的发小打来的。他说他离婚了，打算来北京打工，问我干啥好。我尽我所能的给他讲了一些北京的现状和需要面对的压力以及一些建议。然后在他的感激不尽中挂了电话。10年大二寒假回家的时候，还喝了他们的喜酒，当初看着那么幸福的一对怎么就离了呢。原来，有些人在一起了，却没走到最后。真心希望所有天下有情人生生世世相亲相爱。\n\n好奇心就像魔法一样，我用了一个周末两天的时间看完了被网友们褒贬不一的两部《小时代》。想看看到底有多烂或者说多好。除去别的不说，就单从小说翻拍电影来说，值得一看。比《奋斗》电影版拍的好。觉得《青木时代》里最后打雪仗的情景是那么的温馨，无论彼此间有怎样的深仇大恨或阴谋算计，那一刻的他们是那么的单纯，单纯的玩闹。一想到后来，他们要面对的一切，感觉小四挺残忍的。\n\n这里的秋天是一年中风景最好的时刻。大街上到处都是戴着墨镜、穿着风衣和紧身牛仔裤的姑娘们，风一吹，看着那在风中凌乱的长发各个都是女王的范儿。比起夏天那让人无法直视的小短裙……，现在的风景是多么的好。这个季节的天气不冷不热，时而还刮点儿大风，然后在某个早晨一觉醒来，发现树上的叶子都没有了。\n\n那些曾经在QQ空间很活跃的朋友们，都不知不觉的消失了。只剩下那么几个人偶尔上来喘口气，证明自己还活着。这样也好，每个人的内心深处总是渴望有一片宁静地方，现在的这里很好。\n\n我依旧喜欢看《奋斗》，无论是小说还是电视剧。总觉得那个故事是那么的有意思，总觉得米莱是这个世界上最好的姑娘！\n\n “年轻的时候，不该什么都不想，也不能想太多。想得太多会毁了你，我相信这话……成功路上最心酸的是要耐得住寂寞、熬得住孤独，总有那么一段路是你一个人在走，一个人坚强和勇敢。也许这个过程要持续很久，但如果你挺过去了，最后的成功就属于你。”《中国合伙人》里这句话真是说的太好了。\n\n时间，从不曾给予我们毫无顾忌的任性，生活，也从不曾带给我们满是绝望的恐惧，回忆，更是从不曾留给我们颓废茫然的理由。人不能总是活在回忆里。我们所经历所有事情都是有意义的。\n\n \n\n生活，会变成我们想象的样子！\n\n\n","tags":["生活，理想"],"categories":["诗与远方"]},{"title":"很久很久之前","url":"%2F2013%2F02%2F19%2F%E5%BE%88%E4%B9%85%E5%BE%88%E4%B9%85%E4%B9%8B%E5%89%8D%2F","tags":["生活，理想"],"categories":["诗与远方"]}]