<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="前言关于 Android Handler 机制更多的理解和思考。 多年之前曾写过一篇 终于明白了Handler的运行机制  的博文。现在回过头来再看，其理解之肤浅和偏差实在是惨不忍睹。因此，这里就 Android 最核心的 Handler 机制做一次新的分析和理解。">
<meta property="og:type" content="article">
<meta property="og:title" content="Handler Again">
<meta property="og:url" content="http://yoursite.com/2021/04/17/Handler-Again/index.html">
<meta property="og:site_name" content="诗与远方">
<meta property="og:description" content="前言关于 Android Handler 机制更多的理解和思考。 多年之前曾写过一篇 终于明白了Handler的运行机制  的博文。现在回过头来再看，其理解之肤浅和偏差实在是惨不忍睹。因此，这里就 Android 最核心的 Handler 机制做一次新的分析和理解。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-17T14:35:26.000Z">
<meta property="article:modified_time" content="2021-08-22T13:21:45.025Z">
<meta property="article:author" content="九尾灵狐">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Handler">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2021/04/17/Handler-Again/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Handler Again | 诗与远方</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">诗与远方</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/REBOOTERS" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/17/Handler-Again/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="九尾灵狐">
      <meta itemprop="description" content="人生不止眼前的苟且，还有诗与远方和田野">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="诗与远方">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Handler Again
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 22:35:26" itemprop="dateCreated datePublished" datetime="2021-04-17T22:35:26+08:00">2021-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-22 21:21:45" itemprop="dateModified" datetime="2021-08-22T21:21:45+08:00">2021-08-22</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>31k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>29 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于 Android Handler 机制更多的理解和思考。</p>
<p>多年之前曾写过一篇 <a href="/2017/01/15/%E7%BB%88%E4%BA%8E%E6%98%8E%E7%99%BD%E4%BA%86Handler%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/" title="终于明白了Handler的运行机制">终于明白了Handler的运行机制</a>  的博文。现在回过头来再看，其理解之肤浅和偏差实在是惨不忍睹。因此，这里就 Android 最核心的 Handler 机制做一次新的分析和理解。</p>
<a id="more"></a>

<h2 id="Handler-N-问"><a href="#Handler-N-问" class="headerlink" title="Handler N 问"></a>Handler N 问</h2><p>鉴于 Handler 的使用已经是非常熟悉了，使用方式就不再赘述。本文就从一些对 Handler 的问题出发，通过对这些问题的解答再次探索 Handler 的奥妙所在。</p>
<p><strong>以下所有 Android Framework 层 Handler 相关的源码均以 Android SDK 30 (Android 11 R) 版本为准</strong> </p>
<p><em>有些问题可能看起来很简，这里提出是因为对这个问题的答案之前理解有偏差或完全错误，因此在此做一次更正</em></p>
<h3 id="发送的消息到底会在哪里执行？"><a href="#发送的消息到底会在哪里执行？" class="headerlink" title="发送的消息到底会在哪里执行？"></a>发送的消息到底会在哪里执行？</h3><figure class="highlight java"><figcaption><span>dispatchMessage</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道在 Looper 的 loop 方法，每当获取到一个 Message 消息的时候，就会调用 <code>msg.target.dispatchMessage(msg)</code> 开始上述方法的调用。因此，loop 方法执行的线程就是 <code>Message</code> 被处理的线程。</p>
<p>我们看下面的例子，我们分别创建了两个 Handler。 h 是用主线程的 Looper。subHandler 是通过 HandlerThread 的机制在子线程创建的。<br>然后我们分别在子线程和 UI  线程向这两个 Handler 发送了消息，并在其 dispatchMessage 方法中打印线程名及 Message 的信息来看看消息是在哪里执行的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">        viewBinding.handler.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> h = Handler(Looper.getMainLooper()) &#123; msg -&gt;</span><br><span class="line">                Log.e(</span><br><span class="line">                    TAG,</span><br><span class="line">                    <span class="string">&quot;handleMessage() called in <span class="subst">$&#123;Thread.currentThread().name&#125;</span> with: msg = <span class="variable">$msg</span>&quot;</span></span><br><span class="line">                )</span><br><span class="line">                <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> handlerThread = HandlerThread(<span class="string">&quot;subThread&quot;</span>)</span><br><span class="line">            handlerThread.start()</span><br><span class="line">            <span class="keyword">val</span> subHandler = Handler(handlerThread.looper) &#123; msg -&gt;</span><br><span class="line">                Log.e(</span><br><span class="line">                    TAG,</span><br><span class="line">                    <span class="string">&quot;handleMessage() called in <span class="subst">$&#123;Thread.currentThread().name&#125;</span> with: msg = <span class="variable">$msg</span>&quot;</span></span><br><span class="line">                )</span><br><span class="line">                <span class="comment">// 为了方便调试多次方法，正常情况下，用完后记得立即关闭</span></span><br><span class="line"><span class="comment">//                handlerThread.quitSafely()</span></span><br><span class="line">                <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread &#123;</span><br><span class="line">                <span class="keyword">val</span> msg1 = Message.obtain()</span><br><span class="line">                msg1.what = <span class="number">1000</span></span><br><span class="line">                msg1.obj = <span class="string">&quot;1000&quot;</span></span><br><span class="line">                h.sendMessage(msg1)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> msg2 = Message.obtain()</span><br><span class="line">                msg2.what = <span class="number">2000</span></span><br><span class="line">                msg2.obj = <span class="string">&quot;2000&quot;</span></span><br><span class="line">                subHandler.sendMessage(msg2)</span><br><span class="line">            &#125;.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            h.sendEmptyMessageDelayed(<span class="number">100</span>,<span class="number">1000</span>)</span><br><span class="line">            subHandler.sendEmptyMessageDelayed(<span class="number">200</span>, <span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>为了让 子线程的消息优先处理，这里主线程发送消息 delay 了 1000ms.</p>
<blockquote>
<p>Logcat</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">E: handleMessage() called in subThread with: msg = &#123; when=0 what=2000 obj=2000 target=android.os.Handler &#125;</span><br><span class="line">E: handleMessage() called in main with: msg = &#123; when=-5ms what=1000 obj=1000 target=android.os.Handler &#125;</span><br><span class="line">E: handleMessage() called in subThread with: msg = &#123; when=-2ms what=200 target=android.os.Handler &#125;</span><br><span class="line">E: handleMessage() called in main with: msg = &#123; when=-2ms what=100 target=android.os.Handler &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">E: handleMessage() called in subThread with: msg = &#123; when=0 what=2000 obj=2000 target=android.os.Handler &#125;</span><br><span class="line">E: handleMessage() called in main with: msg = &#123; when=-2ms what=1000 obj=1000 target=android.os.Handler &#125;</span><br><span class="line">E: handleMessage() called in main with: msg = &#123; when=-4ms what=100 target=android.os.Handler &#125;</span><br><span class="line">E: handleMessage() called in subThread with: msg = &#123; when=-4ms what=200 target=android.os.Handler &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>向 h 这个 Handler 发送的消息，无论是从主线程还是子线程发送，都是在 main Thread 执行。</li>
<li>向 subHander 这个 Handler 发送到消息，无论是从主线程还是子线程发送，都是在 subThread 执行，即子线程发送的消息不一定要到主线程执行。</li>
</ul>
<p>也就是说消息执行的线程只和创建 Handler 时 Looper 的线程有关，即 Looper.prepare 是在哪个线程调用的，MessageQueue 以及后续 <code>dispatchMessage</code> 的调用都将在该线程。</p>
<p>这里消息被处理的顺序也很有意思，在子线程发送的两个消息，subThread 总是优先处理消息，即便他是后执行的。可以先想一下原因，后面会有解释。</p>
<h3 id="为啥不会阻塞主线程？"><a href="#为啥不会阻塞主线程？" class="headerlink" title="为啥不会阻塞主线程？"></a>为啥不会阻塞主线程？</h3><figure class="highlight java"><figcaption><span>loop</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Looper.loop 方法中取消息的时候，queue.next() 是阻塞操作，那么为什么不会造成主线程卡死呢？（面试经典问题 <strong>为什么主线程的Looper是一个死循环，但是却不会ANR？</strong>）</p>
<p>这个问题细分的话可以由很多点可以讨论，比如 ANR 是什么？在 Android 中哪些情况下会 ANR ？<br>因为死循环，所以 ANR ？ 这个问题本身的问法可能就有点问题。<br>具体细节可以参考知乎问题 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/34652589">Android中为什么主线程不会因为Looper.loop()里的死循环卡死？</a>。里面的每一个回答基本都值得一看，从不同角度阐述了对这个问题的理解。</p>
<p>我们可以仔细看一下 <code>MessageQueue</code> 的实现.</p>
<figure class="highlight java"><figcaption><span>MessageQueue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis); <span class="comment">// ①</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE); <span class="comment">// ②</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg; <span class="comment">// ③</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>; <span class="comment">// ④</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的关键是 <code>nativePollOnce</code> 这个 native 方法的调用。 按照 <a target="_blank" rel="noopener" href="https://www.kancloud.cn/alex_wsc/android-deep3/416265">深入理解Android 卷 三</a> 一文的解读。当 nextPollTimeoutMillis 等于 0 的是这里会立即返回，等于 -1 的时候会一直阻塞等待，直到有事件发生为止。</p>
<p>因此，每次调用 next 方法时，由于 nextPollTimeoutMillis = 0，会立即进入 <code>synchronized</code> 代码块去获取消息，这里就有以下这些情况。</p>
<ul>
<li>获取到了一条消息 message<ul>
<li>message 执行的时间 when 大于等于当前时间，那就立刻返回这条消息给 Looper.loop 方法去消费。</li>
<li>message 执行的时间 when 小于当前时间，那么就和当前时间算一个时间差，并赋值给 nextPollTimeoutMillis</li>
</ul>
</li>
<li>没有获取到消息 <ul>
<li>nextPollTimeoutMillis 设置为 -1</li>
</ul>
</li>
<li>已经执行 Looper.quit 方法了，那么就返回一条 null 消息，Looper.loop 拿到 null 也就停止了。</li>
</ul>
<p>到这里就解析通了，面对真实场景，拿到消息时间 OK 就的话返回给 Looper，由 Looper 执行 <code>msg.target.dispatchMessage(msg)</code> ，完成消息相应的逻辑。没有消息就一直等待着。<code>nativePollOnce</code> 是个阻塞操作，但是会释放 CPU 。</p>
<p>那么问题来了，如果 nextPollTimeoutMillis == -1 的情况下，一直在这里阻塞。那么谁来唤醒呢？这就要靠 enqueueMessage 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在最后,如果需要调用 <code>nativeWake(mPtr)</code>，就会唤醒由 <code>nativePollOnce</code> 阻塞的逻辑。一般情况下当有消息处理时，mBlocked 都是 false。 没有消息可以处理（甚至连 IdleHandler 也没有的时候才会设置为 true) 。</p>
<blockquote>
<p>Message next() 从队列中获取并返回下一个消息. </p>
<p>如果队列为空(无返回值), 则该方法将调用 native void nativePollOnce(long, int), 该方法将一直阻塞直到添加新消息为止. 此时,您可能会问nativePollOnce 如何知道何时醒来. 这是一个很好的问题. 当将 Message 添加到队列时, 框架调用 enqueueMessage 方法, 该方法不仅将消息插入队列, 而且还会调用native static void nativeWake(long). </p>
</blockquote>
<blockquote>
<p>nativePollOnce 和 nativeWake 的核心魔术发生在 native 代码中. native MessageQueue 利用名为 epoll 的 Linux 系统调用, 该系统调用可以监视文件描述符中的 IO 事件. nativePollOnce 在某个文件描述符上调用 epoll_wait, 而 nativeWake 写入一个 IO 操作到描述符, epoll_wait 等待. 然后, 内核从等待状态中取出 epoll 等待线程, 并且该线程继续处理新消息. 如果您熟悉 Java 的 Object.wait()和 Object.notify()方法,可以想象一下 nativePollOnce 大致等同于 Object.wait(), nativeWake 等同于 Object.notify(),但它们的实现完全不同: nativePollOnce 使用 epoll, 而 Object.wait 使用 futex Linux 调用. </p>
</blockquote>
<blockquote>
<p>值得注意的是, nativePollOnce 和 Object.wait 都不会浪费 CPU 周期, 因为当线程进入任一方法时, 出于线程调度的目的, 该线程将被禁用(引用Object类的javadoc). 但是, 某些事件探查器可能会错误地将等待 epoll 等待(甚至是 Object.wait)的线程识别为正在运行并消耗 CPU 时间, 这是不正确的. 如果这些方法实际上浪费了 CPU 周期, 则所有空闲的应用程序都将使用 100％ 的 CPU, 从而加热并降低设备速度.</p>
</blockquote>
<h3 id="为什么使用-SystemClock-uptimeMillis-？"><a href="#为什么使用-SystemClock-uptimeMillis-？" class="headerlink" title="为什么使用 SystemClock.uptimeMillis() ？"></a>为什么使用 SystemClock.uptimeMillis() ？</h3><p>如果你足够仔细的话，你会发现，在 Handler 机制中，关于 Message.when 这个属性的赋值以及和这个属性的比较时，获取时间的方法都是 <code>SystemClock.uptimeMillis()</code> 。那么这个事件和我们非常熟悉的 <code>System.currentTimeMillis()</code> 有什么区别呢?</p>
<figure class="highlight java"><figcaption><span>SystemClock.uptimeMillis()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns milliseconds since boot, not counting time spent in deep sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> milliseconds of non-sleep uptime since boot.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CriticalNative</span></span><br><span class="line"><span class="function"><span class="keyword">native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">uptimeMillis</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><figcaption><span>System.currentTimeMillis</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the current time in milliseconds.  Note that</span></span><br><span class="line"><span class="comment"> * while the unit of time of the return value is a millisecond,</span></span><br><span class="line"><span class="comment"> * the granularity of the value depends on the underlying</span></span><br><span class="line"><span class="comment"> * operating system and may be larger.  For example, many</span></span><br><span class="line"><span class="comment"> * operating systems measure time in units of tens of</span></span><br><span class="line"><span class="comment"> * milliseconds.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; See the description of the class &lt;code&gt;Date&lt;/code&gt; for</span></span><br><span class="line"><span class="comment"> * a discussion of slight discrepancies that may arise between</span></span><br><span class="line"><span class="comment"> * &quot;computer time&quot; and coordinated universal time (UTC).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the difference, measured in milliseconds, between</span></span><br><span class="line"><span class="comment"> *          the current time and midnight, January 1, 1970 UTC.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.util.Date</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CriticalNative</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>注释很清楚了，<code>SystemClock.uptimeMillis()</code> 返回的系统开机之后累计的 milliseconds。并且在系统处于 deep sleep 的时候不会及时。而 <code>System.currentTimeMillis()</code> 都很熟悉了，这个方法返回的是当前时间与协调世界时 1970 年 1 月 1 日午夜之间的时间差（以毫秒为单位测量）,而且非常依赖操作系统。再有如果手动修改了操作系统的时间，这个值就没有意义了。因此，对于 Handler 已 Message 的时间为序的消费场景（这里简单指所有的同步消息，包含一部消息和屏障消息时就有差异了），是不可靠的。因此，使用了以开机时间的一个计数器这样的时间来作为所有 Message.whne 的时间标准。</p>
<h3 id="Handler-有什么新的变化吗？"><a href="#Handler-有什么新的变化吗？" class="headerlink" title="Handler 有什么新的变化吗？"></a>Handler 有什么新的变化吗？</h3><p>再次读 Handler 的源码，发现的确是有了一些变化，但是不知道是从哪个版本开始的。</p>
<h4 id="构造函数的变化"><a href="#构造函数的变化" class="headerlink" title="构造函数的变化"></a>构造函数的变化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default constructor associates this handler with the &#123;<span class="doctag">@link</span> Looper&#125; for the</span></span><br><span class="line"><span class="comment"> * current thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If this thread does not have a looper, this handler won&#x27;t be able to receive messages</span></span><br><span class="line"><span class="comment"> * so an exception is thrown.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> Implicitly choosing a Looper during Handler construction can lead to bugs</span></span><br><span class="line"><span class="comment"> *   where operations are silently lost (if the Handler is not expecting new tasks and quits),</span></span><br><span class="line"><span class="comment"> *   crashes (if a handler is sometimes created on a thread without a Looper active), or race</span></span><br><span class="line"><span class="comment"> *   conditions, where the thread a handler is associated with is not what the author</span></span><br><span class="line"><span class="comment"> *   anticipated. Instead, use an &#123;<span class="doctag">@link</span> java.util.concurrent.Executor&#125; or specify the Looper</span></span><br><span class="line"><span class="comment"> *   explicitly, using &#123;<span class="doctag">@link</span> Looper#getMainLooper&#125;, &#123;link android.view.View#getHandler&#125;, or</span></span><br><span class="line"><span class="comment"> *   similar. If the implicit thread local behavior is required for compatibility, use</span></span><br><span class="line"><span class="comment"> *   &#123;<span class="doctag">@code</span> new Handler(Looper.myLooper())&#125; to make it clear to readers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，现在创建 Handler 必须显示的提供 Looper 了。原因在上面注释里也解释的很清楚了。Android 官方也是被逼无奈啊。</p>
<h4 id="异步消息的支持"><a href="#异步消息的支持" class="headerlink" title="异步消息的支持"></a>异步消息的支持</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>在之前的版本中，由于构造函数调用的限制，应用层的开发者只能通过 Handler 发送同步消息。mAsynchronous 参数无论用什么方式创建 Handler 都会默认设置为 false。因此在 enqueueMessage 阶段，消息只能是同步的。</p>
<p>现在提供了 createAsync 方法，mAsynchronous 会设置为 true。也就是说我们可以发送异步消息了。当然为了兼容性考虑，建议使用 <code>HandlerCompat</code> 创建此类消息。</p>
<p>那么，异步消息有什么用呢？下面就来解释</p>
<h3 id="异步消息、同步消息、屏障消息是啥？"><a href="#异步消息、同步消息、屏障消息是啥？" class="headerlink" title="异步消息、同步消息、屏障消息是啥？"></a>异步消息、同步消息、屏障消息是啥？</h3><p>同步消息和异步消息的区别是通过 <code>msg.setAsynchronous()</code> 方法设置。那么同步消息和异步消息在 next() 当中获取的时候有什么区别呢？这就要说到屏障消息了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Posts a synchronization barrier to the Looper&#x27;s message queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Message processing occurs as usual until the message queue encounters the</span></span><br><span class="line"><span class="comment"> * synchronization barrier that has been posted.  When the barrier is encountered,</span></span><br><span class="line"><span class="comment"> * later synchronous messages in the queue are stalled (prevented from being executed)</span></span><br><span class="line"><span class="comment"> * until the barrier is released by calling &#123;<span class="doctag">@link</span> #removeSyncBarrier&#125; and specifying</span></span><br><span class="line"><span class="comment"> * the token that identifies the synchronization barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method is used to immediately postpone execution of all subsequently posted</span></span><br><span class="line"><span class="comment"> * synchronous messages until a condition is met that releases the barrier.</span></span><br><span class="line"><span class="comment"> * Asynchronous messages (see &#123;<span class="doctag">@link</span> Message#isAsynchronous&#125; are exempt from the barrier</span></span><br><span class="line"><span class="comment"> * and continue to be processed as usual.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This call must be always matched by a call to &#123;<span class="doctag">@link</span> #removeSyncBarrier&#125; with</span></span><br><span class="line"><span class="comment"> * the same token to ensure that the message queue resumes normal operation.</span></span><br><span class="line"><span class="comment"> * Otherwise the application will probably hang!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A token that uniquely identifies the barrier.  This token must be</span></span><br><span class="line"><span class="comment"> * passed to &#123;<span class="doctag">@link</span> #removeSyncBarrier&#125; to release the barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>屏障消息有两个特点，1. 其 target 为 null 2. message.what = token 。注释已经解析的很清楚了，屏障消息会屏蔽同步消息的执行，优先会执行异步消息。除非同步屏障被移除了。移除的时候，就要依赖添加的时候生成的 token。也就是说通过同步屏障的机制，给 Handler 消息执行机制提供了一种优先级的概念。</p>
<figure class="highlight java"><figcaption><span>MessageQueue.next()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prevMsg = msg;</span><br><span class="line">        msg = msg.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在 next() 方法中遇到 target 为 null 的同步屏障消息，遇到同步消息会一直往后找，直到找到异步消息或到链表末尾。</p>
<h3 id="HandlerThread-是啥？"><a href="#HandlerThread-是啥？" class="headerlink" title="HandlerThread 是啥？"></a>HandlerThread 是啥？</h3><p>UI 线程在 ActivityThread.main 方法中创建了 Looper并开始了 loop 循环，保证了 UI 线程 Handler 正常运行。为了方便在子线程中方便的使用 Handler 机制，官方简单封装 Looper 的创建过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mPriority;</span><br><span class="line">    <span class="keyword">int</span> mTid = -<span class="number">1</span>;</span><br><span class="line">    Looper mLooper;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a HandlerThread.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priority The priority to run the thread at. The value supplied must be from </span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> android.os.Process&#125; and not from java.lang.Thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Call back method that can be explicitly overridden if needed to execute some</span></span><br><span class="line"><span class="comment">     * setup before Looper loops.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method returns the Looper associated with this thread. If this thread not been started</span></span><br><span class="line"><span class="comment">     * or for any reason isAlive() returns false, this method will return null. If this thread</span></span><br><span class="line"><span class="comment">     * has been started, this method will block until the looper has been initialized.  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The looper.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HandlerThread 本质上还是一个 Thread。在其内部使用 wait 和 notify 机制。保证了在调用线程的 start 方法后，一定可以获取的到正常的和当前线程绑定的 Looper。</p>
<h3 id="利用-Handler-机制在性能优化时可以做哪些事情？"><a href="#利用-Handler-机制在性能优化时可以做哪些事情？" class="headerlink" title="利用 Handler 机制在性能优化时可以做哪些事情？"></a>利用 Handler 机制在性能优化时可以做哪些事情？</h3><p>这个最有名的就是 <a target="_blank" rel="noopener" href="https://github.com/markzhai/AndroidPerformanceMonitor">BlockCanary</a>了。</p>
<p>利用 Looper.loop </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//默认为null，可通过setMessageLogging()方法来指定输出，用于debug功能</span></span><br><span class="line">        Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//事件分发之前的时间T1</span></span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//事件分发之后的时间T2</span></span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在消息处理的前后进行了日志打印，如果T2-T1的时间差大于某个阀值,就可以判断发生了卡顿。</p>
<p>我们可以个之前创建的两个 Handler 添加自定义的 Logger .<code>handlerThread.looper.setMessageLogging(LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;))</code></p>
<details>
<summary>
日志输出
</summary>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.ViewRootImpl$ViewRootHandler) &#123;b1ebc0b&#125; android.view.View$PerformClick@b011f92: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.ViewRootImpl$ViewRootHandler) &#123;b1ebc0b&#125; android.view.View$PerformClick@b011f92</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.os.Handler) &#123;aa95e90&#125; null: 2000</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.ViewRootImpl$ViewRootHandler) &#123;b1ebc0b&#125; android.view.View$UnsetPressedState@2b3dd60: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.os.Handler) &#123;aa95e90&#125; null</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.ViewRootImpl$ViewRootHandler) &#123;b1ebc0b&#125; android.view.View$UnsetPressedState@2b3dd60</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.os.Handler) &#123;84d5389&#125; null: 1000</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.os.Handler) &#123;84d5389&#125; null</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.os.Handler) &#123;e85c3af&#125; android.graphics.animation.-$$Lambda$awqPSgriNRe12PWP0zkpAtPsfV4@8edd3bc: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.os.Handler) &#123;e85c3af&#125; android.graphics.animation.-$$Lambda$awqPSgriNRe12PWP0zkpAtPsfV4@8edd3bc</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.os.Handler) &#123;32e9f45&#125; android.graphics.animation.-$$Lambda$awqPSgriNRe12PWP0zkpAtPsfV4@3bf069a: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.os.Handler) &#123;32e9f45&#125; android.graphics.animation.-$$Lambda$awqPSgriNRe12PWP0zkpAtPsfV4@3bf069a</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.os.Handler) &#123;174ebcb&#125; android.graphics.animation.-$$Lambda$awqPSgriNRe12PWP0zkpAtPsfV4@8a26fa8: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.os.Handler) &#123;174ebcb&#125; android.graphics.animation.-$$Lambda$awqPSgriNRe12PWP0zkpAtPsfV4@8a26fa8</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.os.Handler) &#123;f1eeac1&#125; android.graphics.animation.-$$Lambda$awqPSgriNRe12PWP0zkpAtPsfV4@df6f266: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.os.Handler) &#123;f1eeac1&#125; android.graphics.animation.-$$Lambda$awqPSgriNRe12PWP0zkpAtPsfV4@df6f266</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.view.Choreographer$FrameHandler) &#123;ff72a60&#125; android.view.Choreographer$FrameDisplayEventReceiver@1667b19</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.os.Handler) &#123;e479a7&#125; android.graphics.animation.-$$Lambda$awqPSgriNRe12PWP0zkpAtPsfV4@c82de54: 0</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.os.Handler) &#123;e479a7&#125; android.graphics.animation.-$$Lambda$awqPSgriNRe12PWP0zkpAtPsfV4@c82de54</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.os.Handler) &#123;aa95e90&#125; null: 200</span><br><span class="line">D/ActivityThread: &gt;&gt;&gt;&gt;&gt; Dispatching to Handler (android.os.Handler) &#123;84d5389&#125; null: 100</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.os.Handler) &#123;84d5389&#125; null</span><br><span class="line">D/ActivityThread: &lt;&lt;&lt;&lt;&lt; Finished to Handler (android.os.Handler) &#123;aa95e90&#125; null</span><br></pre></td></tr></table></figure>
</details>

<p>可以看到在处理代码发送的消息之前，会优先执行 Choreographer$FrameHandler 的消息，毕竟点击事件也是由其触发的。同时由于 UI 线程要处理 UI 绘制相关的内容（点击 Button 会有动画），因此，即便在子线程中 message.what = 2000 的消息是后发送的，他也是优先执行。毕竟他所在的 Handler 是子线程创建的，没有其他消息需要处理。</p>
<h3 id="IdleHandler-有什么用？-原理是啥"><a href="#IdleHandler-有什么用？-原理是啥" class="headerlink" title="IdleHandler 有什么用？ 原理是啥"></a>IdleHandler 有什么用？ 原理是啥</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback interface for discovering when a thread is going to block</span></span><br><span class="line"><span class="comment"> * waiting for more messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when the message queue has run out of messages and will now</span></span><br><span class="line"><span class="comment">     * wait for more.  Return true to keep your idle handler active, false</span></span><br><span class="line"><span class="comment">     * to have it removed.  This may be called if there are still messages</span></span><br><span class="line"><span class="comment">     * pending in the queue, but they are all scheduled to be dispatched</span></span><br><span class="line"><span class="comment">     * after the current time.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是在 MessageQueue 中没有消息，等待消息的时候，会执行 IdleHanlder (其实叫做 IdleMessage 可能更贴切)。 实现原理就很简了，在 next() 方法中取不到消息的时候，就会检查是否有有可执行的 IdleHandler ,有的话就执行。</p>
<h3 id="ThreadLocal-有啥用？原理是啥"><a href="#ThreadLocal-有啥用？原理是啥" class="headerlink" title="ThreadLocal 有啥用？原理是啥"></a>ThreadLocal 有啥用？原理是啥</h3><p>ThreadLocal 本质上和 Handler 不是强相关的东西。通过以上的问题，我们已经了解了 <code>线程-Handler-Looper-MessageQueue</code> 一对一绑定的关系。而这其中最关键的就是 Looper 的创建，毕竟可以在任意一个地方调用 Looper.prepare 创建 Looper（随之内部会自动创建 MessageQueue),并由此创建 Handler。因此，要保证这个一对一的关系，其实就是要保证线程和 Looper 的一对一关系，就是在不同线程内的 Looper 是唯一的。</p>
<p>这其实就是如何在线程内部维护一个变量的问题。因此，使用 ThreadLocal 便可以解决问题。</p>
<figure class="highlight java"><figcaption><span>ThreadLocal 使用事例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">viewBinding.threadLocal.setOnClickListener &#123;</span><br><span class="line">    val tag = <span class="string">&quot;threadLocal&quot;</span></span><br><span class="line"></span><br><span class="line">    val threadLocal = ThreadLocal&lt;Int&gt;()</span><br><span class="line">    val threadLocal2 = ThreadLocal&lt;String&gt;()</span><br><span class="line">    val threadLocal3 = ThreadLocal&lt;Boolean&gt;()</span><br><span class="line"></span><br><span class="line">    threadLocal.set(-<span class="number">1</span>)</span><br><span class="line">    threadLocal2.set(<span class="keyword">this</span>::class.java.name)</span><br><span class="line"></span><br><span class="line">    <span class="function">fun <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.e(tag, <span class="string">&quot;$&#123;Thread.currentThread().name&#125; : threadLocal = $&#123;threadLocal.get()&#125;&quot;</span>)</span><br><span class="line">        Log.e(tag, <span class="string">&quot;$&#123;Thread.currentThread().name&#125; : threadLocal2 = $&#123;threadLocal2.get()&#125;&quot;</span>)</span><br><span class="line">        Log.e(tag, <span class="string">&quot;$&#123;Thread.currentThread().name&#125; : threadLocal3 = $&#123;threadLocal3.get()&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val t1 = Thread &#123;</span><br><span class="line">        threadLocal.set(<span class="number">1</span>)</span><br><span class="line">        threadLocal2.set(<span class="string">&quot;22222&quot;</span>)</span><br><span class="line">        threadLocal3.set(<span class="keyword">true</span>)</span><br><span class="line">        printAll()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val t2 = Thread &#123;</span><br><span class="line">        threadLocal.set(<span class="number">2</span>)</span><br><span class="line">        threadLocal3.set(<span class="keyword">false</span>)</span><br><span class="line">        printAll()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line">    printAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看一下输出结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E/threadLocal: Thread-2 : threadLocal = 1</span><br><span class="line">E/threadLocal: Thread-2 : threadLocal2 = 22222</span><br><span class="line">E/threadLocal: Thread-2 : threadLocal3 = true</span><br><span class="line">E/threadLocal: Thread-3 : threadLocal = 2</span><br><span class="line">E/threadLocal: Thread-3 : threadLocal2 = null</span><br><span class="line">E/threadLocal: Thread-3 : threadLocal3 = false</span><br><span class="line">E/threadLocal: main : threadLocal = -1</span><br><span class="line">E/threadLocal: main : threadLocal2 = com.engineer.android.mini.ui.behavior.BehaviorActivity</span><br><span class="line">E/threadLocal: main : threadLocal3 = null</span><br></pre></td></tr></table></figure>
<p><em>注意，这里 threadLocal3 默认为 null，因为是对象类型</em> 。可以看到，ThreadLocal 类型的变量在不同线程的内部的更新是互不影响的。这就提供了统一变量在不同线程之间互相隔离互不影响的实现。</p>
<h4 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h4><p>ThreadLocal 本身的实现并不复杂，每一个线程都会有 <code>ThreadLocal.ThreadLocalMap</code> 类型的 threadLocals 成员变量。这个 ThreadLocalMap 顾名思义就是一个 Map。 key 就是当前 ThreadLocal 的实例，值就是 ThreadLocal 泛型对应变量的值。</p>
<h5 id="set-get"><a href="#set-get" class="headerlink" title="set/get"></a>set/get</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Variant of set() to establish initialValue. Used instead</span></span><br><span class="line"><span class="comment"> * of set() in case user has overridden the set() method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread&#x27;s copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h5><p>这篇 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6854573219916021767">Java面试必问：ThreadLocal终极篇</a> 分析，已经很详细了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于 Handler ，通过此次阅读源码又有了一些比较深入的认识和了解。但是学海无涯，尤其是对于作为 Android 基石的 Handler 机制，每一行源码的实现都是非常考究的，因此这里的理解难免有局限性和偏差。但是，知识的学习就是这样，是一个不断累积的过程，在这个过程中认知会升级，会变化，会纠错。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/421330220/answer/1480860373">Android 中为什么需要 Handler?</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/269485733">Android之Handler机制（终极篇）：面试常见问题汇总，解锁大牛的乐趣</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/34652589">Android中为什么主线程不会因为Looper.loop()里的死循环卡死？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiy-for-you/archive/2019/10/20/11707356.html">MessageQueue nativePollOnce 深入分析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kancloud.cn/alex_wsc/android-deep3/416265">深入理解Android 卷 三</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/markzhai/AndroidPerformanceMonitor">BlockCanary</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6854573219916021767">Java面试必问：ThreadLocal终极篇</a></li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div>加个鸡腿呗.</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="九尾灵狐 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="九尾灵狐 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
              <a href="/tags/Handler/" rel="tag"># Handler</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/09/Kotlin-Syntactic-Sugar/" rel="prev" title="Kotlin Syntactic Sugar">
      <i class="fa fa-chevron-left"></i> Kotlin Syntactic Sugar
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/01/Bitmap-Next/" rel="next" title="Bitmap Next">
      Bitmap Next <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler-N-%E9%97%AE"><span class="nav-number">2.</span> <span class="nav-text">Handler N 问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E7%9A%84%E6%B6%88%E6%81%AF%E5%88%B0%E5%BA%95%E4%BC%9A%E5%9C%A8%E5%93%AA%E9%87%8C%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">发送的消息到底会在哪里执行？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E5%95%A5%E4%B8%8D%E4%BC%9A%E9%98%BB%E5%A1%9E%E4%B8%BB%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">为啥不会阻塞主线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-SystemClock-uptimeMillis-%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">为什么使用 SystemClock.uptimeMillis() ？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Handler-%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B0%E7%9A%84%E5%8F%98%E5%8C%96%E5%90%97%EF%BC%9F"><span class="nav-number">2.4.</span> <span class="nav-text">Handler 有什么新的变化吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">2.4.1.</span> <span class="nav-text">构造函数的变化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">2.4.2.</span> <span class="nav-text">异步消息的支持</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E3%80%81%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF%E3%80%81%E5%B1%8F%E9%9A%9C%E6%B6%88%E6%81%AF%E6%98%AF%E5%95%A5%EF%BC%9F"><span class="nav-number">2.5.</span> <span class="nav-text">异步消息、同步消息、屏障消息是啥？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HandlerThread-%E6%98%AF%E5%95%A5%EF%BC%9F"><span class="nav-number">2.6.</span> <span class="nav-text">HandlerThread 是啥？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-Handler-%E6%9C%BA%E5%88%B6%E5%9C%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%97%B6%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85%EF%BC%9F"><span class="nav-number">2.7.</span> <span class="nav-text">利用 Handler 机制在性能优化时可以做哪些事情？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IdleHandler-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F-%E5%8E%9F%E7%90%86%E6%98%AF%E5%95%A5"><span class="nav-number">2.8.</span> <span class="nav-text">IdleHandler 有什么用？ 原理是啥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal-%E6%9C%89%E5%95%A5%E7%94%A8%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E5%95%A5"><span class="nav-number">2.9.</span> <span class="nav-text">ThreadLocal 有啥用？原理是啥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90"><span class="nav-number">2.9.1.</span> <span class="nav-text">原理浅析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#set-get"><span class="nav-number">2.9.1.1.</span> <span class="nav-text">set&#x2F;get</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ThreadLocalMap"><span class="nav-number">2.9.1.2.</span> <span class="nav-text">ThreadLocalMap</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="nav-number">4.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="九尾灵狐"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">九尾灵狐</p>
  <div class="site-description" itemprop="description">人生不止眼前的苟且，还有诗与远方和田野</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/REBOOTERS" title="GitHub → https://github.com/REBOOTERS" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yingkongshi11@gmail.com" title="E-Mail → mailto:yingkongshi11@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">九尾灵狐</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">614k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:18</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
